import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  _text: any;
  bigint: any;
  blockchain_name: any;
  blockchain_schemas_abi_types: any;
  bpchar: any;
  contract_submission_status: any;
  float8: any;
  interval: any;
  job_categories: any;
  json: any;
  jsonb: any;
  membership_roles: any;
  membership_statuses: any;
  numeric: any;
  smallint: any;
  timestamp: any;
  timestamptz: any;
  tsvector: any;
  uuid: any;
  visualization_types: any;
};


export type AcceptInviteResponse = {
  __typename?: 'AcceptInviteResponse';
  ok: Scalars['Boolean'];
};

export type ApiKeyEntry = {
  __typename?: 'ApiKeyEntry';
  id: Scalars['String'];
  name: Scalars['String'];
  suffix: Scalars['String'];
};

export type AuthProviderUser = {
  __typename?: 'AuthProviderUser';
  email: Scalars['String'];
  emailVerified: Scalars['Boolean'];
  username: Scalars['String'];
};

export type BillableUsageResponse = {
  __typename?: 'BillableUsageResponse';
  credits_included?: Maybe<Scalars['Int']>;
  credits_used: Scalars['Int'];
  csv_downloads: Scalars['Int'];
  datapoints_read: Scalars['Int'];
  extra_credits_cents: Scalars['Float'];
  max_csv_downloads?: Maybe<Scalars['Int']>;
  max_datapoints_read?: Maybe<Scalars['Int']>;
  max_extra_credits_cents?: Maybe<Scalars['Float']>;
  max_query_executions?: Maybe<Scalars['Int']>;
  query_executions: Scalars['Int'];
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: Maybe<Scalars['Boolean']>;
  _gt?: Maybe<Scalars['Boolean']>;
  _gte?: Maybe<Scalars['Boolean']>;
  _in?: Maybe<Array<Scalars['Boolean']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Boolean']>;
  _lte?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Scalars['Boolean']>;
  _nin?: Maybe<Array<Scalars['Boolean']>>;
};

export type CancelApiUserPendingSubscriptionChangeResponse = {
  __typename?: 'CancelApiUserPendingSubscriptionChangeResponse';
  ok: Scalars['Boolean'];
};

export type CancelApiUserSubscriptionResponse = {
  __typename?: 'CancelApiUserSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type CancelExecutionResponse = {
  __typename?: 'CancelExecutionResponse';
  execution_id: Scalars['String'];
};

export type CancelTeamPendingSubscriptionChangeResponse = {
  __typename?: 'CancelTeamPendingSubscriptionChangeResponse';
  ok: Scalars['Boolean'];
};

export type CancelUserPendingSubscriptionChangeResponse = {
  __typename?: 'CancelUserPendingSubscriptionChangeResponse';
  ok: Scalars['Boolean'];
};

export type ChangeEmailOutput = {
  __typename?: 'ChangeEmailOutput';
  new_email: Scalars['String'];
};

export type ChangePasswordResult = {
  __typename?: 'ChangePasswordResult';
  ok: Scalars['Boolean'];
};

export type CompleteNlqModelResponse = {
  __typename?: 'CompleteNlqModelResponse';
  id: Scalars['String'];
  response: Scalars['String'];
};

export type CompleteStripeCheckoutSessionResponse = {
  __typename?: 'CompleteStripeCheckoutSessionResponse';
  card: StripeCard;
};

export type ContextOwner = {
  id: Scalars['Int'];
  type: Scalars['String'];
};

export type CreateDashboardScheduleResponse = {
  __typename?: 'CreateDashboardScheduleResponse';
  cron_job: CronJob;
  dashboard_id: Scalars['Int'];
};

export type CreateFolderInput = {
  color: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  icon: Scalars['String'];
  name: Scalars['String'];
  team_id?: Maybe<Scalars['Int']>;
};

export type CreateMaterializedViewResponse = {
  __typename?: 'CreateMaterializedViewResponse';
  creation_execution_id: Scalars['String'];
  id: Scalars['String'];
  sql_names: Array<Scalars['String']>;
};

export type CreateQueryInput = {
  dataset_id: Scalars['Int'];
  description: Scalars['String'];
  is_private: Scalars['Boolean'];
  is_temp: Scalars['Boolean'];
  name: Scalars['String'];
  parameters?: Maybe<Scalars['json']>;
  query: Scalars['String'];
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

export type CreateQueryResponse = {
  __typename?: 'CreateQueryResponse';
  query_id: Scalars['Int'];
};

export type CreateQueryScheduleResponse = {
  __typename?: 'CreateQueryScheduleResponse';
  cron_job: CronJob;
  query_id: Scalars['Int'];
};

export type CreateTeamApiKeyResponse = {
  __typename?: 'CreateTeamApiKeyResponse';
  id: Scalars['String'];
  key: Scalars['String'];
  name: Scalars['String'];
};

export type CreateTeamCheckoutSessionResponse = {
  __typename?: 'CreateTeamCheckoutSessionResponse';
  checkout_session_id: Scalars['String'];
};

export type CreateTeamResponse = {
  __typename?: 'CreateTeamResponse';
  team_id: Scalars['Int'];
};

export type CreateUserApiKeyResponse = {
  __typename?: 'CreateUserApiKeyResponse';
  id: Scalars['String'];
  key: Scalars['String'];
  name: Scalars['String'];
};

export type CreateUserCheckoutSessionResponse = {
  __typename?: 'CreateUserCheckoutSessionResponse';
  checkout_session_id: Scalars['String'];
};

export type CreateWandQueryResponse = {
  __typename?: 'CreateWandQueryResponse';
  query: Scalars['String'];
  response_id: Scalars['String'];
};

export type CronJob = {
  __typename?: 'CronJob';
  cron_expression?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  metadata: CronJobMetadata;
  next_execution_time?: Maybe<Scalars['timestamptz']>;
  owned_by_customer_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
};

export type CronJobMetadata = {
  __typename?: 'CronJobMetadata';
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

export type DashboardSchedulesResponse = {
  __typename?: 'DashboardSchedulesResponse';
  cron_jobs: Array<CronJob>;
  dashboard_id: Scalars['Int'];
};

export type DashboardSettings = {
  id: Scalars['Int'];
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

export type DebugWandQueryResponse = {
  __typename?: 'DebugWandQueryResponse';
  query: Scalars['String'];
  response_id: Scalars['String'];
};

export type DeleteAccountResult = {
  __typename?: 'DeleteAccountResult';
  ok: Scalars['Boolean'];
};

export type DeleteDashboardScheduleResponse = {
  __typename?: 'DeleteDashboardScheduleResponse';
  cron_job_id: Scalars['String'];
};

export type DeleteQueryScheduleResponse = {
  __typename?: 'DeleteQueryScheduleResponse';
  cron_job_id: Scalars['String'];
};

export type DeleteTeamApiKeyResponse = {
  __typename?: 'DeleteTeamApiKeyResponse';
  id: Scalars['String'];
};

export type DeleteTeamResponse = {
  __typename?: 'DeleteTeamResponse';
  ok: Scalars['Boolean'];
};

export type DeleteUserApiKeyResponse = {
  __typename?: 'DeleteUserApiKeyResponse';
  id: Scalars['String'];
};

export type DowngradeApiUserSubscriptionResponse = {
  __typename?: 'DowngradeApiUserSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type DowngradeTeamSubscriptionResponse = {
  __typename?: 'DowngradeTeamSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type DowngradeUserSubscriptionResponse = {
  __typename?: 'DowngradeUserSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type EditWandQueryResponse = {
  __typename?: 'EditWandQueryResponse';
  query: Scalars['String'];
  response_id: Scalars['String'];
};

export type ErrorMetadata = {
  __typename?: 'ErrorMetadata';
  column: Scalars['Int'];
  hint: Scalars['String'];
  line: Scalars['Int'];
};

export type ExecuteQueryResponse = {
  __typename?: 'ExecuteQueryResponse';
  job_id: Scalars['String'];
};

export type ExecutionFailed = {
  __typename?: 'ExecutionFailed';
  execution_id: Scalars['String'];
  generated_at: Scalars['timestamptz'];
  message: Scalars['String'];
  metadata?: Maybe<ErrorMetadata>;
  runtime_seconds: Scalars['Int'];
  type: Scalars['String'];
};

export type ExecutionQueued = {
  __typename?: 'ExecutionQueued';
  created_at: Scalars['timestamptz'];
  execution_id: Scalars['String'];
  execution_type: Scalars['String'];
  execution_user_id?: Maybe<Scalars['Int']>;
  position: Scalars['Int'];
};

export type ExecutionRunning = {
  __typename?: 'ExecutionRunning';
  created_at: Scalars['timestamptz'];
  execution_id: Scalars['String'];
  execution_type: Scalars['String'];
  execution_user_id?: Maybe<Scalars['Int']>;
  started_at: Scalars['timestamptz'];
};

export type ExecutionSucceeded = {
  __typename?: 'ExecutionSucceeded';
  columns?: Maybe<Array<Scalars['String']>>;
  data?: Maybe<Scalars['json']>;
  execution_id: Scalars['String'];
  generated_at: Scalars['timestamptz'];
  max_result_size_reached_bytes?: Maybe<Scalars['Int']>;
  request_max_result_size_bytes?: Maybe<Scalars['Int']>;
  runtime_seconds: Scalars['Int'];
};

export type ExportCsvResponse = {
  __typename?: 'ExportCSVResponse';
  url: Scalars['String'];
};

export type Folder = {
  __typename?: 'Folder';
  color: Scalars['String'];
  created_at: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  icon: Scalars['String'];
  id: Scalars['String'];
  name: Scalars['String'];
  path: Scalars['String'];
  team_id?: Maybe<Scalars['Int']>;
  updated_at: Scalars['timestamptz'];
  user_id?: Maybe<Scalars['Int']>;
};

export type ForkDashboardResponse = {
  __typename?: 'ForkDashboardResponse';
  slug: Scalars['String'];
};

export type ForkQueryV3Response = {
  __typename?: 'ForkQueryV3Response';
  query_id: Scalars['Int'];
};

export type GetApiUpcomingInvoiceResponse = {
  __typename?: 'GetApiUpcomingInvoiceResponse';
  invoice: UpcomingInvoice;
};

export type GetExecutionResponse = {
  __typename?: 'GetExecutionResponse';
  execution_failed?: Maybe<ExecutionFailed>;
  execution_queued?: Maybe<ExecutionQueued>;
  execution_running?: Maybe<ExecutionRunning>;
  execution_succeeded?: Maybe<ExecutionSucceeded>;
};

export type GetInvoiceResponse = {
  __typename?: 'GetInvoiceResponse';
  invoices: Array<Invoice>;
};

export type GetQueryContributorsResponse = {
  __typename?: 'GetQueryContributorsResponse';
  contributors: Array<QueryContributor>;
};

export type GetQueryEventsResponse = {
  __typename?: 'GetQueryEventsResponse';
  past_retention_window: Scalars['Boolean'];
  results: Array<QueryEvent>;
  retention_days: Scalars['Int'];
};

export type GetResultV3Response = {
  __typename?: 'GetResultV3Response';
  error_id?: Maybe<Scalars['String']>;
  job_id?: Maybe<Scalars['String']>;
  result_id?: Maybe<Scalars['String']>;
};

export type GetResultV4Response = {
  __typename?: 'GetResultV4Response';
  error_id?: Maybe<Scalars['String']>;
  job_id?: Maybe<Scalars['String']>;
  result_id?: Maybe<Scalars['String']>;
};

export type GetTablePreviewResponse = {
  __typename?: 'GetTablePreviewResponse';
  error_id?: Maybe<Scalars['String']>;
  job_id?: Maybe<Scalars['String']>;
  parameters: Array<ParameterObject>;
  query_id: Scalars['Int'];
  result_id?: Maybe<Scalars['String']>;
};

export type GetTeamInvoiceResponse = {
  __typename?: 'GetTeamInvoiceResponse';
  invoices: Array<Invoice>;
};

export type GetTeamUpcomingInvoiceResponse = {
  __typename?: 'GetTeamUpcomingInvoiceResponse';
  invoice: UpcomingInvoice;
};

export type GetUpcomingInvoiceResponse = {
  __typename?: 'GetUpcomingInvoiceResponse';
  invoice: UpcomingInvoice;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: Maybe<Scalars['Int']>;
  _gt?: Maybe<Scalars['Int']>;
  _gte?: Maybe<Scalars['Int']>;
  _in?: Maybe<Array<Scalars['Int']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Int']>;
  _lte?: Maybe<Scalars['Int']>;
  _neq?: Maybe<Scalars['Int']>;
  _nin?: Maybe<Array<Scalars['Int']>>;
};

export type InteractiveExecutions = {
  __typename?: 'InteractiveExecutions';
  credits: Scalars['Int'];
  dataset_id: Scalars['Int'];
  public_performance_tier_key: Scalars['String'];
};

export type InviteMemberResponse = {
  __typename?: 'InviteMemberResponse';
  email?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  role: Scalars['String'];
  status: Scalars['String'];
  team_id: Scalars['Int'];
  user_id?: Maybe<Scalars['Int']>;
};

export type Invoice = {
  __typename?: 'Invoice';
  amount_display: Scalars['String'];
  currency_key: Scalars['String'];
  date: Scalars['timestamptz'];
  href: Scalars['String'];
  plan_display_name?: Maybe<Scalars['String']>;
  source: Scalars['String'];
  status: Scalars['String'];
};

export type ListTeamApiKeysResponse = {
  __typename?: 'ListTeamApiKeysResponse';
  keys: Array<ApiKeyEntry>;
};

export type ListUserApiKeysResponse = {
  __typename?: 'ListUserApiKeysResponse';
  keys: Array<ApiKeyEntry>;
};

export type MigrateContentResponse = {
  __typename?: 'MigrateContentResponse';
  migrated_dashboards: Scalars['Int'];
  migrated_queries: Scalars['Int'];
  total_dashboards: Scalars['Int'];
  total_queries: Scalars['Int'];
};

export type MigrateLegacyPlanInput = {
  service_tier_id: Scalars['Int'];
  team_id?: Maybe<Scalars['Int']>;
};

export type MigrateLegacyPlanResponse = {
  __typename?: 'MigrateLegacyPlanResponse';
  ok: Scalars['Boolean'];
};

export type OperationCosts = {
  __typename?: 'OperationCosts';
  interactive_executions: Array<InteractiveExecutions>;
  key: Scalars['String'];
};

export type Parameter = {
  enumOptions?: Maybe<Array<Scalars['String']>>;
  key: Scalars['String'];
  type: Scalars['String'];
  value: Scalars['String'];
};

export type ParameterObject = {
  __typename?: 'ParameterObject';
  enumOptions?: Maybe<Array<Scalars['String']>>;
  key: Scalars['String'];
  type: Scalars['String'];
  value: Scalars['String'];
};

export type PatchDashboardSettingsResponse = {
  __typename?: 'PatchDashboardSettingsResponse';
  dashboard?: Maybe<Dashboards>;
  dashboard_id: Scalars['Int'];
};

export type PatchQuerySettingsResponse = {
  __typename?: 'PatchQuerySettingsResponse';
  query?: Maybe<Queries>;
  query_id: Scalars['Int'];
};

export type PresignedUrlResponse = {
  __typename?: 'PresignedUrlResponse';
  url: Scalars['String'];
};

export type QueryContributor = {
  __typename?: 'QueryContributor';
  contributions: Scalars['Int'];
  handle: Scalars['String'];
  profile_image_url?: Maybe<Scalars['String']>;
  query_id: Scalars['Int'];
  user_id: Scalars['Int'];
};

export type QueryEvent = {
  __typename?: 'QueryEvent';
  created_at: Scalars['timestamptz'];
  from: Scalars['json'];
  id: Scalars['String'];
  metadata?: Maybe<QueryEventMetadata>;
  query_id: Scalars['Int'];
  query_version: Scalars['Int'];
  team_id?: Maybe<Scalars['Int']>;
  to: Scalars['json'];
  type: Scalars['String'];
  user_id?: Maybe<Scalars['Int']>;
};

export type QueryEventMetadata = {
  __typename?: 'QueryEventMetadata';
  created_at: Scalars['timestamptz'];
  description: Scalars['String'];
  name: Scalars['String'];
  query_event_id: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_id: Scalars['Int'];
};

export type QuerySchedulesResponse = {
  __typename?: 'QuerySchedulesResponse';
  cron_jobs: Array<CronJob>;
  query_id: Scalars['Int'];
};

export type QuerySettings = {
  id: Scalars['Int'];
  is_archived?: Maybe<Scalars['Boolean']>;
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

export type RemoveMemberResponse = {
  __typename?: 'RemoveMemberResponse';
  ok: Scalars['Boolean'];
};

export type ResendEmailVerificationCodeOutput = {
  __typename?: 'ResendEmailVerificationCodeOutput';
  ok: Scalars['Boolean'];
};

export type ResendInviteResponse = {
  __typename?: 'ResendInviteResponse';
  ok: Scalars['Boolean'];
};

export type RestoreQueryResponse = {
  __typename?: 'RestoreQueryResponse';
  query_id: Scalars['Int'];
};

export type SearchContractsProject = {
  __typename?: 'SearchContractsProject';
  blockchains: Array<Scalars['String']>;
  namespace: Scalars['String'];
};

export type SearchContractsResponse = {
  __typename?: 'SearchContractsResponse';
  projects: Array<SearchContractsProject>;
};

export type SetMaxExecutionsOverageCostCentsResponse = {
  __typename?: 'SetMaxExecutionsOverageCostCentsResponse';
  user: SetMaxExecutionsOverageCostCentsUpdatedUser;
};

export type SetMaxExecutionsOverageCostCentsUpdatedTeam = {
  __typename?: 'SetMaxExecutionsOverageCostCentsUpdatedTeam';
  execution_quota_exceeded_until?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
};

export type SetMaxExecutionsOverageCostCentsUpdatedUser = {
  __typename?: 'SetMaxExecutionsOverageCostCentsUpdatedUser';
  execution_quota_exceeded_until?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
};

export type SetMaxOverageCentsResponse = {
  __typename?: 'SetMaxOverageCentsResponse';
  max_overage_cents?: Maybe<Scalars['Int']>;
};

export type SetTeamMaxExecutionsOverageCostCentsResponse = {
  __typename?: 'SetTeamMaxExecutionsOverageCostCentsResponse';
  team: SetMaxExecutionsOverageCostCentsUpdatedTeam;
};

export type SetTeamMaxOverageCentsResponse = {
  __typename?: 'SetTeamMaxOverageCentsResponse';
  team: SetTeamMaxOverageCentsUpdatedTeam;
};

export type SetTeamMaxOverageCentsUpdatedTeam = {
  __typename?: 'SetTeamMaxOverageCentsUpdatedTeam';
  id: Scalars['Int'];
  max_overage_cents?: Maybe<Scalars['Int']>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: Maybe<Scalars['String']>;
  _gt?: Maybe<Scalars['String']>;
  _gte?: Maybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['String']>;
  _in?: Maybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['String']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['String']>;
  _lt?: Maybe<Scalars['String']>;
  _lte?: Maybe<Scalars['String']>;
  _neq?: Maybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['String']>;
  _nin?: Maybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['String']>;
};

export type StripeCard = {
  __typename?: 'StripeCard';
  brand: Scalars['String'];
  exp_month: Scalars['Int'];
  exp_year: Scalars['Int'];
  last4: Scalars['String'];
};

export type StripeDefaultCardResponse = {
  __typename?: 'StripeDefaultCardResponse';
  card?: Maybe<StripeCard>;
};

export type TeamBillableUsageResponse = {
  __typename?: 'TeamBillableUsageResponse';
  credits_included?: Maybe<Scalars['Int']>;
  credits_used: Scalars['Int'];
  csv_downloads: Scalars['Int'];
  datapoints_read: Scalars['Int'];
  extra_credits_cents: Scalars['Float'];
  max_csv_downloads?: Maybe<Scalars['Int']>;
  max_datapoints_read?: Maybe<Scalars['Int']>;
  max_extra_credits_cents?: Maybe<Scalars['Float']>;
  max_query_executions?: Maybe<Scalars['Int']>;
  query_executions: Scalars['Int'];
};

export type TeamStripeDefaultCardResponse = {
  __typename?: 'TeamStripeDefaultCardResponse';
  card?: Maybe<StripeCard>;
};

export type TerminateApiUserSubscriptionResponse = {
  __typename?: 'TerminateApiUserSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type TransferDashboardsResponse = {
  __typename?: 'TransferDashboardsResponse';
  dashboard?: Maybe<Dashboards>;
  dashboard_id: Scalars['Int'];
  ok: Scalars['Boolean'];
};

export type TransferQueriesResponse = {
  __typename?: 'TransferQueriesResponse';
  ok: Scalars['Boolean'];
  query?: Maybe<Queries>;
  query_id: Scalars['Int'];
};

export type UnlinkWalletAddressResult = {
  __typename?: 'UnlinkWalletAddressResult';
  ok: Scalars['Boolean'];
};

export type UpcomingInvoice = {
  __typename?: 'UpcomingInvoice';
  amount_due: Scalars['String'];
  currency: Scalars['String'];
  hosted_invoice_url: Scalars['String'];
  target_date: Scalars['String'];
};

export type UpdateAccountForServiceTierResponse = {
  __typename?: 'UpdateAccountForServiceTierResponse';
  archived_dashboards_count: Scalars['Int'];
  archived_queries_count: Scalars['Int'];
};

export type UpdateDashboardScheduleResponse = {
  __typename?: 'UpdateDashboardScheduleResponse';
  cron_job: CronJob;
  dashboard_id: Scalars['Int'];
};

export type UpdateFolderInput = {
  color: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  icon: Scalars['String'];
  id: Scalars['String'];
  name: Scalars['String'];
};

export type UpdateQueryInput = {
  dataset_id: Scalars['Int'];
  description: Scalars['String'];
  id: Scalars['Int'];
  is_archived: Scalars['Boolean'];
  is_private: Scalars['Boolean'];
  is_temp: Scalars['Boolean'];
  name: Scalars['String'];
  parameters: Scalars['json'];
  query: Scalars['String'];
  schedule?: Maybe<Scalars['interval']>;
  tags: Scalars['json'];
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
  version: Scalars['Int'];
};

export type UpdateQueryResponse = {
  __typename?: 'UpdateQueryResponse';
  query_id: Scalars['Int'];
};

export type UpdateQueryScheduleResponse = {
  __typename?: 'UpdateQueryScheduleResponse';
  cron_job: CronJob;
  query_id: Scalars['Int'];
};

export type UpdateTeamAccountForServiceTierResponse = {
  __typename?: 'UpdateTeamAccountForServiceTierResponse';
  archived_dashboards_count: Scalars['Int'];
  archived_queries_count: Scalars['Int'];
};

export type UpgradeApiUserSubscriptionResponse = {
  __typename?: 'UpgradeApiUserSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type UpgradeTeamSubscriptionResponse = {
  __typename?: 'UpgradeTeamSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type UpgradeUserSubscriptionResponse = {
  __typename?: 'UpgradeUserSubscriptionResponse';
  ok: Scalars['Boolean'];
};

export type UploadedTable = {
  __typename?: 'UploadedTable';
  file_name: Scalars['String'];
  status: Scalars['String'];
  table_name: Scalars['String'];
  type: Scalars['String'];
};

export type UpsertQueryEventMetadataInput = {
  description: Scalars['String'];
  name: Scalars['String'];
};

export type VerifyEmailOutput = {
  __typename?: 'VerifyEmailOutput';
  ok: Scalars['Boolean'];
};


/** Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'. */
export type _Text_Comparison_Exp = {
  _eq?: Maybe<Scalars['_text']>;
  _gt?: Maybe<Scalars['_text']>;
  _gte?: Maybe<Scalars['_text']>;
  _in?: Maybe<Array<Scalars['_text']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['_text']>;
  _lte?: Maybe<Scalars['_text']>;
  _neq?: Maybe<Scalars['_text']>;
  _nin?: Maybe<Array<Scalars['_text']>>;
};

/** columns and relationships of "api_keys" */
export type Api_Keys = {
  __typename?: 'api_keys';
  active: Scalars['Boolean'];
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dashboard?: Maybe<Dashboards>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id: Scalars['String'];
  /** An object relationship */
  query?: Maybe<Queries>;
  query_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  team?: Maybe<Teams>;
  team_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "api_keys" */
export type Api_Keys_Aggregate = {
  __typename?: 'api_keys_aggregate';
  aggregate?: Maybe<Api_Keys_Aggregate_Fields>;
  nodes: Array<Api_Keys>;
};

export type Api_Keys_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Api_Keys_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Api_Keys_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Api_Keys_Aggregate_Bool_Exp_Count>;
};

export type Api_Keys_Aggregate_Bool_Exp_Bool_And = {
  arguments: Api_Keys_Select_Column_Api_Keys_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Api_Keys_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Api_Keys_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Api_Keys_Select_Column_Api_Keys_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Api_Keys_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Api_Keys_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Api_Keys_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Api_Keys_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "api_keys" */
export type Api_Keys_Aggregate_Fields = {
  __typename?: 'api_keys_aggregate_fields';
  avg?: Maybe<Api_Keys_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Api_Keys_Max_Fields>;
  min?: Maybe<Api_Keys_Min_Fields>;
  stddev?: Maybe<Api_Keys_Stddev_Fields>;
  stddev_pop?: Maybe<Api_Keys_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Api_Keys_Stddev_Samp_Fields>;
  sum?: Maybe<Api_Keys_Sum_Fields>;
  var_pop?: Maybe<Api_Keys_Var_Pop_Fields>;
  var_samp?: Maybe<Api_Keys_Var_Samp_Fields>;
  variance?: Maybe<Api_Keys_Variance_Fields>;
};


/** aggregate fields of "api_keys" */
export type Api_Keys_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Api_Keys_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "api_keys" */
export type Api_Keys_Aggregate_Order_By = {
  avg?: Maybe<Api_Keys_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Api_Keys_Max_Order_By>;
  min?: Maybe<Api_Keys_Min_Order_By>;
  stddev?: Maybe<Api_Keys_Stddev_Order_By>;
  stddev_pop?: Maybe<Api_Keys_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Api_Keys_Stddev_Samp_Order_By>;
  sum?: Maybe<Api_Keys_Sum_Order_By>;
  var_pop?: Maybe<Api_Keys_Var_Pop_Order_By>;
  var_samp?: Maybe<Api_Keys_Var_Samp_Order_By>;
  variance?: Maybe<Api_Keys_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "api_keys" */
export type Api_Keys_Arr_Rel_Insert_Input = {
  data: Array<Api_Keys_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Api_Keys_On_Conflict>;
};

/** aggregate avg on columns */
export type Api_Keys_Avg_Fields = {
  __typename?: 'api_keys_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "api_keys" */
export type Api_Keys_Avg_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "api_keys". All fields are combined with a logical 'AND'. */
export type Api_Keys_Bool_Exp = {
  _and?: Maybe<Array<Api_Keys_Bool_Exp>>;
  _not?: Maybe<Api_Keys_Bool_Exp>;
  _or?: Maybe<Array<Api_Keys_Bool_Exp>>;
  active?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dashboard?: Maybe<Dashboards_Bool_Exp>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<String_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "api_keys" */
export enum Api_Keys_Constraint {
  /** unique or primary key constraint on columns "id" */
  ApiKeysPkey = 'api_keys_pkey'
}

/** input type for incrementing numeric columns in table "api_keys" */
export type Api_Keys_Inc_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "api_keys" */
export type Api_Keys_Insert_Input = {
  active?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  team_id?: Maybe<Scalars['Int']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Api_Keys_Max_Fields = {
  __typename?: 'api_keys_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "api_keys" */
export type Api_Keys_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Api_Keys_Min_Fields = {
  __typename?: 'api_keys_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "api_keys" */
export type Api_Keys_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "api_keys" */
export type Api_Keys_Mutation_Response = {
  __typename?: 'api_keys_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Api_Keys>;
};

/** input type for inserting object relation for remote table "api_keys" */
export type Api_Keys_Obj_Rel_Insert_Input = {
  data: Api_Keys_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Api_Keys_On_Conflict>;
};

/** on_conflict condition type for table "api_keys" */
export type Api_Keys_On_Conflict = {
  constraint: Api_Keys_Constraint;
  update_columns: Array<Api_Keys_Update_Column>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};

/** Ordering options when selecting data from "api_keys". */
export type Api_Keys_Order_By = {
  active?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dashboard?: Maybe<Dashboards_Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_id?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  team_id?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: api_keys */
export type Api_Keys_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "api_keys" */
export enum Api_Keys_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UserId = 'user_id'
}

/** select "api_keys_aggregate_bool_exp_bool_and_arguments_columns" columns of table "api_keys" */
export enum Api_Keys_Select_Column_Api_Keys_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** select "api_keys_aggregate_bool_exp_bool_or_arguments_columns" columns of table "api_keys" */
export enum Api_Keys_Select_Column_Api_Keys_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** input type for updating data in table "api_keys" */
export type Api_Keys_Set_Input = {
  active?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Api_Keys_Stddev_Fields = {
  __typename?: 'api_keys_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "api_keys" */
export type Api_Keys_Stddev_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Api_Keys_Stddev_Pop_Fields = {
  __typename?: 'api_keys_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "api_keys" */
export type Api_Keys_Stddev_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Api_Keys_Stddev_Samp_Fields = {
  __typename?: 'api_keys_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "api_keys" */
export type Api_Keys_Stddev_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "api_keys" */
export type Api_Keys_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Api_Keys_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Api_Keys_Stream_Cursor_Value_Input = {
  active?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Api_Keys_Sum_Fields = {
  __typename?: 'api_keys_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "api_keys" */
export type Api_Keys_Sum_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** update columns of table "api_keys" */
export enum Api_Keys_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UserId = 'user_id'
}

export type Api_Keys_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Api_Keys_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Api_Keys_Set_Input>;
  where: Api_Keys_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Api_Keys_Var_Pop_Fields = {
  __typename?: 'api_keys_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "api_keys" */
export type Api_Keys_Var_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Api_Keys_Var_Samp_Fields = {
  __typename?: 'api_keys_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "api_keys" */
export type Api_Keys_Var_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Api_Keys_Variance_Fields = {
  __typename?: 'api_keys_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "api_keys" */
export type Api_Keys_Variance_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** columns and relationships of "api_user_service_tiers" */
export type Api_User_Service_Tiers = {
  __typename?: 'api_user_service_tiers';
  base_monthly_price_dollars_cents: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  datapoint_overage_10k_cost_dollars_cents: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  dune_attribution_required: Scalars['Boolean'];
  id: Scalars['Int'];
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  is_public?: Maybe<Scalars['Boolean']>;
  name: Scalars['String'];
  orb_base_plan_id?: Maybe<Scalars['String']>;
  /** An array relationship */
  pending_api_user_subscription_updates: Array<Pending_Api_User_Subscription_Updates>;
  /** An aggregate relationship */
  pending_api_user_subscription_updates_aggregate: Pending_Api_User_Subscription_Updates_Aggregate;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  users: Array<Users>;
  /** An aggregate relationship */
  users_aggregate: Users_Aggregate;
};


/** columns and relationships of "api_user_service_tiers" */
export type Api_User_Service_TiersPending_Api_User_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Api_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};


/** columns and relationships of "api_user_service_tiers" */
export type Api_User_Service_TiersPending_Api_User_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Api_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};


/** columns and relationships of "api_user_service_tiers" */
export type Api_User_Service_TiersUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


/** columns and relationships of "api_user_service_tiers" */
export type Api_User_Service_TiersUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};

/** aggregated selection of "api_user_service_tiers" */
export type Api_User_Service_Tiers_Aggregate = {
  __typename?: 'api_user_service_tiers_aggregate';
  aggregate?: Maybe<Api_User_Service_Tiers_Aggregate_Fields>;
  nodes: Array<Api_User_Service_Tiers>;
};

/** aggregate fields of "api_user_service_tiers" */
export type Api_User_Service_Tiers_Aggregate_Fields = {
  __typename?: 'api_user_service_tiers_aggregate_fields';
  avg?: Maybe<Api_User_Service_Tiers_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Api_User_Service_Tiers_Max_Fields>;
  min?: Maybe<Api_User_Service_Tiers_Min_Fields>;
  stddev?: Maybe<Api_User_Service_Tiers_Stddev_Fields>;
  stddev_pop?: Maybe<Api_User_Service_Tiers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Api_User_Service_Tiers_Stddev_Samp_Fields>;
  sum?: Maybe<Api_User_Service_Tiers_Sum_Fields>;
  var_pop?: Maybe<Api_User_Service_Tiers_Var_Pop_Fields>;
  var_samp?: Maybe<Api_User_Service_Tiers_Var_Samp_Fields>;
  variance?: Maybe<Api_User_Service_Tiers_Variance_Fields>;
};


/** aggregate fields of "api_user_service_tiers" */
export type Api_User_Service_Tiers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Api_User_Service_Tiers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Api_User_Service_Tiers_Avg_Fields = {
  __typename?: 'api_user_service_tiers_avg_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_executions?: Maybe<Scalars['Float']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "api_user_service_tiers". All fields are combined with a logical 'AND'. */
export type Api_User_Service_Tiers_Bool_Exp = {
  _and?: Maybe<Array<Api_User_Service_Tiers_Bool_Exp>>;
  _not?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
  _or?: Maybe<Array<Api_User_Service_Tiers_Bool_Exp>>;
  base_monthly_price_dollars_cents?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Int_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  dune_attribution_required?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  included_datapoints?: Maybe<Int_Comparison_Exp>;
  included_executions?: Maybe<Int_Comparison_Exp>;
  is_public?: Maybe<Boolean_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  orb_base_plan_id?: Maybe<String_Comparison_Exp>;
  pending_api_user_subscription_updates?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
  pending_api_user_subscription_updates_aggregate?: Maybe<Pending_Api_User_Subscription_Updates_Aggregate_Bool_Exp>;
  read_results_api_calls_per_minute?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  users?: Maybe<Users_Bool_Exp>;
  users_aggregate?: Maybe<Users_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "api_user_service_tiers" */
export enum Api_User_Service_Tiers_Constraint {
  /** unique or primary key constraint on columns "id" */
  ApiUserServiceTiersPkey = 'api_user_service_tiers_pkey'
}

/** input type for incrementing numeric columns in table "api_user_service_tiers" */
export type Api_User_Service_Tiers_Inc_Input = {
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "api_user_service_tiers" */
export type Api_User_Service_Tiers_Insert_Input = {
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  dune_attribution_required?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  is_public?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  pending_api_user_subscription_updates?: Maybe<Pending_Api_User_Subscription_Updates_Arr_Rel_Insert_Input>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  users?: Maybe<Users_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Api_User_Service_Tiers_Max_Fields = {
  __typename?: 'api_user_service_tiers_max_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Api_User_Service_Tiers_Min_Fields = {
  __typename?: 'api_user_service_tiers_min_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "api_user_service_tiers" */
export type Api_User_Service_Tiers_Mutation_Response = {
  __typename?: 'api_user_service_tiers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Api_User_Service_Tiers>;
};

/** input type for inserting object relation for remote table "api_user_service_tiers" */
export type Api_User_Service_Tiers_Obj_Rel_Insert_Input = {
  data: Api_User_Service_Tiers_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Api_User_Service_Tiers_On_Conflict>;
};

/** on_conflict condition type for table "api_user_service_tiers" */
export type Api_User_Service_Tiers_On_Conflict = {
  constraint: Api_User_Service_Tiers_Constraint;
  update_columns: Array<Api_User_Service_Tiers_Update_Column>;
  where?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
};

/** Ordering options when selecting data from "api_user_service_tiers". */
export type Api_User_Service_Tiers_Order_By = {
  base_monthly_price_dollars_cents?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  dune_attribution_required?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  included_datapoints?: Maybe<Order_By>;
  included_executions?: Maybe<Order_By>;
  is_public?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  orb_base_plan_id?: Maybe<Order_By>;
  pending_api_user_subscription_updates_aggregate?: Maybe<Pending_Api_User_Subscription_Updates_Aggregate_Order_By>;
  read_results_api_calls_per_minute?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  users_aggregate?: Maybe<Users_Aggregate_Order_By>;
};

/** primary key columns input for table: api_user_service_tiers */
export type Api_User_Service_Tiers_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "api_user_service_tiers" */
export enum Api_User_Service_Tiers_Select_Column {
  /** column name */
  BaseMonthlyPriceDollarsCents = 'base_monthly_price_dollars_cents',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatapointOverage_10kCostDollarsCents = 'datapoint_overage_10k_cost_dollars_cents',
  /** column name */
  Description = 'description',
  /** column name */
  DuneAttributionRequired = 'dune_attribution_required',
  /** column name */
  Id = 'id',
  /** column name */
  IncludedDatapoints = 'included_datapoints',
  /** column name */
  IncludedExecutions = 'included_executions',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  Name = 'name',
  /** column name */
  OrbBasePlanId = 'orb_base_plan_id',
  /** column name */
  ReadResultsApiCallsPerMinute = 'read_results_api_calls_per_minute',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "api_user_service_tiers" */
export type Api_User_Service_Tiers_Set_Input = {
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  dune_attribution_required?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  is_public?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Api_User_Service_Tiers_Stddev_Fields = {
  __typename?: 'api_user_service_tiers_stddev_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_executions?: Maybe<Scalars['Float']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Api_User_Service_Tiers_Stddev_Pop_Fields = {
  __typename?: 'api_user_service_tiers_stddev_pop_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_executions?: Maybe<Scalars['Float']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Api_User_Service_Tiers_Stddev_Samp_Fields = {
  __typename?: 'api_user_service_tiers_stddev_samp_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_executions?: Maybe<Scalars['Float']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "api_user_service_tiers" */
export type Api_User_Service_Tiers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Api_User_Service_Tiers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Api_User_Service_Tiers_Stream_Cursor_Value_Input = {
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  dune_attribution_required?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  is_public?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Api_User_Service_Tiers_Sum_Fields = {
  __typename?: 'api_user_service_tiers_sum_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_executions?: Maybe<Scalars['Int']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Int']>;
};

/** update columns of table "api_user_service_tiers" */
export enum Api_User_Service_Tiers_Update_Column {
  /** column name */
  BaseMonthlyPriceDollarsCents = 'base_monthly_price_dollars_cents',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatapointOverage_10kCostDollarsCents = 'datapoint_overage_10k_cost_dollars_cents',
  /** column name */
  Description = 'description',
  /** column name */
  DuneAttributionRequired = 'dune_attribution_required',
  /** column name */
  Id = 'id',
  /** column name */
  IncludedDatapoints = 'included_datapoints',
  /** column name */
  IncludedExecutions = 'included_executions',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  Name = 'name',
  /** column name */
  OrbBasePlanId = 'orb_base_plan_id',
  /** column name */
  ReadResultsApiCallsPerMinute = 'read_results_api_calls_per_minute',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Api_User_Service_Tiers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Api_User_Service_Tiers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Api_User_Service_Tiers_Set_Input>;
  where: Api_User_Service_Tiers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Api_User_Service_Tiers_Var_Pop_Fields = {
  __typename?: 'api_user_service_tiers_var_pop_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_executions?: Maybe<Scalars['Float']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Api_User_Service_Tiers_Var_Samp_Fields = {
  __typename?: 'api_user_service_tiers_var_samp_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_executions?: Maybe<Scalars['Float']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Api_User_Service_Tiers_Variance_Fields = {
  __typename?: 'api_user_service_tiers_variance_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  datapoint_overage_10k_cost_dollars_cents?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_executions?: Maybe<Scalars['Float']>;
  read_results_api_calls_per_minute?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "arrakis_schemas" */
export type Arrakis_Schemas = {
  __typename?: 'arrakis_schemas';
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['String']>;
  abstraction_tier?: Maybe<Scalars['String']>;
  abstraction_type?: Maybe<Scalars['String']>;
  blockchains: Scalars['jsonb'];
  category: Scalars['String'];
  column_name: Scalars['String'];
  contract_name?: Maybe<Scalars['String']>;
  contributors?: Maybe<Scalars['jsonb']>;
  created_at: Scalars['timestamptz'];
  data_type: Scalars['String'];
  dataset_id: Scalars['Int'];
  full_name: Scalars['String'];
  id: Scalars['String'];
  namespace: Scalars['String'];
  search_vector: Scalars['tsvector'];
  table_name: Scalars['String'];
};


/** columns and relationships of "arrakis_schemas" */
export type Arrakis_SchemasBlockchainsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "arrakis_schemas" */
export type Arrakis_SchemasContributorsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "arrakis_schemas" */
export type Arrakis_Schemas_Aggregate = {
  __typename?: 'arrakis_schemas_aggregate';
  aggregate?: Maybe<Arrakis_Schemas_Aggregate_Fields>;
  nodes: Array<Arrakis_Schemas>;
};

/** aggregate fields of "arrakis_schemas" */
export type Arrakis_Schemas_Aggregate_Fields = {
  __typename?: 'arrakis_schemas_aggregate_fields';
  avg?: Maybe<Arrakis_Schemas_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Arrakis_Schemas_Max_Fields>;
  min?: Maybe<Arrakis_Schemas_Min_Fields>;
  stddev?: Maybe<Arrakis_Schemas_Stddev_Fields>;
  stddev_pop?: Maybe<Arrakis_Schemas_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arrakis_Schemas_Stddev_Samp_Fields>;
  sum?: Maybe<Arrakis_Schemas_Sum_Fields>;
  var_pop?: Maybe<Arrakis_Schemas_Var_Pop_Fields>;
  var_samp?: Maybe<Arrakis_Schemas_Var_Samp_Fields>;
  variance?: Maybe<Arrakis_Schemas_Variance_Fields>;
};


/** aggregate fields of "arrakis_schemas" */
export type Arrakis_Schemas_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Arrakis_Schemas_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Arrakis_Schemas_Append_Input = {
  blockchains?: Maybe<Scalars['jsonb']>;
  contributors?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Arrakis_Schemas_Avg_Fields = {
  __typename?: 'arrakis_schemas_avg_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "arrakis_schemas". All fields are combined with a logical 'AND'. */
export type Arrakis_Schemas_Bool_Exp = {
  _and?: Maybe<Array<Arrakis_Schemas_Bool_Exp>>;
  _not?: Maybe<Arrakis_Schemas_Bool_Exp>;
  _or?: Maybe<Array<Arrakis_Schemas_Bool_Exp>>;
  abi_name?: Maybe<String_Comparison_Exp>;
  abi_type?: Maybe<String_Comparison_Exp>;
  abstraction_tier?: Maybe<String_Comparison_Exp>;
  abstraction_type?: Maybe<String_Comparison_Exp>;
  blockchains?: Maybe<Jsonb_Comparison_Exp>;
  category?: Maybe<String_Comparison_Exp>;
  column_name?: Maybe<String_Comparison_Exp>;
  contract_name?: Maybe<String_Comparison_Exp>;
  contributors?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  data_type?: Maybe<String_Comparison_Exp>;
  dataset_id?: Maybe<Int_Comparison_Exp>;
  full_name?: Maybe<String_Comparison_Exp>;
  id?: Maybe<String_Comparison_Exp>;
  namespace?: Maybe<String_Comparison_Exp>;
  search_vector?: Maybe<Tsvector_Comparison_Exp>;
  table_name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "arrakis_schemas" */
export enum Arrakis_Schemas_Constraint {
  /** unique or primary key constraint on columns "full_name", "column_name", "dataset_id" */
  ArrakisSchemasDatasetIdFullNameColumnNameKey = 'arrakis_schemas_dataset_id_full_name_column_name_key',
  /** unique or primary key constraint on columns "id" */
  ArrakisSchemasPkey = 'arrakis_schemas_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Arrakis_Schemas_Delete_At_Path_Input = {
  blockchains?: Maybe<Array<Scalars['String']>>;
  contributors?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Arrakis_Schemas_Delete_Elem_Input = {
  blockchains?: Maybe<Scalars['Int']>;
  contributors?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Arrakis_Schemas_Delete_Key_Input = {
  blockchains?: Maybe<Scalars['String']>;
  contributors?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "arrakis_schemas" */
export type Arrakis_Schemas_Inc_Input = {
  dataset_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "arrakis_schemas" */
export type Arrakis_Schemas_Insert_Input = {
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['String']>;
  abstraction_tier?: Maybe<Scalars['String']>;
  abstraction_type?: Maybe<Scalars['String']>;
  blockchains?: Maybe<Scalars['jsonb']>;
  category?: Maybe<Scalars['String']>;
  column_name?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  contributors?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  namespace?: Maybe<Scalars['String']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  table_name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Arrakis_Schemas_Max_Fields = {
  __typename?: 'arrakis_schemas_max_fields';
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['String']>;
  abstraction_tier?: Maybe<Scalars['String']>;
  abstraction_type?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  column_name?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  namespace?: Maybe<Scalars['String']>;
  table_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Arrakis_Schemas_Min_Fields = {
  __typename?: 'arrakis_schemas_min_fields';
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['String']>;
  abstraction_tier?: Maybe<Scalars['String']>;
  abstraction_type?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  column_name?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  namespace?: Maybe<Scalars['String']>;
  table_name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "arrakis_schemas" */
export type Arrakis_Schemas_Mutation_Response = {
  __typename?: 'arrakis_schemas_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Arrakis_Schemas>;
};

/** on_conflict condition type for table "arrakis_schemas" */
export type Arrakis_Schemas_On_Conflict = {
  constraint: Arrakis_Schemas_Constraint;
  update_columns: Array<Arrakis_Schemas_Update_Column>;
  where?: Maybe<Arrakis_Schemas_Bool_Exp>;
};

/** Ordering options when selecting data from "arrakis_schemas". */
export type Arrakis_Schemas_Order_By = {
  abi_name?: Maybe<Order_By>;
  abi_type?: Maybe<Order_By>;
  abstraction_tier?: Maybe<Order_By>;
  abstraction_type?: Maybe<Order_By>;
  blockchains?: Maybe<Order_By>;
  category?: Maybe<Order_By>;
  column_name?: Maybe<Order_By>;
  contract_name?: Maybe<Order_By>;
  contributors?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  data_type?: Maybe<Order_By>;
  dataset_id?: Maybe<Order_By>;
  full_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  namespace?: Maybe<Order_By>;
  search_vector?: Maybe<Order_By>;
  table_name?: Maybe<Order_By>;
};

/** primary key columns input for table: arrakis_schemas */
export type Arrakis_Schemas_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Arrakis_Schemas_Prepend_Input = {
  blockchains?: Maybe<Scalars['jsonb']>;
  contributors?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "arrakis_schemas" */
export enum Arrakis_Schemas_Select_Column {
  /** column name */
  AbiName = 'abi_name',
  /** column name */
  AbiType = 'abi_type',
  /** column name */
  AbstractionTier = 'abstraction_tier',
  /** column name */
  AbstractionType = 'abstraction_type',
  /** column name */
  Blockchains = 'blockchains',
  /** column name */
  Category = 'category',
  /** column name */
  ColumnName = 'column_name',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  Contributors = 'contributors',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataType = 'data_type',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  FullName = 'full_name',
  /** column name */
  Id = 'id',
  /** column name */
  Namespace = 'namespace',
  /** column name */
  SearchVector = 'search_vector',
  /** column name */
  TableName = 'table_name'
}

/** input type for updating data in table "arrakis_schemas" */
export type Arrakis_Schemas_Set_Input = {
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['String']>;
  abstraction_tier?: Maybe<Scalars['String']>;
  abstraction_type?: Maybe<Scalars['String']>;
  blockchains?: Maybe<Scalars['jsonb']>;
  category?: Maybe<Scalars['String']>;
  column_name?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  contributors?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  namespace?: Maybe<Scalars['String']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  table_name?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Arrakis_Schemas_Stddev_Fields = {
  __typename?: 'arrakis_schemas_stddev_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Arrakis_Schemas_Stddev_Pop_Fields = {
  __typename?: 'arrakis_schemas_stddev_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Arrakis_Schemas_Stddev_Samp_Fields = {
  __typename?: 'arrakis_schemas_stddev_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "arrakis_schemas" */
export type Arrakis_Schemas_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arrakis_Schemas_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arrakis_Schemas_Stream_Cursor_Value_Input = {
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['String']>;
  abstraction_tier?: Maybe<Scalars['String']>;
  abstraction_type?: Maybe<Scalars['String']>;
  blockchains?: Maybe<Scalars['jsonb']>;
  category?: Maybe<Scalars['String']>;
  column_name?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  contributors?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  namespace?: Maybe<Scalars['String']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  table_name?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Arrakis_Schemas_Sum_Fields = {
  __typename?: 'arrakis_schemas_sum_fields';
  dataset_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "arrakis_schemas" */
export enum Arrakis_Schemas_Update_Column {
  /** column name */
  AbiName = 'abi_name',
  /** column name */
  AbiType = 'abi_type',
  /** column name */
  AbstractionTier = 'abstraction_tier',
  /** column name */
  AbstractionType = 'abstraction_type',
  /** column name */
  Blockchains = 'blockchains',
  /** column name */
  Category = 'category',
  /** column name */
  ColumnName = 'column_name',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  Contributors = 'contributors',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataType = 'data_type',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  FullName = 'full_name',
  /** column name */
  Id = 'id',
  /** column name */
  Namespace = 'namespace',
  /** column name */
  SearchVector = 'search_vector',
  /** column name */
  TableName = 'table_name'
}

export type Arrakis_Schemas_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Arrakis_Schemas_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Arrakis_Schemas_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Arrakis_Schemas_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Arrakis_Schemas_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Arrakis_Schemas_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Arrakis_Schemas_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Arrakis_Schemas_Set_Input>;
  where: Arrakis_Schemas_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arrakis_Schemas_Var_Pop_Fields = {
  __typename?: 'arrakis_schemas_var_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Arrakis_Schemas_Var_Samp_Fields = {
  __typename?: 'arrakis_schemas_var_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Arrakis_Schemas_Variance_Fields = {
  __typename?: 'arrakis_schemas_variance_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};


/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: Maybe<Scalars['bigint']>;
  _gt?: Maybe<Scalars['bigint']>;
  _gte?: Maybe<Scalars['bigint']>;
  _in?: Maybe<Array<Scalars['bigint']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['bigint']>;
  _lte?: Maybe<Scalars['bigint']>;
  _neq?: Maybe<Scalars['bigint']>;
  _nin?: Maybe<Array<Scalars['bigint']>>;
};


/** Boolean expression to compare columns of type "blockchain_name". All fields are combined with logical 'AND'. */
export type Blockchain_Name_Comparison_Exp = {
  _eq?: Maybe<Scalars['blockchain_name']>;
  _gt?: Maybe<Scalars['blockchain_name']>;
  _gte?: Maybe<Scalars['blockchain_name']>;
  _in?: Maybe<Array<Scalars['blockchain_name']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['blockchain_name']>;
  _lte?: Maybe<Scalars['blockchain_name']>;
  _neq?: Maybe<Scalars['blockchain_name']>;
  _nin?: Maybe<Array<Scalars['blockchain_name']>>;
};

/** columns and relationships of "blockchain_schemas" */
export type Blockchain_Schemas = {
  __typename?: 'blockchain_schemas';
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  column_name: Scalars['String'];
  contract?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  data_type: Scalars['String'];
  dataset_id: Scalars['Int'];
  full_name: Scalars['String'];
  id: Scalars['uuid'];
  schema: Scalars['String'];
  search_vector?: Maybe<Scalars['tsvector']>;
  table: Scalars['String'];
};


/** Boolean expression to compare columns of type "blockchain_schemas_abi_types". All fields are combined with logical 'AND'. */
export type Blockchain_Schemas_Abi_Types_Comparison_Exp = {
  _eq?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  _gt?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  _gte?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  _in?: Maybe<Array<Scalars['blockchain_schemas_abi_types']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  _lte?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  _neq?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  _nin?: Maybe<Array<Scalars['blockchain_schemas_abi_types']>>;
};

/** aggregated selection of "blockchain_schemas" */
export type Blockchain_Schemas_Aggregate = {
  __typename?: 'blockchain_schemas_aggregate';
  aggregate?: Maybe<Blockchain_Schemas_Aggregate_Fields>;
  nodes: Array<Blockchain_Schemas>;
};

/** aggregate fields of "blockchain_schemas" */
export type Blockchain_Schemas_Aggregate_Fields = {
  __typename?: 'blockchain_schemas_aggregate_fields';
  avg?: Maybe<Blockchain_Schemas_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Blockchain_Schemas_Max_Fields>;
  min?: Maybe<Blockchain_Schemas_Min_Fields>;
  stddev?: Maybe<Blockchain_Schemas_Stddev_Fields>;
  stddev_pop?: Maybe<Blockchain_Schemas_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Blockchain_Schemas_Stddev_Samp_Fields>;
  sum?: Maybe<Blockchain_Schemas_Sum_Fields>;
  var_pop?: Maybe<Blockchain_Schemas_Var_Pop_Fields>;
  var_samp?: Maybe<Blockchain_Schemas_Var_Samp_Fields>;
  variance?: Maybe<Blockchain_Schemas_Variance_Fields>;
};


/** aggregate fields of "blockchain_schemas" */
export type Blockchain_Schemas_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Blockchain_Schemas_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Blockchain_Schemas_Avg_Fields = {
  __typename?: 'blockchain_schemas_avg_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "blockchain_schemas". All fields are combined with a logical 'AND'. */
export type Blockchain_Schemas_Bool_Exp = {
  _and?: Maybe<Array<Blockchain_Schemas_Bool_Exp>>;
  _not?: Maybe<Blockchain_Schemas_Bool_Exp>;
  _or?: Maybe<Array<Blockchain_Schemas_Bool_Exp>>;
  abi_name?: Maybe<String_Comparison_Exp>;
  abi_type?: Maybe<Blockchain_Schemas_Abi_Types_Comparison_Exp>;
  column_name?: Maybe<String_Comparison_Exp>;
  contract?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  data_type?: Maybe<String_Comparison_Exp>;
  dataset_id?: Maybe<Int_Comparison_Exp>;
  full_name?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  schema?: Maybe<String_Comparison_Exp>;
  search_vector?: Maybe<Tsvector_Comparison_Exp>;
  table?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "blockchain_schemas" */
export enum Blockchain_Schemas_Constraint {
  /** unique or primary key constraint on columns "full_name", "dataset_id" */
  BlockchainSchemasFullNameDatasetIdIx = 'blockchain_schemas_full_name_dataset_id_ix',
  /** unique or primary key constraint on columns "id" */
  BlockchainSchemasPkey = 'blockchain_schemas_pkey'
}

/** input type for incrementing numeric columns in table "blockchain_schemas" */
export type Blockchain_Schemas_Inc_Input = {
  dataset_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "blockchain_schemas" */
export type Blockchain_Schemas_Insert_Input = {
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  column_name?: Maybe<Scalars['String']>;
  contract?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  table?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Blockchain_Schemas_Max_Fields = {
  __typename?: 'blockchain_schemas_max_fields';
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  column_name?: Maybe<Scalars['String']>;
  contract?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  table?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Blockchain_Schemas_Min_Fields = {
  __typename?: 'blockchain_schemas_min_fields';
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  column_name?: Maybe<Scalars['String']>;
  contract?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  table?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "blockchain_schemas" */
export type Blockchain_Schemas_Mutation_Response = {
  __typename?: 'blockchain_schemas_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Blockchain_Schemas>;
};

/** input type for inserting object relation for remote table "blockchain_schemas" */
export type Blockchain_Schemas_Obj_Rel_Insert_Input = {
  data: Blockchain_Schemas_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Blockchain_Schemas_On_Conflict>;
};

/** on_conflict condition type for table "blockchain_schemas" */
export type Blockchain_Schemas_On_Conflict = {
  constraint: Blockchain_Schemas_Constraint;
  update_columns: Array<Blockchain_Schemas_Update_Column>;
  where?: Maybe<Blockchain_Schemas_Bool_Exp>;
};

/** Ordering options when selecting data from "blockchain_schemas". */
export type Blockchain_Schemas_Order_By = {
  abi_name?: Maybe<Order_By>;
  abi_type?: Maybe<Order_By>;
  column_name?: Maybe<Order_By>;
  contract?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  data_type?: Maybe<Order_By>;
  dataset_id?: Maybe<Order_By>;
  full_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  schema?: Maybe<Order_By>;
  search_vector?: Maybe<Order_By>;
  table?: Maybe<Order_By>;
};

/** primary key columns input for table: blockchain_schemas */
export type Blockchain_Schemas_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "blockchain_schemas" */
export enum Blockchain_Schemas_Select_Column {
  /** column name */
  AbiName = 'abi_name',
  /** column name */
  AbiType = 'abi_type',
  /** column name */
  ColumnName = 'column_name',
  /** column name */
  Contract = 'contract',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataType = 'data_type',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  FullName = 'full_name',
  /** column name */
  Id = 'id',
  /** column name */
  Schema = 'schema',
  /** column name */
  SearchVector = 'search_vector',
  /** column name */
  Table = 'table'
}

/** input type for updating data in table "blockchain_schemas" */
export type Blockchain_Schemas_Set_Input = {
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  column_name?: Maybe<Scalars['String']>;
  contract?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  table?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Blockchain_Schemas_Stddev_Fields = {
  __typename?: 'blockchain_schemas_stddev_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Blockchain_Schemas_Stddev_Pop_Fields = {
  __typename?: 'blockchain_schemas_stddev_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Blockchain_Schemas_Stddev_Samp_Fields = {
  __typename?: 'blockchain_schemas_stddev_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "blockchain_schemas" */
export type Blockchain_Schemas_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Blockchain_Schemas_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Blockchain_Schemas_Stream_Cursor_Value_Input = {
  abi_name?: Maybe<Scalars['String']>;
  abi_type?: Maybe<Scalars['blockchain_schemas_abi_types']>;
  column_name?: Maybe<Scalars['String']>;
  contract?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_type?: Maybe<Scalars['String']>;
  dataset_id?: Maybe<Scalars['Int']>;
  full_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  table?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Blockchain_Schemas_Sum_Fields = {
  __typename?: 'blockchain_schemas_sum_fields';
  dataset_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "blockchain_schemas" */
export enum Blockchain_Schemas_Update_Column {
  /** column name */
  AbiName = 'abi_name',
  /** column name */
  AbiType = 'abi_type',
  /** column name */
  ColumnName = 'column_name',
  /** column name */
  Contract = 'contract',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataType = 'data_type',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  FullName = 'full_name',
  /** column name */
  Id = 'id',
  /** column name */
  Schema = 'schema',
  /** column name */
  SearchVector = 'search_vector',
  /** column name */
  Table = 'table'
}

export type Blockchain_Schemas_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Blockchain_Schemas_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Blockchain_Schemas_Set_Input>;
  where: Blockchain_Schemas_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Blockchain_Schemas_Var_Pop_Fields = {
  __typename?: 'blockchain_schemas_var_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Blockchain_Schemas_Var_Samp_Fields = {
  __typename?: 'blockchain_schemas_var_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Blockchain_Schemas_Variance_Fields = {
  __typename?: 'blockchain_schemas_variance_fields';
  dataset_id?: Maybe<Scalars['Float']>;
};


/** Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'. */
export type Bpchar_Comparison_Exp = {
  _eq?: Maybe<Scalars['bpchar']>;
  _gt?: Maybe<Scalars['bpchar']>;
  _gte?: Maybe<Scalars['bpchar']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['bpchar']>;
  _in?: Maybe<Array<Scalars['bpchar']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['bpchar']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['bpchar']>;
  _lt?: Maybe<Scalars['bpchar']>;
  _lte?: Maybe<Scalars['bpchar']>;
  _neq?: Maybe<Scalars['bpchar']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['bpchar']>;
  _nin?: Maybe<Array<Scalars['bpchar']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['bpchar']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['bpchar']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['bpchar']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['bpchar']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['bpchar']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['bpchar']>;
};


/** Boolean expression to compare columns of type "contract_submission_status". All fields are combined with logical 'AND'. */
export type Contract_Submission_Status_Comparison_Exp = {
  _eq?: Maybe<Scalars['contract_submission_status']>;
  _gt?: Maybe<Scalars['contract_submission_status']>;
  _gte?: Maybe<Scalars['contract_submission_status']>;
  _in?: Maybe<Array<Scalars['contract_submission_status']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['contract_submission_status']>;
  _lte?: Maybe<Scalars['contract_submission_status']>;
  _neq?: Maybe<Scalars['contract_submission_status']>;
  _nin?: Maybe<Array<Scalars['contract_submission_status']>>;
};

/** columns and relationships of "contract_submissions" */
export type Contract_Submissions = {
  __typename?: 'contract_submissions';
  abi: Scalars['jsonb'];
  address: Scalars['String'];
  blockchain: Scalars['blockchain_name'];
  cognito_user_id?: Maybe<Scalars['uuid']>;
  comment?: Maybe<Scalars['String']>;
  contract_name: Scalars['String'];
  created_at: Scalars['timestamptz'];
  has_multiple_instances: Scalars['Boolean'];
  id: Scalars['uuid'];
  is_created_by_factory: Scalars['Boolean'];
  is_manual_abi: Scalars['Boolean'];
  is_proxy: Scalars['Boolean'];
  project_name: Scalars['String'];
  resubmission_reason?: Maybe<Scalars['String']>;
  status: Scalars['contract_submission_status'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "contract_submissions" */
export type Contract_SubmissionsAbiArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "contract_submissions" */
export type Contract_Submissions_Aggregate = {
  __typename?: 'contract_submissions_aggregate';
  aggregate?: Maybe<Contract_Submissions_Aggregate_Fields>;
  nodes: Array<Contract_Submissions>;
};

export type Contract_Submissions_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Contract_Submissions_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Contract_Submissions_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Contract_Submissions_Aggregate_Bool_Exp_Count>;
};

export type Contract_Submissions_Aggregate_Bool_Exp_Bool_And = {
  arguments: Contract_Submissions_Select_Column_Contract_Submissions_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Contract_Submissions_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Contract_Submissions_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Contract_Submissions_Select_Column_Contract_Submissions_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Contract_Submissions_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Contract_Submissions_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Contract_Submissions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Contract_Submissions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "contract_submissions" */
export type Contract_Submissions_Aggregate_Fields = {
  __typename?: 'contract_submissions_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Contract_Submissions_Max_Fields>;
  min?: Maybe<Contract_Submissions_Min_Fields>;
};


/** aggregate fields of "contract_submissions" */
export type Contract_Submissions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Contract_Submissions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "contract_submissions" */
export type Contract_Submissions_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Contract_Submissions_Max_Order_By>;
  min?: Maybe<Contract_Submissions_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Contract_Submissions_Append_Input = {
  abi?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "contract_submissions" */
export type Contract_Submissions_Arr_Rel_Insert_Input = {
  data: Array<Contract_Submissions_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Contract_Submissions_On_Conflict>;
};

/** Boolean expression to filter rows from the table "contract_submissions". All fields are combined with a logical 'AND'. */
export type Contract_Submissions_Bool_Exp = {
  _and?: Maybe<Array<Contract_Submissions_Bool_Exp>>;
  _not?: Maybe<Contract_Submissions_Bool_Exp>;
  _or?: Maybe<Array<Contract_Submissions_Bool_Exp>>;
  abi?: Maybe<Jsonb_Comparison_Exp>;
  address?: Maybe<String_Comparison_Exp>;
  blockchain?: Maybe<Blockchain_Name_Comparison_Exp>;
  cognito_user_id?: Maybe<Uuid_Comparison_Exp>;
  comment?: Maybe<String_Comparison_Exp>;
  contract_name?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  has_multiple_instances?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_created_by_factory?: Maybe<Boolean_Comparison_Exp>;
  is_manual_abi?: Maybe<Boolean_Comparison_Exp>;
  is_proxy?: Maybe<Boolean_Comparison_Exp>;
  project_name?: Maybe<String_Comparison_Exp>;
  resubmission_reason?: Maybe<String_Comparison_Exp>;
  status?: Maybe<Contract_Submission_Status_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "contract_submissions" */
export enum Contract_Submissions_Constraint {
  /** unique or primary key constraint on columns "id" */
  ContractSubmissionsPkey = 'contract_submissions_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Contract_Submissions_Delete_At_Path_Input = {
  abi?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Contract_Submissions_Delete_Elem_Input = {
  abi?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Contract_Submissions_Delete_Key_Input = {
  abi?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "contract_submissions" */
export type Contract_Submissions_Insert_Input = {
  abi?: Maybe<Scalars['jsonb']>;
  address?: Maybe<Scalars['String']>;
  blockchain?: Maybe<Scalars['blockchain_name']>;
  cognito_user_id?: Maybe<Scalars['uuid']>;
  comment?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  has_multiple_instances?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  is_created_by_factory?: Maybe<Scalars['Boolean']>;
  is_manual_abi?: Maybe<Scalars['Boolean']>;
  is_proxy?: Maybe<Scalars['Boolean']>;
  project_name?: Maybe<Scalars['String']>;
  resubmission_reason?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['contract_submission_status']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Contract_Submissions_Max_Fields = {
  __typename?: 'contract_submissions_max_fields';
  address?: Maybe<Scalars['String']>;
  blockchain?: Maybe<Scalars['blockchain_name']>;
  cognito_user_id?: Maybe<Scalars['uuid']>;
  comment?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  resubmission_reason?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['contract_submission_status']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "contract_submissions" */
export type Contract_Submissions_Max_Order_By = {
  address?: Maybe<Order_By>;
  blockchain?: Maybe<Order_By>;
  cognito_user_id?: Maybe<Order_By>;
  comment?: Maybe<Order_By>;
  contract_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_name?: Maybe<Order_By>;
  resubmission_reason?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Contract_Submissions_Min_Fields = {
  __typename?: 'contract_submissions_min_fields';
  address?: Maybe<Scalars['String']>;
  blockchain?: Maybe<Scalars['blockchain_name']>;
  cognito_user_id?: Maybe<Scalars['uuid']>;
  comment?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  resubmission_reason?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['contract_submission_status']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "contract_submissions" */
export type Contract_Submissions_Min_Order_By = {
  address?: Maybe<Order_By>;
  blockchain?: Maybe<Order_By>;
  cognito_user_id?: Maybe<Order_By>;
  comment?: Maybe<Order_By>;
  contract_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_name?: Maybe<Order_By>;
  resubmission_reason?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "contract_submissions" */
export type Contract_Submissions_Mutation_Response = {
  __typename?: 'contract_submissions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Contract_Submissions>;
};

/** on_conflict condition type for table "contract_submissions" */
export type Contract_Submissions_On_Conflict = {
  constraint: Contract_Submissions_Constraint;
  update_columns: Array<Contract_Submissions_Update_Column>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};

/** Ordering options when selecting data from "contract_submissions". */
export type Contract_Submissions_Order_By = {
  abi?: Maybe<Order_By>;
  address?: Maybe<Order_By>;
  blockchain?: Maybe<Order_By>;
  cognito_user_id?: Maybe<Order_By>;
  comment?: Maybe<Order_By>;
  contract_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  has_multiple_instances?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_created_by_factory?: Maybe<Order_By>;
  is_manual_abi?: Maybe<Order_By>;
  is_proxy?: Maybe<Order_By>;
  project_name?: Maybe<Order_By>;
  resubmission_reason?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: contract_submissions */
export type Contract_Submissions_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Contract_Submissions_Prepend_Input = {
  abi?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "contract_submissions" */
export enum Contract_Submissions_Select_Column {
  /** column name */
  Abi = 'abi',
  /** column name */
  Address = 'address',
  /** column name */
  Blockchain = 'blockchain',
  /** column name */
  CognitoUserId = 'cognito_user_id',
  /** column name */
  Comment = 'comment',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasMultipleInstances = 'has_multiple_instances',
  /** column name */
  Id = 'id',
  /** column name */
  IsCreatedByFactory = 'is_created_by_factory',
  /** column name */
  IsManualAbi = 'is_manual_abi',
  /** column name */
  IsProxy = 'is_proxy',
  /** column name */
  ProjectName = 'project_name',
  /** column name */
  ResubmissionReason = 'resubmission_reason',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "contract_submissions_aggregate_bool_exp_bool_and_arguments_columns" columns of table "contract_submissions" */
export enum Contract_Submissions_Select_Column_Contract_Submissions_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  HasMultipleInstances = 'has_multiple_instances',
  /** column name */
  IsCreatedByFactory = 'is_created_by_factory',
  /** column name */
  IsManualAbi = 'is_manual_abi',
  /** column name */
  IsProxy = 'is_proxy'
}

/** select "contract_submissions_aggregate_bool_exp_bool_or_arguments_columns" columns of table "contract_submissions" */
export enum Contract_Submissions_Select_Column_Contract_Submissions_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  HasMultipleInstances = 'has_multiple_instances',
  /** column name */
  IsCreatedByFactory = 'is_created_by_factory',
  /** column name */
  IsManualAbi = 'is_manual_abi',
  /** column name */
  IsProxy = 'is_proxy'
}

/** input type for updating data in table "contract_submissions" */
export type Contract_Submissions_Set_Input = {
  abi?: Maybe<Scalars['jsonb']>;
  address?: Maybe<Scalars['String']>;
  blockchain?: Maybe<Scalars['blockchain_name']>;
  cognito_user_id?: Maybe<Scalars['uuid']>;
  comment?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  has_multiple_instances?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  is_created_by_factory?: Maybe<Scalars['Boolean']>;
  is_manual_abi?: Maybe<Scalars['Boolean']>;
  is_proxy?: Maybe<Scalars['Boolean']>;
  project_name?: Maybe<Scalars['String']>;
  resubmission_reason?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['contract_submission_status']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "contract_submissions" */
export type Contract_Submissions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Contract_Submissions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Contract_Submissions_Stream_Cursor_Value_Input = {
  abi?: Maybe<Scalars['jsonb']>;
  address?: Maybe<Scalars['String']>;
  blockchain?: Maybe<Scalars['blockchain_name']>;
  cognito_user_id?: Maybe<Scalars['uuid']>;
  comment?: Maybe<Scalars['String']>;
  contract_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  has_multiple_instances?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  is_created_by_factory?: Maybe<Scalars['Boolean']>;
  is_manual_abi?: Maybe<Scalars['Boolean']>;
  is_proxy?: Maybe<Scalars['Boolean']>;
  project_name?: Maybe<Scalars['String']>;
  resubmission_reason?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['contract_submission_status']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "contract_submissions" */
export enum Contract_Submissions_Update_Column {
  /** column name */
  Abi = 'abi',
  /** column name */
  Address = 'address',
  /** column name */
  Blockchain = 'blockchain',
  /** column name */
  CognitoUserId = 'cognito_user_id',
  /** column name */
  Comment = 'comment',
  /** column name */
  ContractName = 'contract_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasMultipleInstances = 'has_multiple_instances',
  /** column name */
  Id = 'id',
  /** column name */
  IsCreatedByFactory = 'is_created_by_factory',
  /** column name */
  IsManualAbi = 'is_manual_abi',
  /** column name */
  IsProxy = 'is_proxy',
  /** column name */
  ProjectName = 'project_name',
  /** column name */
  ResubmissionReason = 'resubmission_reason',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Contract_Submissions_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Contract_Submissions_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Contract_Submissions_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Contract_Submissions_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Contract_Submissions_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Contract_Submissions_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Contract_Submissions_Set_Input>;
  where: Contract_Submissions_Bool_Exp;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "dashboard_favorite_count_all" */
export type Dashboard_Favorite_Count_All = {
  __typename?: 'dashboard_favorite_count_all';
  /** An object relationship */
  dashboard?: Maybe<Dashboards>;
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "dashboard_favorite_count_all" */
export type Dashboard_Favorite_Count_All_Aggregate = {
  __typename?: 'dashboard_favorite_count_all_aggregate';
  aggregate?: Maybe<Dashboard_Favorite_Count_All_Aggregate_Fields>;
  nodes: Array<Dashboard_Favorite_Count_All>;
};

/** aggregate fields of "dashboard_favorite_count_all" */
export type Dashboard_Favorite_Count_All_Aggregate_Fields = {
  __typename?: 'dashboard_favorite_count_all_aggregate_fields';
  avg?: Maybe<Dashboard_Favorite_Count_All_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dashboard_Favorite_Count_All_Max_Fields>;
  min?: Maybe<Dashboard_Favorite_Count_All_Min_Fields>;
  stddev?: Maybe<Dashboard_Favorite_Count_All_Stddev_Fields>;
  stddev_pop?: Maybe<Dashboard_Favorite_Count_All_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dashboard_Favorite_Count_All_Stddev_Samp_Fields>;
  sum?: Maybe<Dashboard_Favorite_Count_All_Sum_Fields>;
  var_pop?: Maybe<Dashboard_Favorite_Count_All_Var_Pop_Fields>;
  var_samp?: Maybe<Dashboard_Favorite_Count_All_Var_Samp_Fields>;
  variance?: Maybe<Dashboard_Favorite_Count_All_Variance_Fields>;
};


/** aggregate fields of "dashboard_favorite_count_all" */
export type Dashboard_Favorite_Count_All_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dashboard_Favorite_Count_All_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dashboard_Favorite_Count_All_Avg_Fields = {
  __typename?: 'dashboard_favorite_count_all_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dashboard_favorite_count_all". All fields are combined with a logical 'AND'. */
export type Dashboard_Favorite_Count_All_Bool_Exp = {
  _and?: Maybe<Array<Dashboard_Favorite_Count_All_Bool_Exp>>;
  _not?: Maybe<Dashboard_Favorite_Count_All_Bool_Exp>;
  _or?: Maybe<Array<Dashboard_Favorite_Count_All_Bool_Exp>>;
  dashboard?: Maybe<Dashboards_Bool_Exp>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for inserting data into table "dashboard_favorite_count_all" */
export type Dashboard_Favorite_Count_All_Insert_Input = {
  dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Dashboard_Favorite_Count_All_Max_Fields = {
  __typename?: 'dashboard_favorite_count_all_max_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Dashboard_Favorite_Count_All_Min_Fields = {
  __typename?: 'dashboard_favorite_count_all_min_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** input type for inserting object relation for remote table "dashboard_favorite_count_all" */
export type Dashboard_Favorite_Count_All_Obj_Rel_Insert_Input = {
  data: Dashboard_Favorite_Count_All_Insert_Input;
};

/** Ordering options when selecting data from "dashboard_favorite_count_all". */
export type Dashboard_Favorite_Count_All_Order_By = {
  dashboard?: Maybe<Dashboards_Order_By>;
  dashboard_id?: Maybe<Order_By>;
  favorite_count?: Maybe<Order_By>;
};

/** select columns of table "dashboard_favorite_count_all" */
export enum Dashboard_Favorite_Count_All_Select_Column {
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  FavoriteCount = 'favorite_count'
}

/** aggregate stddev on columns */
export type Dashboard_Favorite_Count_All_Stddev_Fields = {
  __typename?: 'dashboard_favorite_count_all_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dashboard_Favorite_Count_All_Stddev_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_all_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dashboard_Favorite_Count_All_Stddev_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_all_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dashboard_favorite_count_all" */
export type Dashboard_Favorite_Count_All_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dashboard_Favorite_Count_All_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dashboard_Favorite_Count_All_Stream_Cursor_Value_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dashboard_Favorite_Count_All_Sum_Fields = {
  __typename?: 'dashboard_favorite_count_all_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Dashboard_Favorite_Count_All_Var_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_all_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dashboard_Favorite_Count_All_Var_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_all_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dashboard_Favorite_Count_All_Variance_Fields = {
  __typename?: 'dashboard_favorite_count_all_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dashboard_favorite_count_last_24h" */
export type Dashboard_Favorite_Count_Last_24h = {
  __typename?: 'dashboard_favorite_count_last_24h';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "dashboard_favorite_count_last_24h" */
export type Dashboard_Favorite_Count_Last_24h_Aggregate = {
  __typename?: 'dashboard_favorite_count_last_24h_aggregate';
  aggregate?: Maybe<Dashboard_Favorite_Count_Last_24h_Aggregate_Fields>;
  nodes: Array<Dashboard_Favorite_Count_Last_24h>;
};

/** aggregate fields of "dashboard_favorite_count_last_24h" */
export type Dashboard_Favorite_Count_Last_24h_Aggregate_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_aggregate_fields';
  avg?: Maybe<Dashboard_Favorite_Count_Last_24h_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dashboard_Favorite_Count_Last_24h_Max_Fields>;
  min?: Maybe<Dashboard_Favorite_Count_Last_24h_Min_Fields>;
  stddev?: Maybe<Dashboard_Favorite_Count_Last_24h_Stddev_Fields>;
  stddev_pop?: Maybe<Dashboard_Favorite_Count_Last_24h_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dashboard_Favorite_Count_Last_24h_Stddev_Samp_Fields>;
  sum?: Maybe<Dashboard_Favorite_Count_Last_24h_Sum_Fields>;
  var_pop?: Maybe<Dashboard_Favorite_Count_Last_24h_Var_Pop_Fields>;
  var_samp?: Maybe<Dashboard_Favorite_Count_Last_24h_Var_Samp_Fields>;
  variance?: Maybe<Dashboard_Favorite_Count_Last_24h_Variance_Fields>;
};


/** aggregate fields of "dashboard_favorite_count_last_24h" */
export type Dashboard_Favorite_Count_Last_24h_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dashboard_Favorite_Count_Last_24h_Avg_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dashboard_favorite_count_last_24h". All fields are combined with a logical 'AND'. */
export type Dashboard_Favorite_Count_Last_24h_Bool_Exp = {
  _and?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Bool_Exp>>;
  _not?: Maybe<Dashboard_Favorite_Count_Last_24h_Bool_Exp>;
  _or?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Bool_Exp>>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for inserting data into table "dashboard_favorite_count_last_24h" */
export type Dashboard_Favorite_Count_Last_24h_Insert_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Dashboard_Favorite_Count_Last_24h_Max_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_max_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Dashboard_Favorite_Count_Last_24h_Min_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_min_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** input type for inserting object relation for remote table "dashboard_favorite_count_last_24h" */
export type Dashboard_Favorite_Count_Last_24h_Obj_Rel_Insert_Input = {
  data: Dashboard_Favorite_Count_Last_24h_Insert_Input;
};

/** Ordering options when selecting data from "dashboard_favorite_count_last_24h". */
export type Dashboard_Favorite_Count_Last_24h_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  favorite_count?: Maybe<Order_By>;
};

/** select columns of table "dashboard_favorite_count_last_24h" */
export enum Dashboard_Favorite_Count_Last_24h_Select_Column {
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  FavoriteCount = 'favorite_count'
}

/** aggregate stddev on columns */
export type Dashboard_Favorite_Count_Last_24h_Stddev_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dashboard_Favorite_Count_Last_24h_Stddev_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dashboard_Favorite_Count_Last_24h_Stddev_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dashboard_favorite_count_last_24h" */
export type Dashboard_Favorite_Count_Last_24h_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dashboard_Favorite_Count_Last_24h_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dashboard_Favorite_Count_Last_24h_Stream_Cursor_Value_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dashboard_Favorite_Count_Last_24h_Sum_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Dashboard_Favorite_Count_Last_24h_Var_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dashboard_Favorite_Count_Last_24h_Var_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dashboard_Favorite_Count_Last_24h_Variance_Fields = {
  __typename?: 'dashboard_favorite_count_last_24h_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dashboard_favorite_count_last_30d" */
export type Dashboard_Favorite_Count_Last_30d = {
  __typename?: 'dashboard_favorite_count_last_30d';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "dashboard_favorite_count_last_30d" */
export type Dashboard_Favorite_Count_Last_30d_Aggregate = {
  __typename?: 'dashboard_favorite_count_last_30d_aggregate';
  aggregate?: Maybe<Dashboard_Favorite_Count_Last_30d_Aggregate_Fields>;
  nodes: Array<Dashboard_Favorite_Count_Last_30d>;
};

/** aggregate fields of "dashboard_favorite_count_last_30d" */
export type Dashboard_Favorite_Count_Last_30d_Aggregate_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_aggregate_fields';
  avg?: Maybe<Dashboard_Favorite_Count_Last_30d_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dashboard_Favorite_Count_Last_30d_Max_Fields>;
  min?: Maybe<Dashboard_Favorite_Count_Last_30d_Min_Fields>;
  stddev?: Maybe<Dashboard_Favorite_Count_Last_30d_Stddev_Fields>;
  stddev_pop?: Maybe<Dashboard_Favorite_Count_Last_30d_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dashboard_Favorite_Count_Last_30d_Stddev_Samp_Fields>;
  sum?: Maybe<Dashboard_Favorite_Count_Last_30d_Sum_Fields>;
  var_pop?: Maybe<Dashboard_Favorite_Count_Last_30d_Var_Pop_Fields>;
  var_samp?: Maybe<Dashboard_Favorite_Count_Last_30d_Var_Samp_Fields>;
  variance?: Maybe<Dashboard_Favorite_Count_Last_30d_Variance_Fields>;
};


/** aggregate fields of "dashboard_favorite_count_last_30d" */
export type Dashboard_Favorite_Count_Last_30d_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dashboard_Favorite_Count_Last_30d_Avg_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dashboard_favorite_count_last_30d". All fields are combined with a logical 'AND'. */
export type Dashboard_Favorite_Count_Last_30d_Bool_Exp = {
  _and?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Bool_Exp>>;
  _not?: Maybe<Dashboard_Favorite_Count_Last_30d_Bool_Exp>;
  _or?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Bool_Exp>>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for inserting data into table "dashboard_favorite_count_last_30d" */
export type Dashboard_Favorite_Count_Last_30d_Insert_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Dashboard_Favorite_Count_Last_30d_Max_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_max_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Dashboard_Favorite_Count_Last_30d_Min_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_min_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** input type for inserting object relation for remote table "dashboard_favorite_count_last_30d" */
export type Dashboard_Favorite_Count_Last_30d_Obj_Rel_Insert_Input = {
  data: Dashboard_Favorite_Count_Last_30d_Insert_Input;
};

/** Ordering options when selecting data from "dashboard_favorite_count_last_30d". */
export type Dashboard_Favorite_Count_Last_30d_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  favorite_count?: Maybe<Order_By>;
};

/** select columns of table "dashboard_favorite_count_last_30d" */
export enum Dashboard_Favorite_Count_Last_30d_Select_Column {
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  FavoriteCount = 'favorite_count'
}

/** aggregate stddev on columns */
export type Dashboard_Favorite_Count_Last_30d_Stddev_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dashboard_Favorite_Count_Last_30d_Stddev_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dashboard_Favorite_Count_Last_30d_Stddev_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dashboard_favorite_count_last_30d" */
export type Dashboard_Favorite_Count_Last_30d_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dashboard_Favorite_Count_Last_30d_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dashboard_Favorite_Count_Last_30d_Stream_Cursor_Value_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dashboard_Favorite_Count_Last_30d_Sum_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Dashboard_Favorite_Count_Last_30d_Var_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dashboard_Favorite_Count_Last_30d_Var_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dashboard_Favorite_Count_Last_30d_Variance_Fields = {
  __typename?: 'dashboard_favorite_count_last_30d_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dashboard_favorite_count_last_7d" */
export type Dashboard_Favorite_Count_Last_7d = {
  __typename?: 'dashboard_favorite_count_last_7d';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "dashboard_favorite_count_last_7d" */
export type Dashboard_Favorite_Count_Last_7d_Aggregate = {
  __typename?: 'dashboard_favorite_count_last_7d_aggregate';
  aggregate?: Maybe<Dashboard_Favorite_Count_Last_7d_Aggregate_Fields>;
  nodes: Array<Dashboard_Favorite_Count_Last_7d>;
};

/** aggregate fields of "dashboard_favorite_count_last_7d" */
export type Dashboard_Favorite_Count_Last_7d_Aggregate_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_aggregate_fields';
  avg?: Maybe<Dashboard_Favorite_Count_Last_7d_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dashboard_Favorite_Count_Last_7d_Max_Fields>;
  min?: Maybe<Dashboard_Favorite_Count_Last_7d_Min_Fields>;
  stddev?: Maybe<Dashboard_Favorite_Count_Last_7d_Stddev_Fields>;
  stddev_pop?: Maybe<Dashboard_Favorite_Count_Last_7d_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dashboard_Favorite_Count_Last_7d_Stddev_Samp_Fields>;
  sum?: Maybe<Dashboard_Favorite_Count_Last_7d_Sum_Fields>;
  var_pop?: Maybe<Dashboard_Favorite_Count_Last_7d_Var_Pop_Fields>;
  var_samp?: Maybe<Dashboard_Favorite_Count_Last_7d_Var_Samp_Fields>;
  variance?: Maybe<Dashboard_Favorite_Count_Last_7d_Variance_Fields>;
};


/** aggregate fields of "dashboard_favorite_count_last_7d" */
export type Dashboard_Favorite_Count_Last_7d_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dashboard_Favorite_Count_Last_7d_Avg_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dashboard_favorite_count_last_7d". All fields are combined with a logical 'AND'. */
export type Dashboard_Favorite_Count_Last_7d_Bool_Exp = {
  _and?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Bool_Exp>>;
  _not?: Maybe<Dashboard_Favorite_Count_Last_7d_Bool_Exp>;
  _or?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Bool_Exp>>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for inserting data into table "dashboard_favorite_count_last_7d" */
export type Dashboard_Favorite_Count_Last_7d_Insert_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Dashboard_Favorite_Count_Last_7d_Max_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_max_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Dashboard_Favorite_Count_Last_7d_Min_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_min_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** input type for inserting object relation for remote table "dashboard_favorite_count_last_7d" */
export type Dashboard_Favorite_Count_Last_7d_Obj_Rel_Insert_Input = {
  data: Dashboard_Favorite_Count_Last_7d_Insert_Input;
};

/** Ordering options when selecting data from "dashboard_favorite_count_last_7d". */
export type Dashboard_Favorite_Count_Last_7d_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  favorite_count?: Maybe<Order_By>;
};

/** select columns of table "dashboard_favorite_count_last_7d" */
export enum Dashboard_Favorite_Count_Last_7d_Select_Column {
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  FavoriteCount = 'favorite_count'
}

/** aggregate stddev on columns */
export type Dashboard_Favorite_Count_Last_7d_Stddev_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dashboard_Favorite_Count_Last_7d_Stddev_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dashboard_Favorite_Count_Last_7d_Stddev_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dashboard_favorite_count_last_7d" */
export type Dashboard_Favorite_Count_Last_7d_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dashboard_Favorite_Count_Last_7d_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dashboard_Favorite_Count_Last_7d_Stream_Cursor_Value_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dashboard_Favorite_Count_Last_7d_Sum_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  favorite_count?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Dashboard_Favorite_Count_Last_7d_Var_Pop_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dashboard_Favorite_Count_Last_7d_Var_Samp_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dashboard_Favorite_Count_Last_7d_Variance_Fields = {
  __typename?: 'dashboard_favorite_count_last_7d_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  favorite_count?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dashboard_trending_scores" */
export type Dashboard_Trending_Scores = {
  __typename?: 'dashboard_trending_scores';
  dashboard_id: Scalars['Int'];
  /** An object relationship */
  dashboard_trending_scores_dashboard?: Maybe<Dashboards>;
  score_1h: Scalars['numeric'];
  score_24h: Scalars['numeric'];
  score_4h: Scalars['numeric'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Aggregate = {
  __typename?: 'dashboard_trending_scores_aggregate';
  aggregate?: Maybe<Dashboard_Trending_Scores_Aggregate_Fields>;
  nodes: Array<Dashboard_Trending_Scores>;
};

/** aggregate fields of "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Aggregate_Fields = {
  __typename?: 'dashboard_trending_scores_aggregate_fields';
  avg?: Maybe<Dashboard_Trending_Scores_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dashboard_Trending_Scores_Max_Fields>;
  min?: Maybe<Dashboard_Trending_Scores_Min_Fields>;
  stddev?: Maybe<Dashboard_Trending_Scores_Stddev_Fields>;
  stddev_pop?: Maybe<Dashboard_Trending_Scores_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dashboard_Trending_Scores_Stddev_Samp_Fields>;
  sum?: Maybe<Dashboard_Trending_Scores_Sum_Fields>;
  var_pop?: Maybe<Dashboard_Trending_Scores_Var_Pop_Fields>;
  var_samp?: Maybe<Dashboard_Trending_Scores_Var_Samp_Fields>;
  variance?: Maybe<Dashboard_Trending_Scores_Variance_Fields>;
};


/** aggregate fields of "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dashboard_Trending_Scores_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dashboard_Trending_Scores_Avg_Fields = {
  __typename?: 'dashboard_trending_scores_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  score_1h?: Maybe<Scalars['Float']>;
  score_24h?: Maybe<Scalars['Float']>;
  score_4h?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dashboard_trending_scores". All fields are combined with a logical 'AND'. */
export type Dashboard_Trending_Scores_Bool_Exp = {
  _and?: Maybe<Array<Dashboard_Trending_Scores_Bool_Exp>>;
  _not?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
  _or?: Maybe<Array<Dashboard_Trending_Scores_Bool_Exp>>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  dashboard_trending_scores_dashboard?: Maybe<Dashboards_Bool_Exp>;
  score_1h?: Maybe<Numeric_Comparison_Exp>;
  score_24h?: Maybe<Numeric_Comparison_Exp>;
  score_4h?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "dashboard_trending_scores" */
export enum Dashboard_Trending_Scores_Constraint {
  /** unique or primary key constraint on columns "dashboard_id" */
  DashboardTrendingScoresPkey = 'dashboard_trending_scores_pkey'
}

/** input type for incrementing numeric columns in table "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Inc_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  score_1h?: Maybe<Scalars['numeric']>;
  score_24h?: Maybe<Scalars['numeric']>;
  score_4h?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Insert_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  dashboard_trending_scores_dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  score_1h?: Maybe<Scalars['numeric']>;
  score_24h?: Maybe<Scalars['numeric']>;
  score_4h?: Maybe<Scalars['numeric']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Dashboard_Trending_Scores_Max_Fields = {
  __typename?: 'dashboard_trending_scores_max_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  score_1h?: Maybe<Scalars['numeric']>;
  score_24h?: Maybe<Scalars['numeric']>;
  score_4h?: Maybe<Scalars['numeric']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Dashboard_Trending_Scores_Min_Fields = {
  __typename?: 'dashboard_trending_scores_min_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  score_1h?: Maybe<Scalars['numeric']>;
  score_24h?: Maybe<Scalars['numeric']>;
  score_4h?: Maybe<Scalars['numeric']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Mutation_Response = {
  __typename?: 'dashboard_trending_scores_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dashboard_Trending_Scores>;
};

/** input type for inserting object relation for remote table "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Obj_Rel_Insert_Input = {
  data: Dashboard_Trending_Scores_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Dashboard_Trending_Scores_On_Conflict>;
};

/** on_conflict condition type for table "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_On_Conflict = {
  constraint: Dashboard_Trending_Scores_Constraint;
  update_columns: Array<Dashboard_Trending_Scores_Update_Column>;
  where?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
};

/** Ordering options when selecting data from "dashboard_trending_scores". */
export type Dashboard_Trending_Scores_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  dashboard_trending_scores_dashboard?: Maybe<Dashboards_Order_By>;
  score_1h?: Maybe<Order_By>;
  score_24h?: Maybe<Order_By>;
  score_4h?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: dashboard_trending_scores */
export type Dashboard_Trending_Scores_Pk_Columns_Input = {
  dashboard_id: Scalars['Int'];
};

/** select columns of table "dashboard_trending_scores" */
export enum Dashboard_Trending_Scores_Select_Column {
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Score_1h = 'score_1h',
  /** column name */
  Score_24h = 'score_24h',
  /** column name */
  Score_4h = 'score_4h',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Set_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  score_1h?: Maybe<Scalars['numeric']>;
  score_24h?: Maybe<Scalars['numeric']>;
  score_4h?: Maybe<Scalars['numeric']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Dashboard_Trending_Scores_Stddev_Fields = {
  __typename?: 'dashboard_trending_scores_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  score_1h?: Maybe<Scalars['Float']>;
  score_24h?: Maybe<Scalars['Float']>;
  score_4h?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dashboard_Trending_Scores_Stddev_Pop_Fields = {
  __typename?: 'dashboard_trending_scores_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  score_1h?: Maybe<Scalars['Float']>;
  score_24h?: Maybe<Scalars['Float']>;
  score_4h?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dashboard_Trending_Scores_Stddev_Samp_Fields = {
  __typename?: 'dashboard_trending_scores_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  score_1h?: Maybe<Scalars['Float']>;
  score_24h?: Maybe<Scalars['Float']>;
  score_4h?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dashboard_trending_scores" */
export type Dashboard_Trending_Scores_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dashboard_Trending_Scores_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dashboard_Trending_Scores_Stream_Cursor_Value_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  score_1h?: Maybe<Scalars['numeric']>;
  score_24h?: Maybe<Scalars['numeric']>;
  score_4h?: Maybe<Scalars['numeric']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Dashboard_Trending_Scores_Sum_Fields = {
  __typename?: 'dashboard_trending_scores_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  score_1h?: Maybe<Scalars['numeric']>;
  score_24h?: Maybe<Scalars['numeric']>;
  score_4h?: Maybe<Scalars['numeric']>;
};

/** update columns of table "dashboard_trending_scores" */
export enum Dashboard_Trending_Scores_Update_Column {
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Score_1h = 'score_1h',
  /** column name */
  Score_24h = 'score_24h',
  /** column name */
  Score_4h = 'score_4h',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Dashboard_Trending_Scores_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Dashboard_Trending_Scores_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Dashboard_Trending_Scores_Set_Input>;
  where: Dashboard_Trending_Scores_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dashboard_Trending_Scores_Var_Pop_Fields = {
  __typename?: 'dashboard_trending_scores_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  score_1h?: Maybe<Scalars['Float']>;
  score_24h?: Maybe<Scalars['Float']>;
  score_4h?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dashboard_Trending_Scores_Var_Samp_Fields = {
  __typename?: 'dashboard_trending_scores_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  score_1h?: Maybe<Scalars['Float']>;
  score_24h?: Maybe<Scalars['Float']>;
  score_4h?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dashboard_Trending_Scores_Variance_Fields = {
  __typename?: 'dashboard_trending_scores_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  score_1h?: Maybe<Scalars['Float']>;
  score_24h?: Maybe<Scalars['Float']>;
  score_4h?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dashboards" */
export type Dashboards = {
  __typename?: 'dashboards';
  /** An array relationship */
  api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  api_keys_aggregate: Api_Keys_Aggregate;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dashboard_favorite_count_all?: Maybe<Dashboard_Favorite_Count_All>;
  /** An object relationship */
  dashboard_favorite_count_last_24h?: Maybe<Dashboard_Favorite_Count_Last_24h>;
  /** An object relationship */
  dashboard_favorite_count_last_30d?: Maybe<Dashboard_Favorite_Count_Last_30d>;
  /** An object relationship */
  dashboard_favorite_count_last_7d?: Maybe<Dashboard_Favorite_Count_Last_7d>;
  /** An array relationship */
  favorite_dashboards: Array<Favorite_Dashboards>;
  /** An aggregate relationship */
  favorite_dashboards_aggregate: Favorite_Dashboards_Aggregate;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  forked_dashboard?: Maybe<Dashboards>;
  id: Scalars['Int'];
  is_archived: Scalars['Boolean'];
  is_private: Scalars['Boolean'];
  name: Scalars['String'];
  /** An array relationship */
  param_widgets: Array<Param_Widgets>;
  /** An aggregate relationship */
  param_widgets_aggregate: Param_Widgets_Aggregate;
  parameters?: Maybe<Scalars['json']>;
  redirect_from?: Maybe<Scalars['String']>;
  slug: Scalars['String'];
  tags?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  team?: Maybe<Teams>;
  team_id?: Maybe<Scalars['Int']>;
  /** An array relationship */
  text_widgets: Array<Text_Widgets>;
  /** An aggregate relationship */
  text_widgets_aggregate: Text_Widgets_Aggregate;
  /** An object relationship */
  trending_scores?: Maybe<Dashboard_Trending_Scores>;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['Int']>;
  /** An array relationship */
  visualization_widgets: Array<Visualization_Widgets>;
  /** An aggregate relationship */
  visualization_widgets_aggregate: Visualization_Widgets_Aggregate;
};


/** columns and relationships of "dashboards" */
export type DashboardsApi_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsApi_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsFavorite_DashboardsArgs = {
  distinct_on?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Dashboards_Order_By>>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsFavorite_Dashboards_AggregateArgs = {
  distinct_on?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Dashboards_Order_By>>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsParam_WidgetsArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsParam_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsParametersArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "dashboards" */
export type DashboardsTagsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "dashboards" */
export type DashboardsText_WidgetsArgs = {
  distinct_on?: Maybe<Array<Text_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Text_Widgets_Order_By>>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsText_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Text_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Text_Widgets_Order_By>>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsVisualization_WidgetsArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};


/** columns and relationships of "dashboards" */
export type DashboardsVisualization_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};

/** aggregated selection of "dashboards" */
export type Dashboards_Aggregate = {
  __typename?: 'dashboards_aggregate';
  aggregate?: Maybe<Dashboards_Aggregate_Fields>;
  nodes: Array<Dashboards>;
};

export type Dashboards_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Dashboards_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Dashboards_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Dashboards_Aggregate_Bool_Exp_Count>;
};

export type Dashboards_Aggregate_Bool_Exp_Bool_And = {
  arguments: Dashboards_Select_Column_Dashboards_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Dashboards_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Dashboards_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Dashboards_Select_Column_Dashboards_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Dashboards_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Dashboards_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Dashboards_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Dashboards_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dashboards" */
export type Dashboards_Aggregate_Fields = {
  __typename?: 'dashboards_aggregate_fields';
  avg?: Maybe<Dashboards_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dashboards_Max_Fields>;
  min?: Maybe<Dashboards_Min_Fields>;
  stddev?: Maybe<Dashboards_Stddev_Fields>;
  stddev_pop?: Maybe<Dashboards_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dashboards_Stddev_Samp_Fields>;
  sum?: Maybe<Dashboards_Sum_Fields>;
  var_pop?: Maybe<Dashboards_Var_Pop_Fields>;
  var_samp?: Maybe<Dashboards_Var_Samp_Fields>;
  variance?: Maybe<Dashboards_Variance_Fields>;
};


/** aggregate fields of "dashboards" */
export type Dashboards_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dashboards_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dashboards" */
export type Dashboards_Aggregate_Order_By = {
  avg?: Maybe<Dashboards_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Dashboards_Max_Order_By>;
  min?: Maybe<Dashboards_Min_Order_By>;
  stddev?: Maybe<Dashboards_Stddev_Order_By>;
  stddev_pop?: Maybe<Dashboards_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Dashboards_Stddev_Samp_Order_By>;
  sum?: Maybe<Dashboards_Sum_Order_By>;
  var_pop?: Maybe<Dashboards_Var_Pop_Order_By>;
  var_samp?: Maybe<Dashboards_Var_Samp_Order_By>;
  variance?: Maybe<Dashboards_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Dashboards_Append_Input = {
  tags?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "dashboards" */
export type Dashboards_Arr_Rel_Insert_Input = {
  data: Array<Dashboards_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Dashboards_On_Conflict>;
};

/** aggregate avg on columns */
export type Dashboards_Avg_Fields = {
  __typename?: 'dashboards_avg_fields';
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "dashboards" */
export type Dashboards_Avg_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "dashboards". All fields are combined with a logical 'AND'. */
export type Dashboards_Bool_Exp = {
  _and?: Maybe<Array<Dashboards_Bool_Exp>>;
  _not?: Maybe<Dashboards_Bool_Exp>;
  _or?: Maybe<Array<Dashboards_Bool_Exp>>;
  api_keys?: Maybe<Api_Keys_Bool_Exp>;
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dashboard_favorite_count_all?: Maybe<Dashboard_Favorite_Count_All_Bool_Exp>;
  dashboard_favorite_count_last_24h?: Maybe<Dashboard_Favorite_Count_Last_24h_Bool_Exp>;
  dashboard_favorite_count_last_30d?: Maybe<Dashboard_Favorite_Count_Last_30d_Bool_Exp>;
  dashboard_favorite_count_last_7d?: Maybe<Dashboard_Favorite_Count_Last_7d_Bool_Exp>;
  favorite_dashboards?: Maybe<Favorite_Dashboards_Bool_Exp>;
  favorite_dashboards_aggregate?: Maybe<Favorite_Dashboards_Aggregate_Bool_Exp>;
  folder_id?: Maybe<String_Comparison_Exp>;
  fork_of_id?: Maybe<Int_Comparison_Exp>;
  forked_dashboard?: Maybe<Dashboards_Bool_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  is_archived?: Maybe<Boolean_Comparison_Exp>;
  is_private?: Maybe<Boolean_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  param_widgets?: Maybe<Param_Widgets_Bool_Exp>;
  param_widgets_aggregate?: Maybe<Param_Widgets_Aggregate_Bool_Exp>;
  parameters?: Maybe<Json_Comparison_Exp>;
  redirect_from?: Maybe<String_Comparison_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  tags?: Maybe<Jsonb_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  text_widgets?: Maybe<Text_Widgets_Bool_Exp>;
  text_widgets_aggregate?: Maybe<Text_Widgets_Aggregate_Bool_Exp>;
  trending_scores?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
  visualization_widgets?: Maybe<Visualization_Widgets_Bool_Exp>;
  visualization_widgets_aggregate?: Maybe<Visualization_Widgets_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "dashboards" */
export enum Dashboards_Constraint {
  /** unique or primary key constraint on columns "id" */
  DashboardsPkey = 'dashboards_pkey',
  /** unique or primary key constraint on columns "slug", "team_id" */
  DashboardsUniqueTeamSlugIdx = 'dashboards_unique_team_slug_idx',
  /** unique or primary key constraint on columns "slug", "user_id" */
  DashboardsUniqueUserSlugIdx = 'dashboards_unique_user_slug_idx'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Dashboards_Delete_At_Path_Input = {
  tags?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Dashboards_Delete_Elem_Input = {
  tags?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Dashboards_Delete_Key_Input = {
  tags?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "dashboards" */
export type Dashboards_Inc_Input = {
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "dashboards" */
export type Dashboards_Insert_Input = {
  api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_favorite_count_all?: Maybe<Dashboard_Favorite_Count_All_Obj_Rel_Insert_Input>;
  dashboard_favorite_count_last_24h?: Maybe<Dashboard_Favorite_Count_Last_24h_Obj_Rel_Insert_Input>;
  dashboard_favorite_count_last_30d?: Maybe<Dashboard_Favorite_Count_Last_30d_Obj_Rel_Insert_Input>;
  dashboard_favorite_count_last_7d?: Maybe<Dashboard_Favorite_Count_Last_7d_Obj_Rel_Insert_Input>;
  favorite_dashboards?: Maybe<Favorite_Dashboards_Arr_Rel_Insert_Input>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  forked_dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  id?: Maybe<Scalars['Int']>;
  is_archived?: Maybe<Scalars['Boolean']>;
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  param_widgets?: Maybe<Param_Widgets_Arr_Rel_Insert_Input>;
  parameters?: Maybe<Scalars['json']>;
  redirect_from?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['jsonb']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  team_id?: Maybe<Scalars['Int']>;
  text_widgets?: Maybe<Text_Widgets_Arr_Rel_Insert_Input>;
  trending_scores?: Maybe<Dashboard_Trending_Scores_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
  visualization_widgets?: Maybe<Visualization_Widgets_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Dashboards_Max_Fields = {
  __typename?: 'dashboards_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  redirect_from?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "dashboards" */
export type Dashboards_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  folder_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  redirect_from?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Dashboards_Min_Fields = {
  __typename?: 'dashboards_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  redirect_from?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "dashboards" */
export type Dashboards_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  folder_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  redirect_from?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "dashboards" */
export type Dashboards_Mutation_Response = {
  __typename?: 'dashboards_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dashboards>;
};

/** input type for inserting object relation for remote table "dashboards" */
export type Dashboards_Obj_Rel_Insert_Input = {
  data: Dashboards_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Dashboards_On_Conflict>;
};

/** on_conflict condition type for table "dashboards" */
export type Dashboards_On_Conflict = {
  constraint: Dashboards_Constraint;
  update_columns: Array<Dashboards_Update_Column>;
  where?: Maybe<Dashboards_Bool_Exp>;
};

/** Ordering options when selecting data from "dashboards". */
export type Dashboards_Order_By = {
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  dashboard_favorite_count_all?: Maybe<Dashboard_Favorite_Count_All_Order_By>;
  dashboard_favorite_count_last_24h?: Maybe<Dashboard_Favorite_Count_Last_24h_Order_By>;
  dashboard_favorite_count_last_30d?: Maybe<Dashboard_Favorite_Count_Last_30d_Order_By>;
  dashboard_favorite_count_last_7d?: Maybe<Dashboard_Favorite_Count_Last_7d_Order_By>;
  favorite_dashboards_aggregate?: Maybe<Favorite_Dashboards_Aggregate_Order_By>;
  folder_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  forked_dashboard?: Maybe<Dashboards_Order_By>;
  id?: Maybe<Order_By>;
  is_archived?: Maybe<Order_By>;
  is_private?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  param_widgets_aggregate?: Maybe<Param_Widgets_Aggregate_Order_By>;
  parameters?: Maybe<Order_By>;
  redirect_from?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  tags?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  team_id?: Maybe<Order_By>;
  text_widgets_aggregate?: Maybe<Text_Widgets_Aggregate_Order_By>;
  trending_scores?: Maybe<Dashboard_Trending_Scores_Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
  visualization_widgets_aggregate?: Maybe<Visualization_Widgets_Aggregate_Order_By>;
};

/** primary key columns input for table: dashboards */
export type Dashboards_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Dashboards_Prepend_Input = {
  tags?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "dashboards" */
export enum Dashboards_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FolderId = 'folder_id',
  /** column name */
  ForkOfId = 'fork_of_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private',
  /** column name */
  Name = 'name',
  /** column name */
  Parameters = 'parameters',
  /** column name */
  RedirectFrom = 'redirect_from',
  /** column name */
  Slug = 'slug',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** select "dashboards_aggregate_bool_exp_bool_and_arguments_columns" columns of table "dashboards" */
export enum Dashboards_Select_Column_Dashboards_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private'
}

/** select "dashboards_aggregate_bool_exp_bool_or_arguments_columns" columns of table "dashboards" */
export enum Dashboards_Select_Column_Dashboards_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private'
}

/** input type for updating data in table "dashboards" */
export type Dashboards_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  is_archived?: Maybe<Scalars['Boolean']>;
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['json']>;
  redirect_from?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['jsonb']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Dashboards_Stddev_Fields = {
  __typename?: 'dashboards_stddev_fields';
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "dashboards" */
export type Dashboards_Stddev_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Dashboards_Stddev_Pop_Fields = {
  __typename?: 'dashboards_stddev_pop_fields';
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "dashboards" */
export type Dashboards_Stddev_Pop_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Dashboards_Stddev_Samp_Fields = {
  __typename?: 'dashboards_stddev_samp_fields';
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "dashboards" */
export type Dashboards_Stddev_Samp_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "dashboards" */
export type Dashboards_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dashboards_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dashboards_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  is_archived?: Maybe<Scalars['Boolean']>;
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['json']>;
  redirect_from?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['jsonb']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Dashboards_Sum_Fields = {
  __typename?: 'dashboards_sum_fields';
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "dashboards" */
export type Dashboards_Sum_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** update columns of table "dashboards" */
export enum Dashboards_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FolderId = 'folder_id',
  /** column name */
  ForkOfId = 'fork_of_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private',
  /** column name */
  Name = 'name',
  /** column name */
  Parameters = 'parameters',
  /** column name */
  RedirectFrom = 'redirect_from',
  /** column name */
  Slug = 'slug',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Dashboards_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Dashboards_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Dashboards_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Dashboards_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Dashboards_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Dashboards_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Dashboards_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Dashboards_Set_Input>;
  where: Dashboards_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dashboards_Var_Pop_Fields = {
  __typename?: 'dashboards_var_pop_fields';
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "dashboards" */
export type Dashboards_Var_Pop_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Dashboards_Var_Samp_Fields = {
  __typename?: 'dashboards_var_samp_fields';
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "dashboards" */
export type Dashboards_Var_Samp_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Dashboards_Variance_Fields = {
  __typename?: 'dashboards_variance_fields';
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "dashboards" */
export type Dashboards_Variance_Order_By = {
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** columns and relationships of "datasets" */
export type Datasets = {
  __typename?: 'datasets';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  name: Scalars['String'];
  type: Scalars['String'];
};

/** aggregated selection of "datasets" */
export type Datasets_Aggregate = {
  __typename?: 'datasets_aggregate';
  aggregate?: Maybe<Datasets_Aggregate_Fields>;
  nodes: Array<Datasets>;
};

/** aggregate fields of "datasets" */
export type Datasets_Aggregate_Fields = {
  __typename?: 'datasets_aggregate_fields';
  avg?: Maybe<Datasets_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Datasets_Max_Fields>;
  min?: Maybe<Datasets_Min_Fields>;
  stddev?: Maybe<Datasets_Stddev_Fields>;
  stddev_pop?: Maybe<Datasets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Datasets_Stddev_Samp_Fields>;
  sum?: Maybe<Datasets_Sum_Fields>;
  var_pop?: Maybe<Datasets_Var_Pop_Fields>;
  var_samp?: Maybe<Datasets_Var_Samp_Fields>;
  variance?: Maybe<Datasets_Variance_Fields>;
};


/** aggregate fields of "datasets" */
export type Datasets_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Datasets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Datasets_Avg_Fields = {
  __typename?: 'datasets_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "datasets". All fields are combined with a logical 'AND'. */
export type Datasets_Bool_Exp = {
  _and?: Maybe<Array<Datasets_Bool_Exp>>;
  _not?: Maybe<Datasets_Bool_Exp>;
  _or?: Maybe<Array<Datasets_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "datasets" */
export enum Datasets_Constraint {
  /** unique or primary key constraint on columns "id" */
  DataSourcesPkey = 'data_sources_pkey',
  /** unique or primary key constraint on columns "name" */
  DatasetsUniqueName = 'datasets_unique_name'
}

/** input type for incrementing numeric columns in table "datasets" */
export type Datasets_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "datasets" */
export type Datasets_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Datasets_Max_Fields = {
  __typename?: 'datasets_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Datasets_Min_Fields = {
  __typename?: 'datasets_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "datasets" */
export type Datasets_Mutation_Response = {
  __typename?: 'datasets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Datasets>;
};

/** input type for inserting object relation for remote table "datasets" */
export type Datasets_Obj_Rel_Insert_Input = {
  data: Datasets_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Datasets_On_Conflict>;
};

/** on_conflict condition type for table "datasets" */
export type Datasets_On_Conflict = {
  constraint: Datasets_Constraint;
  update_columns: Array<Datasets_Update_Column>;
  where?: Maybe<Datasets_Bool_Exp>;
};

/** Ordering options when selecting data from "datasets". */
export type Datasets_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** primary key columns input for table: datasets */
export type Datasets_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "datasets" */
export enum Datasets_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "datasets" */
export type Datasets_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Datasets_Stddev_Fields = {
  __typename?: 'datasets_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Datasets_Stddev_Pop_Fields = {
  __typename?: 'datasets_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Datasets_Stddev_Samp_Fields = {
  __typename?: 'datasets_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "datasets" */
export type Datasets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Datasets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Datasets_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Datasets_Sum_Fields = {
  __typename?: 'datasets_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** update columns of table "datasets" */
export enum Datasets_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type'
}

export type Datasets_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Datasets_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Datasets_Set_Input>;
  where: Datasets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Datasets_Var_Pop_Fields = {
  __typename?: 'datasets_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Datasets_Var_Samp_Fields = {
  __typename?: 'datasets_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Datasets_Variance_Fields = {
  __typename?: 'datasets_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "favorite_dashboards" */
export type Favorite_Dashboards = {
  __typename?: 'favorite_dashboards';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dashboard: Dashboards;
  dashboard_id: Scalars['Int'];
  id: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['Int'];
};

/** aggregated selection of "favorite_dashboards" */
export type Favorite_Dashboards_Aggregate = {
  __typename?: 'favorite_dashboards_aggregate';
  aggregate?: Maybe<Favorite_Dashboards_Aggregate_Fields>;
  nodes: Array<Favorite_Dashboards>;
};

export type Favorite_Dashboards_Aggregate_Bool_Exp = {
  count?: Maybe<Favorite_Dashboards_Aggregate_Bool_Exp_Count>;
};

export type Favorite_Dashboards_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Favorite_Dashboards_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "favorite_dashboards" */
export type Favorite_Dashboards_Aggregate_Fields = {
  __typename?: 'favorite_dashboards_aggregate_fields';
  avg?: Maybe<Favorite_Dashboards_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Favorite_Dashboards_Max_Fields>;
  min?: Maybe<Favorite_Dashboards_Min_Fields>;
  stddev?: Maybe<Favorite_Dashboards_Stddev_Fields>;
  stddev_pop?: Maybe<Favorite_Dashboards_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Favorite_Dashboards_Stddev_Samp_Fields>;
  sum?: Maybe<Favorite_Dashboards_Sum_Fields>;
  var_pop?: Maybe<Favorite_Dashboards_Var_Pop_Fields>;
  var_samp?: Maybe<Favorite_Dashboards_Var_Samp_Fields>;
  variance?: Maybe<Favorite_Dashboards_Variance_Fields>;
};


/** aggregate fields of "favorite_dashboards" */
export type Favorite_Dashboards_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "favorite_dashboards" */
export type Favorite_Dashboards_Aggregate_Order_By = {
  avg?: Maybe<Favorite_Dashboards_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Favorite_Dashboards_Max_Order_By>;
  min?: Maybe<Favorite_Dashboards_Min_Order_By>;
  stddev?: Maybe<Favorite_Dashboards_Stddev_Order_By>;
  stddev_pop?: Maybe<Favorite_Dashboards_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Favorite_Dashboards_Stddev_Samp_Order_By>;
  sum?: Maybe<Favorite_Dashboards_Sum_Order_By>;
  var_pop?: Maybe<Favorite_Dashboards_Var_Pop_Order_By>;
  var_samp?: Maybe<Favorite_Dashboards_Var_Samp_Order_By>;
  variance?: Maybe<Favorite_Dashboards_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "favorite_dashboards" */
export type Favorite_Dashboards_Arr_Rel_Insert_Input = {
  data: Array<Favorite_Dashboards_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Favorite_Dashboards_On_Conflict>;
};

/** aggregate avg on columns */
export type Favorite_Dashboards_Avg_Fields = {
  __typename?: 'favorite_dashboards_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Avg_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "favorite_dashboards". All fields are combined with a logical 'AND'. */
export type Favorite_Dashboards_Bool_Exp = {
  _and?: Maybe<Array<Favorite_Dashboards_Bool_Exp>>;
  _not?: Maybe<Favorite_Dashboards_Bool_Exp>;
  _or?: Maybe<Array<Favorite_Dashboards_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dashboard?: Maybe<Dashboards_Bool_Exp>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "favorite_dashboards" */
export enum Favorite_Dashboards_Constraint {
  /** unique or primary key constraint on columns "id" */
  FavoriteDashboardsPkey = 'favorite_dashboards_pkey',
  /** unique or primary key constraint on columns "dashboard_id", "user_id" */
  FavouritedDashbaordsUniqueUserDashboardIdIx = 'favourited_dashbaords_unique_user_dashboard_id_ix'
}

/** input type for incrementing numeric columns in table "favorite_dashboards" */
export type Favorite_Dashboards_Inc_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "favorite_dashboards" */
export type Favorite_Dashboards_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Favorite_Dashboards_Max_Fields = {
  __typename?: 'favorite_dashboards_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Favorite_Dashboards_Min_Fields = {
  __typename?: 'favorite_dashboards_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "favorite_dashboards" */
export type Favorite_Dashboards_Mutation_Response = {
  __typename?: 'favorite_dashboards_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Favorite_Dashboards>;
};

/** on_conflict condition type for table "favorite_dashboards" */
export type Favorite_Dashboards_On_Conflict = {
  constraint: Favorite_Dashboards_Constraint;
  update_columns: Array<Favorite_Dashboards_Update_Column>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};

/** Ordering options when selecting data from "favorite_dashboards". */
export type Favorite_Dashboards_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard?: Maybe<Dashboards_Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: favorite_dashboards */
export type Favorite_Dashboards_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "favorite_dashboards" */
export enum Favorite_Dashboards_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "favorite_dashboards" */
export type Favorite_Dashboards_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Favorite_Dashboards_Stddev_Fields = {
  __typename?: 'favorite_dashboards_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Stddev_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Favorite_Dashboards_Stddev_Pop_Fields = {
  __typename?: 'favorite_dashboards_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Stddev_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Favorite_Dashboards_Stddev_Samp_Fields = {
  __typename?: 'favorite_dashboards_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Stddev_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "favorite_dashboards" */
export type Favorite_Dashboards_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Favorite_Dashboards_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Favorite_Dashboards_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Favorite_Dashboards_Sum_Fields = {
  __typename?: 'favorite_dashboards_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Sum_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** update columns of table "favorite_dashboards" */
export enum Favorite_Dashboards_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Favorite_Dashboards_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Favorite_Dashboards_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Favorite_Dashboards_Set_Input>;
  where: Favorite_Dashboards_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Favorite_Dashboards_Var_Pop_Fields = {
  __typename?: 'favorite_dashboards_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Var_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Favorite_Dashboards_Var_Samp_Fields = {
  __typename?: 'favorite_dashboards_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Var_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Favorite_Dashboards_Variance_Fields = {
  __typename?: 'favorite_dashboards_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "favorite_dashboards" */
export type Favorite_Dashboards_Variance_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** columns and relationships of "favorite_queries" */
export type Favorite_Queries = {
  __typename?: 'favorite_queries';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  /** An object relationship */
  query: Queries;
  query_id: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['Int'];
};

/** aggregated selection of "favorite_queries" */
export type Favorite_Queries_Aggregate = {
  __typename?: 'favorite_queries_aggregate';
  aggregate?: Maybe<Favorite_Queries_Aggregate_Fields>;
  nodes: Array<Favorite_Queries>;
};

export type Favorite_Queries_Aggregate_Bool_Exp = {
  count?: Maybe<Favorite_Queries_Aggregate_Bool_Exp_Count>;
};

export type Favorite_Queries_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Favorite_Queries_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Favorite_Queries_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "favorite_queries" */
export type Favorite_Queries_Aggregate_Fields = {
  __typename?: 'favorite_queries_aggregate_fields';
  avg?: Maybe<Favorite_Queries_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Favorite_Queries_Max_Fields>;
  min?: Maybe<Favorite_Queries_Min_Fields>;
  stddev?: Maybe<Favorite_Queries_Stddev_Fields>;
  stddev_pop?: Maybe<Favorite_Queries_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Favorite_Queries_Stddev_Samp_Fields>;
  sum?: Maybe<Favorite_Queries_Sum_Fields>;
  var_pop?: Maybe<Favorite_Queries_Var_Pop_Fields>;
  var_samp?: Maybe<Favorite_Queries_Var_Samp_Fields>;
  variance?: Maybe<Favorite_Queries_Variance_Fields>;
};


/** aggregate fields of "favorite_queries" */
export type Favorite_Queries_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Favorite_Queries_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "favorite_queries" */
export type Favorite_Queries_Aggregate_Order_By = {
  avg?: Maybe<Favorite_Queries_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Favorite_Queries_Max_Order_By>;
  min?: Maybe<Favorite_Queries_Min_Order_By>;
  stddev?: Maybe<Favorite_Queries_Stddev_Order_By>;
  stddev_pop?: Maybe<Favorite_Queries_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Favorite_Queries_Stddev_Samp_Order_By>;
  sum?: Maybe<Favorite_Queries_Sum_Order_By>;
  var_pop?: Maybe<Favorite_Queries_Var_Pop_Order_By>;
  var_samp?: Maybe<Favorite_Queries_Var_Samp_Order_By>;
  variance?: Maybe<Favorite_Queries_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "favorite_queries" */
export type Favorite_Queries_Arr_Rel_Insert_Input = {
  data: Array<Favorite_Queries_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Favorite_Queries_On_Conflict>;
};

/** aggregate avg on columns */
export type Favorite_Queries_Avg_Fields = {
  __typename?: 'favorite_queries_avg_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "favorite_queries" */
export type Favorite_Queries_Avg_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "favorite_queries". All fields are combined with a logical 'AND'. */
export type Favorite_Queries_Bool_Exp = {
  _and?: Maybe<Array<Favorite_Queries_Bool_Exp>>;
  _not?: Maybe<Favorite_Queries_Bool_Exp>;
  _or?: Maybe<Array<Favorite_Queries_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "favorite_queries" */
export enum Favorite_Queries_Constraint {
  /** unique or primary key constraint on columns "id" */
  FavoriteQueriesPkey = 'favorite_queries_pkey',
  /** unique or primary key constraint on columns "query_id", "user_id" */
  FavoriteQueriesUniqueUserDashboardIdIx = 'favorite_queries_unique_user_dashboard_id_ix'
}

/** input type for incrementing numeric columns in table "favorite_queries" */
export type Favorite_Queries_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "favorite_queries" */
export type Favorite_Queries_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Favorite_Queries_Max_Fields = {
  __typename?: 'favorite_queries_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "favorite_queries" */
export type Favorite_Queries_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Favorite_Queries_Min_Fields = {
  __typename?: 'favorite_queries_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "favorite_queries" */
export type Favorite_Queries_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "favorite_queries" */
export type Favorite_Queries_Mutation_Response = {
  __typename?: 'favorite_queries_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Favorite_Queries>;
};

/** on_conflict condition type for table "favorite_queries" */
export type Favorite_Queries_On_Conflict = {
  constraint: Favorite_Queries_Constraint;
  update_columns: Array<Favorite_Queries_Update_Column>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};

/** Ordering options when selecting data from "favorite_queries". */
export type Favorite_Queries_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: favorite_queries */
export type Favorite_Queries_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "favorite_queries" */
export enum Favorite_Queries_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "favorite_queries" */
export type Favorite_Queries_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Favorite_Queries_Stddev_Fields = {
  __typename?: 'favorite_queries_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "favorite_queries" */
export type Favorite_Queries_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Favorite_Queries_Stddev_Pop_Fields = {
  __typename?: 'favorite_queries_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "favorite_queries" */
export type Favorite_Queries_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Favorite_Queries_Stddev_Samp_Fields = {
  __typename?: 'favorite_queries_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "favorite_queries" */
export type Favorite_Queries_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "favorite_queries" */
export type Favorite_Queries_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Favorite_Queries_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Favorite_Queries_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Favorite_Queries_Sum_Fields = {
  __typename?: 'favorite_queries_sum_fields';
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "favorite_queries" */
export type Favorite_Queries_Sum_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** update columns of table "favorite_queries" */
export enum Favorite_Queries_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Favorite_Queries_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Favorite_Queries_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Favorite_Queries_Set_Input>;
  where: Favorite_Queries_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Favorite_Queries_Var_Pop_Fields = {
  __typename?: 'favorite_queries_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "favorite_queries" */
export type Favorite_Queries_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Favorite_Queries_Var_Samp_Fields = {
  __typename?: 'favorite_queries_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "favorite_queries" */
export type Favorite_Queries_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Favorite_Queries_Variance_Fields = {
  __typename?: 'favorite_queries_variance_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "favorite_queries" */
export type Favorite_Queries_Variance_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** columns and relationships of "favourited_schemas" */
export type Favourited_Schemas = {
  __typename?: 'favourited_schemas';
  /** An object relationship */
  blockchain_schema?: Maybe<Blockchain_Schemas>;
  id: Scalars['uuid'];
  schema_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  user: Users;
  user_id: Scalars['Int'];
};

/** aggregated selection of "favourited_schemas" */
export type Favourited_Schemas_Aggregate = {
  __typename?: 'favourited_schemas_aggregate';
  aggregate?: Maybe<Favourited_Schemas_Aggregate_Fields>;
  nodes: Array<Favourited_Schemas>;
};

/** aggregate fields of "favourited_schemas" */
export type Favourited_Schemas_Aggregate_Fields = {
  __typename?: 'favourited_schemas_aggregate_fields';
  avg?: Maybe<Favourited_Schemas_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Favourited_Schemas_Max_Fields>;
  min?: Maybe<Favourited_Schemas_Min_Fields>;
  stddev?: Maybe<Favourited_Schemas_Stddev_Fields>;
  stddev_pop?: Maybe<Favourited_Schemas_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Favourited_Schemas_Stddev_Samp_Fields>;
  sum?: Maybe<Favourited_Schemas_Sum_Fields>;
  var_pop?: Maybe<Favourited_Schemas_Var_Pop_Fields>;
  var_samp?: Maybe<Favourited_Schemas_Var_Samp_Fields>;
  variance?: Maybe<Favourited_Schemas_Variance_Fields>;
};


/** aggregate fields of "favourited_schemas" */
export type Favourited_Schemas_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Favourited_Schemas_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Favourited_Schemas_Avg_Fields = {
  __typename?: 'favourited_schemas_avg_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "favourited_schemas". All fields are combined with a logical 'AND'. */
export type Favourited_Schemas_Bool_Exp = {
  _and?: Maybe<Array<Favourited_Schemas_Bool_Exp>>;
  _not?: Maybe<Favourited_Schemas_Bool_Exp>;
  _or?: Maybe<Array<Favourited_Schemas_Bool_Exp>>;
  blockchain_schema?: Maybe<Blockchain_Schemas_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  schema_id?: Maybe<Uuid_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "favourited_schemas" */
export enum Favourited_Schemas_Constraint {
  /** unique or primary key constraint on columns "id" */
  FavouritedSchemaPkey = 'favourited_schema_pkey'
}

/** input type for incrementing numeric columns in table "favourited_schemas" */
export type Favourited_Schemas_Inc_Input = {
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "favourited_schemas" */
export type Favourited_Schemas_Insert_Input = {
  blockchain_schema?: Maybe<Blockchain_Schemas_Obj_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  schema_id?: Maybe<Scalars['uuid']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Favourited_Schemas_Max_Fields = {
  __typename?: 'favourited_schemas_max_fields';
  id?: Maybe<Scalars['uuid']>;
  schema_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Favourited_Schemas_Min_Fields = {
  __typename?: 'favourited_schemas_min_fields';
  id?: Maybe<Scalars['uuid']>;
  schema_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "favourited_schemas" */
export type Favourited_Schemas_Mutation_Response = {
  __typename?: 'favourited_schemas_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Favourited_Schemas>;
};

/** on_conflict condition type for table "favourited_schemas" */
export type Favourited_Schemas_On_Conflict = {
  constraint: Favourited_Schemas_Constraint;
  update_columns: Array<Favourited_Schemas_Update_Column>;
  where?: Maybe<Favourited_Schemas_Bool_Exp>;
};

/** Ordering options when selecting data from "favourited_schemas". */
export type Favourited_Schemas_Order_By = {
  blockchain_schema?: Maybe<Blockchain_Schemas_Order_By>;
  id?: Maybe<Order_By>;
  schema_id?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: favourited_schemas */
export type Favourited_Schemas_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "favourited_schemas" */
export enum Favourited_Schemas_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  SchemaId = 'schema_id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "favourited_schemas" */
export type Favourited_Schemas_Set_Input = {
  id?: Maybe<Scalars['uuid']>;
  schema_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Favourited_Schemas_Stddev_Fields = {
  __typename?: 'favourited_schemas_stddev_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Favourited_Schemas_Stddev_Pop_Fields = {
  __typename?: 'favourited_schemas_stddev_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Favourited_Schemas_Stddev_Samp_Fields = {
  __typename?: 'favourited_schemas_stddev_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "favourited_schemas" */
export type Favourited_Schemas_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Favourited_Schemas_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Favourited_Schemas_Stream_Cursor_Value_Input = {
  id?: Maybe<Scalars['uuid']>;
  schema_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Favourited_Schemas_Sum_Fields = {
  __typename?: 'favourited_schemas_sum_fields';
  user_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "favourited_schemas" */
export enum Favourited_Schemas_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  SchemaId = 'schema_id',
  /** column name */
  UserId = 'user_id'
}

export type Favourited_Schemas_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Favourited_Schemas_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Favourited_Schemas_Set_Input>;
  where: Favourited_Schemas_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Favourited_Schemas_Var_Pop_Fields = {
  __typename?: 'favourited_schemas_var_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Favourited_Schemas_Var_Samp_Fields = {
  __typename?: 'favourited_schemas_var_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Favourited_Schemas_Variance_Fields = {
  __typename?: 'favourited_schemas_variance_fields';
  user_id?: Maybe<Scalars['Float']>;
};


/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: Maybe<Scalars['float8']>;
  _gt?: Maybe<Scalars['float8']>;
  _gte?: Maybe<Scalars['float8']>;
  _in?: Maybe<Array<Scalars['float8']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['float8']>;
  _lte?: Maybe<Scalars['float8']>;
  _neq?: Maybe<Scalars['float8']>;
  _nin?: Maybe<Array<Scalars['float8']>>;
};

export type Fork_Query_Response = {
  __typename?: 'fork_query_response';
  query_id: Scalars['Int'];
};

export type Get_Result_By_Job_Id_Args = {
  want_job_id?: Maybe<Scalars['uuid']>;
};

export type Get_Result_By_Result_Id_Args = {
  want_result_id?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "get_result_template" */
export type Get_Result_Template = {
  __typename?: 'get_result_template';
  data: Scalars['json'];
  job_id: Scalars['uuid'];
  result_id: Scalars['uuid'];
};


/** columns and relationships of "get_result_template" */
export type Get_Result_TemplateDataArgs = {
  path?: Maybe<Scalars['String']>;
};

export type Get_Result_Template_Aggregate = {
  __typename?: 'get_result_template_aggregate';
  aggregate?: Maybe<Get_Result_Template_Aggregate_Fields>;
  nodes: Array<Get_Result_Template>;
};

/** aggregate fields of "get_result_template" */
export type Get_Result_Template_Aggregate_Fields = {
  __typename?: 'get_result_template_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Get_Result_Template_Max_Fields>;
  min?: Maybe<Get_Result_Template_Min_Fields>;
};


/** aggregate fields of "get_result_template" */
export type Get_Result_Template_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Get_Result_Template_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "get_result_template". All fields are combined with a logical 'AND'. */
export type Get_Result_Template_Bool_Exp = {
  _and?: Maybe<Array<Get_Result_Template_Bool_Exp>>;
  _not?: Maybe<Get_Result_Template_Bool_Exp>;
  _or?: Maybe<Array<Get_Result_Template_Bool_Exp>>;
  data?: Maybe<Json_Comparison_Exp>;
  job_id?: Maybe<Uuid_Comparison_Exp>;
  result_id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for inserting data into table "get_result_template" */
export type Get_Result_Template_Insert_Input = {
  data?: Maybe<Scalars['json']>;
  job_id?: Maybe<Scalars['uuid']>;
  result_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Get_Result_Template_Max_Fields = {
  __typename?: 'get_result_template_max_fields';
  job_id?: Maybe<Scalars['uuid']>;
  result_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Get_Result_Template_Min_Fields = {
  __typename?: 'get_result_template_min_fields';
  job_id?: Maybe<Scalars['uuid']>;
  result_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "get_result_template" */
export type Get_Result_Template_Mutation_Response = {
  __typename?: 'get_result_template_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Get_Result_Template>;
};

/** Ordering options when selecting data from "get_result_template". */
export type Get_Result_Template_Order_By = {
  data?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
  result_id?: Maybe<Order_By>;
};

/** select columns of table "get_result_template" */
export enum Get_Result_Template_Select_Column {
  /** column name */
  Data = 'data',
  /** column name */
  JobId = 'job_id',
  /** column name */
  ResultId = 'result_id'
}

/** input type for updating data in table "get_result_template" */
export type Get_Result_Template_Set_Input = {
  data?: Maybe<Scalars['json']>;
  job_id?: Maybe<Scalars['uuid']>;
  result_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "get_result_template" */
export type Get_Result_Template_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Get_Result_Template_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Get_Result_Template_Stream_Cursor_Value_Input = {
  data?: Maybe<Scalars['json']>;
  job_id?: Maybe<Scalars['uuid']>;
  result_id?: Maybe<Scalars['uuid']>;
};

export type Get_Result_Template_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Get_Result_Template_Set_Input>;
  where: Get_Result_Template_Bool_Exp;
};

/** columns and relationships of "handles" */
export type Handles = {
  __typename?: 'handles';
  entity?: Maybe<Scalars['String']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "handles" */
export type Handles_Aggregate = {
  __typename?: 'handles_aggregate';
  aggregate?: Maybe<Handles_Aggregate_Fields>;
  nodes: Array<Handles>;
};

/** aggregate fields of "handles" */
export type Handles_Aggregate_Fields = {
  __typename?: 'handles_aggregate_fields';
  avg?: Maybe<Handles_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Handles_Max_Fields>;
  min?: Maybe<Handles_Min_Fields>;
  stddev?: Maybe<Handles_Stddev_Fields>;
  stddev_pop?: Maybe<Handles_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Handles_Stddev_Samp_Fields>;
  sum?: Maybe<Handles_Sum_Fields>;
  var_pop?: Maybe<Handles_Var_Pop_Fields>;
  var_samp?: Maybe<Handles_Var_Samp_Fields>;
  variance?: Maybe<Handles_Variance_Fields>;
};


/** aggregate fields of "handles" */
export type Handles_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Handles_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Handles_Avg_Fields = {
  __typename?: 'handles_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "handles". All fields are combined with a logical 'AND'. */
export type Handles_Bool_Exp = {
  _and?: Maybe<Array<Handles_Bool_Exp>>;
  _not?: Maybe<Handles_Bool_Exp>;
  _or?: Maybe<Array<Handles_Bool_Exp>>;
  entity?: Maybe<String_Comparison_Exp>;
  handle?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
};

/** aggregate max on columns */
export type Handles_Max_Fields = {
  __typename?: 'handles_max_fields';
  entity?: Maybe<Scalars['String']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Handles_Min_Fields = {
  __typename?: 'handles_min_fields';
  entity?: Maybe<Scalars['String']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** Ordering options when selecting data from "handles". */
export type Handles_Order_By = {
  entity?: Maybe<Order_By>;
  handle?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** select columns of table "handles" */
export enum Handles_Select_Column {
  /** column name */
  Entity = 'entity',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id'
}

/** aggregate stddev on columns */
export type Handles_Stddev_Fields = {
  __typename?: 'handles_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Handles_Stddev_Pop_Fields = {
  __typename?: 'handles_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Handles_Stddev_Samp_Fields = {
  __typename?: 'handles_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "handles" */
export type Handles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Handles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Handles_Stream_Cursor_Value_Input = {
  entity?: Maybe<Scalars['String']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Handles_Sum_Fields = {
  __typename?: 'handles_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Handles_Var_Pop_Fields = {
  __typename?: 'handles_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Handles_Var_Samp_Fields = {
  __typename?: 'handles_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Handles_Variance_Fields = {
  __typename?: 'handles_variance_fields';
  id?: Maybe<Scalars['Float']>;
};


/** Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'. */
export type Interval_Comparison_Exp = {
  _eq?: Maybe<Scalars['interval']>;
  _gt?: Maybe<Scalars['interval']>;
  _gte?: Maybe<Scalars['interval']>;
  _in?: Maybe<Array<Scalars['interval']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['interval']>;
  _lte?: Maybe<Scalars['interval']>;
  _neq?: Maybe<Scalars['interval']>;
  _nin?: Maybe<Array<Scalars['interval']>>;
};


/** Boolean expression to compare columns of type "job_categories". All fields are combined with logical 'AND'. */
export type Job_Categories_Comparison_Exp = {
  _eq?: Maybe<Scalars['job_categories']>;
  _gt?: Maybe<Scalars['job_categories']>;
  _gte?: Maybe<Scalars['job_categories']>;
  _in?: Maybe<Array<Scalars['job_categories']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['job_categories']>;
  _lte?: Maybe<Scalars['job_categories']>;
  _neq?: Maybe<Scalars['job_categories']>;
  _nin?: Maybe<Array<Scalars['job_categories']>>;
};

/** columns and relationships of "jobs" */
export type Jobs = {
  __typename?: 'jobs';
  attempt_number: Scalars['Int'];
  category: Scalars['job_categories'];
  created_at: Scalars['timestamptz'];
  dataset_id?: Maybe<Scalars['Int']>;
  id: Scalars['uuid'];
  locked_until?: Maybe<Scalars['timestamptz']>;
  priority: Scalars['Int'];
  /** An object relationship */
  query: Queries;
  /** An array relationship */
  query_api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  query_api_keys_aggregate: Api_Keys_Aggregate;
  query_id: Scalars['Int'];
  query_parameters: Scalars['jsonb'];
  query_version: Scalars['Int'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "jobs" */
export type JobsQuery_Api_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "jobs" */
export type JobsQuery_Api_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "jobs" */
export type JobsQuery_ParametersArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "jobs" */
export type Jobs_Aggregate = {
  __typename?: 'jobs_aggregate';
  aggregate?: Maybe<Jobs_Aggregate_Fields>;
  nodes: Array<Jobs>;
};

/** aggregate fields of "jobs" */
export type Jobs_Aggregate_Fields = {
  __typename?: 'jobs_aggregate_fields';
  avg?: Maybe<Jobs_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Jobs_Max_Fields>;
  min?: Maybe<Jobs_Min_Fields>;
  stddev?: Maybe<Jobs_Stddev_Fields>;
  stddev_pop?: Maybe<Jobs_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Jobs_Stddev_Samp_Fields>;
  sum?: Maybe<Jobs_Sum_Fields>;
  var_pop?: Maybe<Jobs_Var_Pop_Fields>;
  var_samp?: Maybe<Jobs_Var_Samp_Fields>;
  variance?: Maybe<Jobs_Variance_Fields>;
};


/** aggregate fields of "jobs" */
export type Jobs_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Jobs_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Jobs_Append_Input = {
  query_parameters?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Jobs_Avg_Fields = {
  __typename?: 'jobs_avg_fields';
  attempt_number?: Maybe<Scalars['Float']>;
  dataset_id?: Maybe<Scalars['Float']>;
  priority?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "jobs". All fields are combined with a logical 'AND'. */
export type Jobs_Bool_Exp = {
  _and?: Maybe<Array<Jobs_Bool_Exp>>;
  _not?: Maybe<Jobs_Bool_Exp>;
  _or?: Maybe<Array<Jobs_Bool_Exp>>;
  attempt_number?: Maybe<Int_Comparison_Exp>;
  category?: Maybe<Job_Categories_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dataset_id?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  locked_until?: Maybe<Timestamptz_Comparison_Exp>;
  priority?: Maybe<Int_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_api_keys?: Maybe<Api_Keys_Bool_Exp>;
  query_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  query_parameters?: Maybe<Jsonb_Comparison_Exp>;
  query_version?: Maybe<Int_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "jobs" */
export enum Jobs_Constraint {
  /** unique or primary key constraint on columns "query_parameters", "query_id", "query_version" */
  JobQueryIdQueryVersionQueryParamsUnique = 'job_query_id_query_version_query_params_unique',
  /** unique or primary key constraint on columns "id" */
  JobsPkey = 'jobs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Jobs_Delete_At_Path_Input = {
  query_parameters?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Jobs_Delete_Elem_Input = {
  query_parameters?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Jobs_Delete_Key_Input = {
  query_parameters?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "jobs" */
export type Jobs_Inc_Input = {
  attempt_number?: Maybe<Scalars['Int']>;
  dataset_id?: Maybe<Scalars['Int']>;
  priority?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "jobs" */
export type Jobs_Insert_Input = {
  attempt_number?: Maybe<Scalars['Int']>;
  category?: Maybe<Scalars['job_categories']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  locked_until?: Maybe<Scalars['timestamptz']>;
  priority?: Maybe<Scalars['Int']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Jobs_Max_Fields = {
  __typename?: 'jobs_max_fields';
  attempt_number?: Maybe<Scalars['Int']>;
  category?: Maybe<Scalars['job_categories']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  locked_until?: Maybe<Scalars['timestamptz']>;
  priority?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Jobs_Min_Fields = {
  __typename?: 'jobs_min_fields';
  attempt_number?: Maybe<Scalars['Int']>;
  category?: Maybe<Scalars['job_categories']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  locked_until?: Maybe<Scalars['timestamptz']>;
  priority?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "jobs" */
export type Jobs_Mutation_Response = {
  __typename?: 'jobs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Jobs>;
};

/** on_conflict condition type for table "jobs" */
export type Jobs_On_Conflict = {
  constraint: Jobs_Constraint;
  update_columns: Array<Jobs_Update_Column>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** Ordering options when selecting data from "jobs". */
export type Jobs_Order_By = {
  attempt_number?: Maybe<Order_By>;
  category?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dataset_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  locked_until?: Maybe<Order_By>;
  priority?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  query_id?: Maybe<Order_By>;
  query_parameters?: Maybe<Order_By>;
  query_version?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: jobs */
export type Jobs_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Jobs_Prepend_Input = {
  query_parameters?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "jobs" */
export enum Jobs_Select_Column {
  /** column name */
  AttemptNumber = 'attempt_number',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  Id = 'id',
  /** column name */
  LockedUntil = 'locked_until',
  /** column name */
  Priority = 'priority',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryParameters = 'query_parameters',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "jobs" */
export type Jobs_Set_Input = {
  attempt_number?: Maybe<Scalars['Int']>;
  category?: Maybe<Scalars['job_categories']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  locked_until?: Maybe<Scalars['timestamptz']>;
  priority?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Jobs_Stddev_Fields = {
  __typename?: 'jobs_stddev_fields';
  attempt_number?: Maybe<Scalars['Float']>;
  dataset_id?: Maybe<Scalars['Float']>;
  priority?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Jobs_Stddev_Pop_Fields = {
  __typename?: 'jobs_stddev_pop_fields';
  attempt_number?: Maybe<Scalars['Float']>;
  dataset_id?: Maybe<Scalars['Float']>;
  priority?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Jobs_Stddev_Samp_Fields = {
  __typename?: 'jobs_stddev_samp_fields';
  attempt_number?: Maybe<Scalars['Float']>;
  dataset_id?: Maybe<Scalars['Float']>;
  priority?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "jobs" */
export type Jobs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Jobs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Jobs_Stream_Cursor_Value_Input = {
  attempt_number?: Maybe<Scalars['Int']>;
  category?: Maybe<Scalars['job_categories']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  locked_until?: Maybe<Scalars['timestamptz']>;
  priority?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Jobs_Sum_Fields = {
  __typename?: 'jobs_sum_fields';
  attempt_number?: Maybe<Scalars['Int']>;
  dataset_id?: Maybe<Scalars['Int']>;
  priority?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "jobs" */
export enum Jobs_Update_Column {
  /** column name */
  AttemptNumber = 'attempt_number',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  Id = 'id',
  /** column name */
  LockedUntil = 'locked_until',
  /** column name */
  Priority = 'priority',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryParameters = 'query_parameters',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  UserId = 'user_id'
}

export type Jobs_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Jobs_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Jobs_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Jobs_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Jobs_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Jobs_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Jobs_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Jobs_Set_Input>;
  where: Jobs_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Jobs_Var_Pop_Fields = {
  __typename?: 'jobs_var_pop_fields';
  attempt_number?: Maybe<Scalars['Float']>;
  dataset_id?: Maybe<Scalars['Float']>;
  priority?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Jobs_Var_Samp_Fields = {
  __typename?: 'jobs_var_samp_fields';
  attempt_number?: Maybe<Scalars['Float']>;
  dataset_id?: Maybe<Scalars['Float']>;
  priority?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Jobs_Variance_Fields = {
  __typename?: 'jobs_variance_fields';
  attempt_number?: Maybe<Scalars['Float']>;
  dataset_id?: Maybe<Scalars['Float']>;
  priority?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};


/** Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'. */
export type Json_Comparison_Exp = {
  _eq?: Maybe<Scalars['json']>;
  _gt?: Maybe<Scalars['json']>;
  _gte?: Maybe<Scalars['json']>;
  _in?: Maybe<Array<Scalars['json']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['json']>;
  _lte?: Maybe<Scalars['json']>;
  _neq?: Maybe<Scalars['json']>;
  _nin?: Maybe<Array<Scalars['json']>>;
};


export type Jsonb_Cast_Exp = {
  String?: Maybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: Maybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: Maybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: Maybe<Scalars['jsonb']>;
  _eq?: Maybe<Scalars['jsonb']>;
  _gt?: Maybe<Scalars['jsonb']>;
  _gte?: Maybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: Maybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: Maybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: Maybe<Array<Scalars['String']>>;
  _in?: Maybe<Array<Scalars['jsonb']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['jsonb']>;
  _lte?: Maybe<Scalars['jsonb']>;
  _neq?: Maybe<Scalars['jsonb']>;
  _nin?: Maybe<Array<Scalars['jsonb']>>;
};


/** Boolean expression to compare columns of type "membership_roles". All fields are combined with logical 'AND'. */
export type Membership_Roles_Comparison_Exp = {
  _eq?: Maybe<Scalars['membership_roles']>;
  _gt?: Maybe<Scalars['membership_roles']>;
  _gte?: Maybe<Scalars['membership_roles']>;
  _in?: Maybe<Array<Scalars['membership_roles']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['membership_roles']>;
  _lte?: Maybe<Scalars['membership_roles']>;
  _neq?: Maybe<Scalars['membership_roles']>;
  _nin?: Maybe<Array<Scalars['membership_roles']>>;
};


/** Boolean expression to compare columns of type "membership_statuses". All fields are combined with logical 'AND'. */
export type Membership_Statuses_Comparison_Exp = {
  _eq?: Maybe<Scalars['membership_statuses']>;
  _gt?: Maybe<Scalars['membership_statuses']>;
  _gte?: Maybe<Scalars['membership_statuses']>;
  _in?: Maybe<Array<Scalars['membership_statuses']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['membership_statuses']>;
  _lte?: Maybe<Scalars['membership_statuses']>;
  _neq?: Maybe<Scalars['membership_statuses']>;
  _nin?: Maybe<Array<Scalars['membership_statuses']>>;
};

/** columns and relationships of "memberships" */
export type Memberships = {
  __typename?: 'memberships';
  created_at: Scalars['timestamptz'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  /** An object relationship */
  private_details?: Maybe<Memberships_Private_Details>;
  role: Scalars['membership_roles'];
  status: Scalars['membership_statuses'];
  /** An object relationship */
  team: Teams;
  team_id: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "memberships" */
export type Memberships_Aggregate = {
  __typename?: 'memberships_aggregate';
  aggregate?: Maybe<Memberships_Aggregate_Fields>;
  nodes: Array<Memberships>;
};

export type Memberships_Aggregate_Bool_Exp = {
  count?: Maybe<Memberships_Aggregate_Bool_Exp_Count>;
};

export type Memberships_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Memberships_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Memberships_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "memberships" */
export type Memberships_Aggregate_Fields = {
  __typename?: 'memberships_aggregate_fields';
  avg?: Maybe<Memberships_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Memberships_Max_Fields>;
  min?: Maybe<Memberships_Min_Fields>;
  stddev?: Maybe<Memberships_Stddev_Fields>;
  stddev_pop?: Maybe<Memberships_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Memberships_Stddev_Samp_Fields>;
  sum?: Maybe<Memberships_Sum_Fields>;
  var_pop?: Maybe<Memberships_Var_Pop_Fields>;
  var_samp?: Maybe<Memberships_Var_Samp_Fields>;
  variance?: Maybe<Memberships_Variance_Fields>;
};


/** aggregate fields of "memberships" */
export type Memberships_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Memberships_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "memberships" */
export type Memberships_Aggregate_Order_By = {
  avg?: Maybe<Memberships_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Memberships_Max_Order_By>;
  min?: Maybe<Memberships_Min_Order_By>;
  stddev?: Maybe<Memberships_Stddev_Order_By>;
  stddev_pop?: Maybe<Memberships_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Memberships_Stddev_Samp_Order_By>;
  sum?: Maybe<Memberships_Sum_Order_By>;
  var_pop?: Maybe<Memberships_Var_Pop_Order_By>;
  var_samp?: Maybe<Memberships_Var_Samp_Order_By>;
  variance?: Maybe<Memberships_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "memberships" */
export type Memberships_Arr_Rel_Insert_Input = {
  data: Array<Memberships_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Memberships_On_Conflict>;
};

/** aggregate avg on columns */
export type Memberships_Avg_Fields = {
  __typename?: 'memberships_avg_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "memberships" */
export type Memberships_Avg_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "memberships". All fields are combined with a logical 'AND'. */
export type Memberships_Bool_Exp = {
  _and?: Maybe<Array<Memberships_Bool_Exp>>;
  _not?: Maybe<Memberships_Bool_Exp>;
  _or?: Maybe<Array<Memberships_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  private_details?: Maybe<Memberships_Private_Details_Bool_Exp>;
  role?: Maybe<Membership_Roles_Comparison_Exp>;
  status?: Maybe<Membership_Statuses_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "memberships" */
export enum Memberships_Constraint {
  /** unique or primary key constraint on columns "id" */
  MembershipsPkey = 'memberships_pkey',
  /** unique or primary key constraint on columns "email", "team_id" */
  MembershipsUniqueEmailTeamIdIx = 'memberships_unique_email_team_id_ix',
  /** unique or primary key constraint on columns "user_id", "team_id" */
  MembershipsUniqueUserIdTeamIdIx = 'memberships_unique_user_id_team_id_ix'
}

/** input type for incrementing numeric columns in table "memberships" */
export type Memberships_Inc_Input = {
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "memberships" */
export type Memberships_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  private_details?: Maybe<Memberships_Private_Details_Obj_Rel_Insert_Input>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Memberships_Max_Fields = {
  __typename?: 'memberships_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "memberships" */
export type Memberships_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Memberships_Min_Fields = {
  __typename?: 'memberships_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "memberships" */
export type Memberships_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "memberships" */
export type Memberships_Mutation_Response = {
  __typename?: 'memberships_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Memberships>;
};

/** on_conflict condition type for table "memberships" */
export type Memberships_On_Conflict = {
  constraint: Memberships_Constraint;
  update_columns: Array<Memberships_Update_Column>;
  where?: Maybe<Memberships_Bool_Exp>;
};

/** Ordering options when selecting data from "memberships". */
export type Memberships_Order_By = {
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  private_details?: Maybe<Memberships_Private_Details_Order_By>;
  role?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: memberships */
export type Memberships_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** memberships_private_details is a view that is intended to be used to show details of a membership only to the membership owner or related team admins */
export type Memberships_Private_Details = {
  __typename?: 'memberships_private_details';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  /** An object relationship */
  team?: Maybe<Teams>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "memberships_private_details" */
export type Memberships_Private_Details_Aggregate = {
  __typename?: 'memberships_private_details_aggregate';
  aggregate?: Maybe<Memberships_Private_Details_Aggregate_Fields>;
  nodes: Array<Memberships_Private_Details>;
};

/** aggregate fields of "memberships_private_details" */
export type Memberships_Private_Details_Aggregate_Fields = {
  __typename?: 'memberships_private_details_aggregate_fields';
  avg?: Maybe<Memberships_Private_Details_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Memberships_Private_Details_Max_Fields>;
  min?: Maybe<Memberships_Private_Details_Min_Fields>;
  stddev?: Maybe<Memberships_Private_Details_Stddev_Fields>;
  stddev_pop?: Maybe<Memberships_Private_Details_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Memberships_Private_Details_Stddev_Samp_Fields>;
  sum?: Maybe<Memberships_Private_Details_Sum_Fields>;
  var_pop?: Maybe<Memberships_Private_Details_Var_Pop_Fields>;
  var_samp?: Maybe<Memberships_Private_Details_Var_Samp_Fields>;
  variance?: Maybe<Memberships_Private_Details_Variance_Fields>;
};


/** aggregate fields of "memberships_private_details" */
export type Memberships_Private_Details_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Memberships_Private_Details_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Memberships_Private_Details_Avg_Fields = {
  __typename?: 'memberships_private_details_avg_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "memberships_private_details". All fields are combined with a logical 'AND'. */
export type Memberships_Private_Details_Bool_Exp = {
  _and?: Maybe<Array<Memberships_Private_Details_Bool_Exp>>;
  _not?: Maybe<Memberships_Private_Details_Bool_Exp>;
  _or?: Maybe<Array<Memberships_Private_Details_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  role?: Maybe<Membership_Roles_Comparison_Exp>;
  status?: Maybe<Membership_Statuses_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "memberships_private_details" */
export type Memberships_Private_Details_Inc_Input = {
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "memberships_private_details" */
export type Memberships_Private_Details_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Memberships_Private_Details_Max_Fields = {
  __typename?: 'memberships_private_details_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Memberships_Private_Details_Min_Fields = {
  __typename?: 'memberships_private_details_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "memberships_private_details" */
export type Memberships_Private_Details_Mutation_Response = {
  __typename?: 'memberships_private_details_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Memberships_Private_Details>;
};

/** input type for inserting object relation for remote table "memberships_private_details" */
export type Memberships_Private_Details_Obj_Rel_Insert_Input = {
  data: Memberships_Private_Details_Insert_Input;
};

/** Ordering options when selecting data from "memberships_private_details". */
export type Memberships_Private_Details_Order_By = {
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** select columns of table "memberships_private_details" */
export enum Memberships_Private_Details_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "memberships_private_details" */
export type Memberships_Private_Details_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Memberships_Private_Details_Stddev_Fields = {
  __typename?: 'memberships_private_details_stddev_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Memberships_Private_Details_Stddev_Pop_Fields = {
  __typename?: 'memberships_private_details_stddev_pop_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Memberships_Private_Details_Stddev_Samp_Fields = {
  __typename?: 'memberships_private_details_stddev_samp_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "memberships_private_details" */
export type Memberships_Private_Details_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Memberships_Private_Details_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Memberships_Private_Details_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Memberships_Private_Details_Sum_Fields = {
  __typename?: 'memberships_private_details_sum_fields';
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

export type Memberships_Private_Details_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Memberships_Private_Details_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Memberships_Private_Details_Set_Input>;
  where: Memberships_Private_Details_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Memberships_Private_Details_Var_Pop_Fields = {
  __typename?: 'memberships_private_details_var_pop_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Memberships_Private_Details_Var_Samp_Fields = {
  __typename?: 'memberships_private_details_var_samp_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Memberships_Private_Details_Variance_Fields = {
  __typename?: 'memberships_private_details_variance_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** select columns of table "memberships" */
export enum Memberships_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "memberships" */
export type Memberships_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Memberships_Stddev_Fields = {
  __typename?: 'memberships_stddev_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "memberships" */
export type Memberships_Stddev_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Memberships_Stddev_Pop_Fields = {
  __typename?: 'memberships_stddev_pop_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "memberships" */
export type Memberships_Stddev_Pop_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Memberships_Stddev_Samp_Fields = {
  __typename?: 'memberships_stddev_samp_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "memberships" */
export type Memberships_Stddev_Samp_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "memberships" */
export type Memberships_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Memberships_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Memberships_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['membership_roles']>;
  status?: Maybe<Scalars['membership_statuses']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Memberships_Sum_Fields = {
  __typename?: 'memberships_sum_fields';
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "memberships" */
export type Memberships_Sum_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** update columns of table "memberships" */
export enum Memberships_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Memberships_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Memberships_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Memberships_Set_Input>;
  where: Memberships_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Memberships_Var_Pop_Fields = {
  __typename?: 'memberships_var_pop_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "memberships" */
export type Memberships_Var_Pop_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Memberships_Var_Samp_Fields = {
  __typename?: 'memberships_var_samp_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "memberships" */
export type Memberships_Var_Samp_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Memberships_Variance_Fields = {
  __typename?: 'memberships_variance_fields';
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "memberships" */
export type Memberships_Variance_Order_By = {
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  accept_invite?: Maybe<AcceptInviteResponse>;
  accept_invite_v2?: Maybe<AcceptInviteResponse>;
  cancel_api_user_pending_subscription_change: CancelApiUserPendingSubscriptionChangeResponse;
  cancel_api_user_subscription: CancelApiUserSubscriptionResponse;
  cancel_execution?: Maybe<CancelExecutionResponse>;
  /** cancel_team_pending_subscription_change */
  cancel_team_pending_subscription_change: CancelTeamPendingSubscriptionChangeResponse;
  cancel_user_pending_subscription_change: CancelUserPendingSubscriptionChangeResponse;
  change_email?: Maybe<ChangeEmailOutput>;
  change_password?: Maybe<ChangePasswordResult>;
  complete_nlq_model: CompleteNlqModelResponse;
  complete_stripe_checkout_session: CompleteStripeCheckoutSessionResponse;
  create_dashboard_schedule: CreateDashboardScheduleResponse;
  create_folder: Folder;
  create_materialized_view: CreateMaterializedViewResponse;
  create_query: CreateQueryResponse;
  create_query_schedule: CreateQueryScheduleResponse;
  create_team?: Maybe<CreateTeamResponse>;
  create_team_api_key: CreateTeamApiKeyResponse;
  /** create_team_checkout_session */
  create_team_checkout_session: CreateTeamCheckoutSessionResponse;
  create_user_api_key: CreateUserApiKeyResponse;
  create_user_checkout_session: CreateUserCheckoutSessionResponse;
  create_wand_query: CreateWandQueryResponse;
  debug_wand_query: DebugWandQueryResponse;
  delete_account?: Maybe<DeleteAccountResult>;
  /** delete data from the table: "api_keys" */
  delete_api_keys?: Maybe<Api_Keys_Mutation_Response>;
  /** delete single row from the table: "api_keys" */
  delete_api_keys_by_pk?: Maybe<Api_Keys>;
  /** delete data from the table: "api_user_service_tiers" */
  delete_api_user_service_tiers?: Maybe<Api_User_Service_Tiers_Mutation_Response>;
  /** delete single row from the table: "api_user_service_tiers" */
  delete_api_user_service_tiers_by_pk?: Maybe<Api_User_Service_Tiers>;
  /** delete data from the table: "arrakis_schemas" */
  delete_arrakis_schemas?: Maybe<Arrakis_Schemas_Mutation_Response>;
  /** delete single row from the table: "arrakis_schemas" */
  delete_arrakis_schemas_by_pk?: Maybe<Arrakis_Schemas>;
  /** delete data from the table: "blockchain_schemas" */
  delete_blockchain_schemas?: Maybe<Blockchain_Schemas_Mutation_Response>;
  /** delete single row from the table: "blockchain_schemas" */
  delete_blockchain_schemas_by_pk?: Maybe<Blockchain_Schemas>;
  /** delete data from the table: "contract_submissions" */
  delete_contract_submissions?: Maybe<Contract_Submissions_Mutation_Response>;
  /** delete single row from the table: "contract_submissions" */
  delete_contract_submissions_by_pk?: Maybe<Contract_Submissions>;
  delete_dashboard_schedule: DeleteDashboardScheduleResponse;
  /** delete data from the table: "dashboard_trending_scores" */
  delete_dashboard_trending_scores?: Maybe<Dashboard_Trending_Scores_Mutation_Response>;
  /** delete single row from the table: "dashboard_trending_scores" */
  delete_dashboard_trending_scores_by_pk?: Maybe<Dashboard_Trending_Scores>;
  /** delete data from the table: "dashboards" */
  delete_dashboards?: Maybe<Dashboards_Mutation_Response>;
  /** delete single row from the table: "dashboards" */
  delete_dashboards_by_pk?: Maybe<Dashboards>;
  /** delete data from the table: "datasets" */
  delete_datasets?: Maybe<Datasets_Mutation_Response>;
  /** delete single row from the table: "datasets" */
  delete_datasets_by_pk?: Maybe<Datasets>;
  /** delete data from the table: "favorite_dashboards" */
  delete_favorite_dashboards?: Maybe<Favorite_Dashboards_Mutation_Response>;
  /** delete single row from the table: "favorite_dashboards" */
  delete_favorite_dashboards_by_pk?: Maybe<Favorite_Dashboards>;
  /** delete data from the table: "favorite_queries" */
  delete_favorite_queries?: Maybe<Favorite_Queries_Mutation_Response>;
  /** delete single row from the table: "favorite_queries" */
  delete_favorite_queries_by_pk?: Maybe<Favorite_Queries>;
  /** delete data from the table: "favourited_schemas" */
  delete_favourited_schemas?: Maybe<Favourited_Schemas_Mutation_Response>;
  /** delete single row from the table: "favourited_schemas" */
  delete_favourited_schemas_by_pk?: Maybe<Favourited_Schemas>;
  /** delete data from the table: "get_result_template" */
  delete_get_result_template?: Maybe<Get_Result_Template_Mutation_Response>;
  /** delete data from the table: "jobs" */
  delete_jobs?: Maybe<Jobs_Mutation_Response>;
  /** delete single row from the table: "jobs" */
  delete_jobs_by_pk?: Maybe<Jobs>;
  /** delete data from the table: "memberships" */
  delete_memberships?: Maybe<Memberships_Mutation_Response>;
  /** delete single row from the table: "memberships" */
  delete_memberships_by_pk?: Maybe<Memberships>;
  /** delete data from the table: "memberships_private_details" */
  delete_memberships_private_details?: Maybe<Memberships_Private_Details_Mutation_Response>;
  /** delete data from the table: "onboarding_questions" */
  delete_onboarding_questions?: Maybe<Onboarding_Questions_Mutation_Response>;
  /** delete single row from the table: "onboarding_questions" */
  delete_onboarding_questions_by_pk?: Maybe<Onboarding_Questions>;
  /** delete data from the table: "operation_costs" */
  delete_operation_costs?: Maybe<Operation_Costs_Mutation_Response>;
  /** delete single row from the table: "operation_costs" */
  delete_operation_costs_by_pk?: Maybe<Operation_Costs>;
  /** delete data from the table: "param_widgets" */
  delete_param_widgets?: Maybe<Param_Widgets_Mutation_Response>;
  /** delete single row from the table: "param_widgets" */
  delete_param_widgets_by_pk?: Maybe<Param_Widgets>;
  /** delete data from the table: "pending_api_user_subscription_updates" */
  delete_pending_api_user_subscription_updates?: Maybe<Pending_Api_User_Subscription_Updates_Mutation_Response>;
  /** delete single row from the table: "pending_api_user_subscription_updates" */
  delete_pending_api_user_subscription_updates_by_pk?: Maybe<Pending_Api_User_Subscription_Updates>;
  /** delete data from the table: "pending_team_subscription_updates" */
  delete_pending_team_subscription_updates?: Maybe<Pending_Team_Subscription_Updates_Mutation_Response>;
  /** delete single row from the table: "pending_team_subscription_updates" */
  delete_pending_team_subscription_updates_by_pk?: Maybe<Pending_Team_Subscription_Updates>;
  /** delete data from the table: "pending_user_subscription_updates" */
  delete_pending_user_subscription_updates?: Maybe<Pending_User_Subscription_Updates_Mutation_Response>;
  /** delete single row from the table: "pending_user_subscription_updates" */
  delete_pending_user_subscription_updates_by_pk?: Maybe<Pending_User_Subscription_Updates>;
  /** delete data from the table: "pro_badge" */
  delete_pro_badge?: Maybe<Pro_Badge_Mutation_Response>;
  /** delete data from the table: "queries" */
  delete_queries?: Maybe<Queries_Mutation_Response>;
  /** delete single row from the table: "queries" */
  delete_queries_by_pk?: Maybe<Queries>;
  /** delete data from the table: "query_errors" */
  delete_query_errors?: Maybe<Query_Errors_Mutation_Response>;
  /** delete single row from the table: "query_errors" */
  delete_query_errors_by_pk?: Maybe<Query_Errors>;
  /** delete data from the table: "query_event_metadata" */
  delete_query_event_metadata?: Maybe<Query_Event_Metadata_Mutation_Response>;
  /** delete single row from the table: "query_event_metadata" */
  delete_query_event_metadata_by_pk?: Maybe<Query_Event_Metadata>;
  /** delete data from the table: "query_event_types" */
  delete_query_event_types?: Maybe<Query_Event_Types_Mutation_Response>;
  /** delete single row from the table: "query_event_types" */
  delete_query_event_types_by_pk?: Maybe<Query_Event_Types>;
  /** delete data from the table: "query_events" */
  delete_query_events?: Maybe<Query_Events_Mutation_Response>;
  /** delete single row from the table: "query_events" */
  delete_query_events_by_pk?: Maybe<Query_Events>;
  /** delete data from the table: "query_results" */
  delete_query_results?: Maybe<Query_Results_Mutation_Response>;
  /** delete single row from the table: "query_results" */
  delete_query_results_by_pk?: Maybe<Query_Results>;
  delete_query_schedule: DeleteQueryScheduleResponse;
  delete_team?: Maybe<DeleteTeamResponse>;
  delete_team_api_key: DeleteTeamApiKeyResponse;
  /** delete data from the table: "team_members_details" */
  delete_team_members_details?: Maybe<Team_Members_Details_Mutation_Response>;
  /** delete data from the table: "team_service_tiers" */
  delete_team_service_tiers?: Maybe<Team_Service_Tiers_Mutation_Response>;
  /** delete single row from the table: "team_service_tiers" */
  delete_team_service_tiers_by_pk?: Maybe<Team_Service_Tiers>;
  /** delete data from the table: "teams" */
  delete_teams?: Maybe<Teams_Mutation_Response>;
  /** delete single row from the table: "teams" */
  delete_teams_by_pk?: Maybe<Teams>;
  /** delete data from the table: "text_widgets" */
  delete_text_widgets?: Maybe<Text_Widgets_Mutation_Response>;
  /** delete single row from the table: "text_widgets" */
  delete_text_widgets_by_pk?: Maybe<Text_Widgets>;
  delete_user_api_key: DeleteUserApiKeyResponse;
  /** delete data from the table: "user_nonce" */
  delete_user_nonce?: Maybe<User_Nonce_Mutation_Response>;
  /** delete single row from the table: "user_nonce" */
  delete_user_nonce_by_pk?: Maybe<User_Nonce>;
  /** delete data from the table: "user_private" */
  delete_user_private?: Maybe<User_Private_Mutation_Response>;
  /** delete data from the table: "user_service_tiers" */
  delete_user_service_tiers?: Maybe<User_Service_Tiers_Mutation_Response>;
  /** delete single row from the table: "user_service_tiers" */
  delete_user_service_tiers_by_pk?: Maybe<User_Service_Tiers>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  /** delete data from the table: "visualization_widgets" */
  delete_visualization_widgets?: Maybe<Visualization_Widgets_Mutation_Response>;
  /** delete single row from the table: "visualization_widgets" */
  delete_visualization_widgets_by_pk?: Maybe<Visualization_Widgets>;
  /** delete data from the table: "visualizations" */
  delete_visualizations?: Maybe<Visualizations_Mutation_Response>;
  /** delete single row from the table: "visualizations" */
  delete_visualizations_by_pk?: Maybe<Visualizations>;
  /** delete data from the table: "wand_completions" */
  delete_wand_completions?: Maybe<Wand_Completions_Mutation_Response>;
  /** delete single row from the table: "wand_completions" */
  delete_wand_completions_by_pk?: Maybe<Wand_Completions>;
  downgrade_api_user_subscription: DowngradeApiUserSubscriptionResponse;
  /** downgrade_team_subscription */
  downgrade_team_subscription: DowngradeTeamSubscriptionResponse;
  downgrade_user_subscription: DowngradeUserSubscriptionResponse;
  edit_wand_query: EditWandQueryResponse;
  execute_query_v3?: Maybe<ExecuteQueryResponse>;
  fork_dashboard_v2?: Maybe<ForkDashboardResponse>;
  fork_query?: Maybe<Fork_Query_Response>;
  fork_query_v3: ForkQueryV3Response;
  generate_data_upload_url?: Maybe<PresignedUrlResponse>;
  generate_upload_url?: Maybe<PresignedUrlResponse>;
  get_table_preview: GetTablePreviewResponse;
  /** insert data into the table: "api_keys" */
  insert_api_keys?: Maybe<Api_Keys_Mutation_Response>;
  /** insert a single row into the table: "api_keys" */
  insert_api_keys_one?: Maybe<Api_Keys>;
  /** insert data into the table: "api_user_service_tiers" */
  insert_api_user_service_tiers?: Maybe<Api_User_Service_Tiers_Mutation_Response>;
  /** insert a single row into the table: "api_user_service_tiers" */
  insert_api_user_service_tiers_one?: Maybe<Api_User_Service_Tiers>;
  /** insert data into the table: "arrakis_schemas" */
  insert_arrakis_schemas?: Maybe<Arrakis_Schemas_Mutation_Response>;
  /** insert a single row into the table: "arrakis_schemas" */
  insert_arrakis_schemas_one?: Maybe<Arrakis_Schemas>;
  /** insert data into the table: "blockchain_schemas" */
  insert_blockchain_schemas?: Maybe<Blockchain_Schemas_Mutation_Response>;
  /** insert a single row into the table: "blockchain_schemas" */
  insert_blockchain_schemas_one?: Maybe<Blockchain_Schemas>;
  /** insert data into the table: "contract_submissions" */
  insert_contract_submissions?: Maybe<Contract_Submissions_Mutation_Response>;
  /** insert a single row into the table: "contract_submissions" */
  insert_contract_submissions_one?: Maybe<Contract_Submissions>;
  /** insert data into the table: "dashboard_trending_scores" */
  insert_dashboard_trending_scores?: Maybe<Dashboard_Trending_Scores_Mutation_Response>;
  /** insert a single row into the table: "dashboard_trending_scores" */
  insert_dashboard_trending_scores_one?: Maybe<Dashboard_Trending_Scores>;
  /** insert data into the table: "dashboards" */
  insert_dashboards?: Maybe<Dashboards_Mutation_Response>;
  /** insert a single row into the table: "dashboards" */
  insert_dashboards_one?: Maybe<Dashboards>;
  /** insert data into the table: "datasets" */
  insert_datasets?: Maybe<Datasets_Mutation_Response>;
  /** insert a single row into the table: "datasets" */
  insert_datasets_one?: Maybe<Datasets>;
  /** insert data into the table: "favorite_dashboards" */
  insert_favorite_dashboards?: Maybe<Favorite_Dashboards_Mutation_Response>;
  /** insert a single row into the table: "favorite_dashboards" */
  insert_favorite_dashboards_one?: Maybe<Favorite_Dashboards>;
  /** insert data into the table: "favorite_queries" */
  insert_favorite_queries?: Maybe<Favorite_Queries_Mutation_Response>;
  /** insert a single row into the table: "favorite_queries" */
  insert_favorite_queries_one?: Maybe<Favorite_Queries>;
  /** insert data into the table: "favourited_schemas" */
  insert_favourited_schemas?: Maybe<Favourited_Schemas_Mutation_Response>;
  /** insert a single row into the table: "favourited_schemas" */
  insert_favourited_schemas_one?: Maybe<Favourited_Schemas>;
  /** insert data into the table: "get_result_template" */
  insert_get_result_template?: Maybe<Get_Result_Template_Mutation_Response>;
  /** insert a single row into the table: "get_result_template" */
  insert_get_result_template_one?: Maybe<Get_Result_Template>;
  /** insert data into the table: "jobs" */
  insert_jobs?: Maybe<Jobs_Mutation_Response>;
  /** insert a single row into the table: "jobs" */
  insert_jobs_one?: Maybe<Jobs>;
  /** insert data into the table: "memberships" */
  insert_memberships?: Maybe<Memberships_Mutation_Response>;
  /** insert a single row into the table: "memberships" */
  insert_memberships_one?: Maybe<Memberships>;
  /** insert data into the table: "memberships_private_details" */
  insert_memberships_private_details?: Maybe<Memberships_Private_Details_Mutation_Response>;
  /** insert a single row into the table: "memberships_private_details" */
  insert_memberships_private_details_one?: Maybe<Memberships_Private_Details>;
  /** insert data into the table: "onboarding_questions" */
  insert_onboarding_questions?: Maybe<Onboarding_Questions_Mutation_Response>;
  /** insert a single row into the table: "onboarding_questions" */
  insert_onboarding_questions_one?: Maybe<Onboarding_Questions>;
  /** insert data into the table: "operation_costs" */
  insert_operation_costs?: Maybe<Operation_Costs_Mutation_Response>;
  /** insert a single row into the table: "operation_costs" */
  insert_operation_costs_one?: Maybe<Operation_Costs>;
  /** insert data into the table: "param_widgets" */
  insert_param_widgets?: Maybe<Param_Widgets_Mutation_Response>;
  /** insert a single row into the table: "param_widgets" */
  insert_param_widgets_one?: Maybe<Param_Widgets>;
  /** insert data into the table: "pending_api_user_subscription_updates" */
  insert_pending_api_user_subscription_updates?: Maybe<Pending_Api_User_Subscription_Updates_Mutation_Response>;
  /** insert a single row into the table: "pending_api_user_subscription_updates" */
  insert_pending_api_user_subscription_updates_one?: Maybe<Pending_Api_User_Subscription_Updates>;
  /** insert data into the table: "pending_team_subscription_updates" */
  insert_pending_team_subscription_updates?: Maybe<Pending_Team_Subscription_Updates_Mutation_Response>;
  /** insert a single row into the table: "pending_team_subscription_updates" */
  insert_pending_team_subscription_updates_one?: Maybe<Pending_Team_Subscription_Updates>;
  /** insert data into the table: "pending_user_subscription_updates" */
  insert_pending_user_subscription_updates?: Maybe<Pending_User_Subscription_Updates_Mutation_Response>;
  /** insert a single row into the table: "pending_user_subscription_updates" */
  insert_pending_user_subscription_updates_one?: Maybe<Pending_User_Subscription_Updates>;
  /** insert data into the table: "pro_badge" */
  insert_pro_badge?: Maybe<Pro_Badge_Mutation_Response>;
  /** insert a single row into the table: "pro_badge" */
  insert_pro_badge_one?: Maybe<Pro_Badge>;
  /** insert data into the table: "queries" */
  insert_queries?: Maybe<Queries_Mutation_Response>;
  /** insert a single row into the table: "queries" */
  insert_queries_one?: Maybe<Queries>;
  /** insert data into the table: "query_errors" */
  insert_query_errors?: Maybe<Query_Errors_Mutation_Response>;
  /** insert a single row into the table: "query_errors" */
  insert_query_errors_one?: Maybe<Query_Errors>;
  /** insert data into the table: "query_event_metadata" */
  insert_query_event_metadata?: Maybe<Query_Event_Metadata_Mutation_Response>;
  /** insert a single row into the table: "query_event_metadata" */
  insert_query_event_metadata_one?: Maybe<Query_Event_Metadata>;
  /** insert data into the table: "query_event_types" */
  insert_query_event_types?: Maybe<Query_Event_Types_Mutation_Response>;
  /** insert a single row into the table: "query_event_types" */
  insert_query_event_types_one?: Maybe<Query_Event_Types>;
  /** insert data into the table: "query_events" */
  insert_query_events?: Maybe<Query_Events_Mutation_Response>;
  /** insert a single row into the table: "query_events" */
  insert_query_events_one?: Maybe<Query_Events>;
  /** insert data into the table: "query_results" */
  insert_query_results?: Maybe<Query_Results_Mutation_Response>;
  /** insert a single row into the table: "query_results" */
  insert_query_results_one?: Maybe<Query_Results>;
  /** insert data into the table: "team_members_details" */
  insert_team_members_details?: Maybe<Team_Members_Details_Mutation_Response>;
  /** insert a single row into the table: "team_members_details" */
  insert_team_members_details_one?: Maybe<Team_Members_Details>;
  /** insert data into the table: "team_service_tiers" */
  insert_team_service_tiers?: Maybe<Team_Service_Tiers_Mutation_Response>;
  /** insert a single row into the table: "team_service_tiers" */
  insert_team_service_tiers_one?: Maybe<Team_Service_Tiers>;
  /** insert data into the table: "teams" */
  insert_teams?: Maybe<Teams_Mutation_Response>;
  /** insert a single row into the table: "teams" */
  insert_teams_one?: Maybe<Teams>;
  /** insert data into the table: "text_widgets" */
  insert_text_widgets?: Maybe<Text_Widgets_Mutation_Response>;
  /** insert a single row into the table: "text_widgets" */
  insert_text_widgets_one?: Maybe<Text_Widgets>;
  /** insert data into the table: "user_nonce" */
  insert_user_nonce?: Maybe<User_Nonce_Mutation_Response>;
  /** insert a single row into the table: "user_nonce" */
  insert_user_nonce_one?: Maybe<User_Nonce>;
  /** insert data into the table: "user_private" */
  insert_user_private?: Maybe<User_Private_Mutation_Response>;
  /** insert a single row into the table: "user_private" */
  insert_user_private_one?: Maybe<User_Private>;
  /** insert data into the table: "user_service_tiers" */
  insert_user_service_tiers?: Maybe<User_Service_Tiers_Mutation_Response>;
  /** insert a single row into the table: "user_service_tiers" */
  insert_user_service_tiers_one?: Maybe<User_Service_Tiers>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  /** insert data into the table: "visualization_widgets" */
  insert_visualization_widgets?: Maybe<Visualization_Widgets_Mutation_Response>;
  /** insert a single row into the table: "visualization_widgets" */
  insert_visualization_widgets_one?: Maybe<Visualization_Widgets>;
  /** insert data into the table: "visualizations" */
  insert_visualizations?: Maybe<Visualizations_Mutation_Response>;
  /** insert a single row into the table: "visualizations" */
  insert_visualizations_one?: Maybe<Visualizations>;
  /** insert data into the table: "wand_completions" */
  insert_wand_completions?: Maybe<Wand_Completions_Mutation_Response>;
  /** insert a single row into the table: "wand_completions" */
  insert_wand_completions_one?: Maybe<Wand_Completions>;
  invite_member?: Maybe<InviteMemberResponse>;
  invite_member_v2?: Maybe<InviteMemberResponse>;
  migrate_content: MigrateContentResponse;
  migrate_legacy_plan: MigrateLegacyPlanResponse;
  patch_dashboard_settings?: Maybe<PatchDashboardSettingsResponse>;
  patch_query_settings?: Maybe<PatchQuerySettingsResponse>;
  remove_member?: Maybe<RemoveMemberResponse>;
  resend_email_verification_code?: Maybe<ResendEmailVerificationCodeOutput>;
  resend_invite?: Maybe<ResendInviteResponse>;
  resend_invite_v2?: Maybe<ResendInviteResponse>;
  restore_query: RestoreQueryResponse;
  set_max_executions_overage_cost_cents: SetMaxExecutionsOverageCostCentsResponse;
  set_max_overage_cents: SetMaxOverageCentsResponse;
  set_team_max_executions_overage_cost_cents: SetTeamMaxExecutionsOverageCostCentsResponse;
  set_team_max_overage_cents: SetTeamMaxOverageCentsResponse;
  terminate_api_user_subscription: TerminateApiUserSubscriptionResponse;
  transfer_dashboards?: Maybe<Array<Maybe<TransferDashboardsResponse>>>;
  transfer_queries?: Maybe<Array<Maybe<TransferQueriesResponse>>>;
  unlink_wallet_address?: Maybe<UnlinkWalletAddressResult>;
  update_account_for_service_tier?: Maybe<UpdateAccountForServiceTierResponse>;
  /** update data of the table: "api_keys" */
  update_api_keys?: Maybe<Api_Keys_Mutation_Response>;
  /** update single row of the table: "api_keys" */
  update_api_keys_by_pk?: Maybe<Api_Keys>;
  /** update multiples rows of table: "api_keys" */
  update_api_keys_many?: Maybe<Array<Maybe<Api_Keys_Mutation_Response>>>;
  /** update data of the table: "api_user_service_tiers" */
  update_api_user_service_tiers?: Maybe<Api_User_Service_Tiers_Mutation_Response>;
  /** update single row of the table: "api_user_service_tiers" */
  update_api_user_service_tiers_by_pk?: Maybe<Api_User_Service_Tiers>;
  /** update multiples rows of table: "api_user_service_tiers" */
  update_api_user_service_tiers_many?: Maybe<Array<Maybe<Api_User_Service_Tiers_Mutation_Response>>>;
  /** update data of the table: "arrakis_schemas" */
  update_arrakis_schemas?: Maybe<Arrakis_Schemas_Mutation_Response>;
  /** update single row of the table: "arrakis_schemas" */
  update_arrakis_schemas_by_pk?: Maybe<Arrakis_Schemas>;
  /** update multiples rows of table: "arrakis_schemas" */
  update_arrakis_schemas_many?: Maybe<Array<Maybe<Arrakis_Schemas_Mutation_Response>>>;
  /** update data of the table: "blockchain_schemas" */
  update_blockchain_schemas?: Maybe<Blockchain_Schemas_Mutation_Response>;
  /** update single row of the table: "blockchain_schemas" */
  update_blockchain_schemas_by_pk?: Maybe<Blockchain_Schemas>;
  /** update multiples rows of table: "blockchain_schemas" */
  update_blockchain_schemas_many?: Maybe<Array<Maybe<Blockchain_Schemas_Mutation_Response>>>;
  /** update data of the table: "contract_submissions" */
  update_contract_submissions?: Maybe<Contract_Submissions_Mutation_Response>;
  /** update single row of the table: "contract_submissions" */
  update_contract_submissions_by_pk?: Maybe<Contract_Submissions>;
  /** update multiples rows of table: "contract_submissions" */
  update_contract_submissions_many?: Maybe<Array<Maybe<Contract_Submissions_Mutation_Response>>>;
  update_dashboard_schedule: UpdateDashboardScheduleResponse;
  /** update data of the table: "dashboard_trending_scores" */
  update_dashboard_trending_scores?: Maybe<Dashboard_Trending_Scores_Mutation_Response>;
  /** update single row of the table: "dashboard_trending_scores" */
  update_dashboard_trending_scores_by_pk?: Maybe<Dashboard_Trending_Scores>;
  /** update multiples rows of table: "dashboard_trending_scores" */
  update_dashboard_trending_scores_many?: Maybe<Array<Maybe<Dashboard_Trending_Scores_Mutation_Response>>>;
  /** update data of the table: "dashboards" */
  update_dashboards?: Maybe<Dashboards_Mutation_Response>;
  /** update single row of the table: "dashboards" */
  update_dashboards_by_pk?: Maybe<Dashboards>;
  /** update multiples rows of table: "dashboards" */
  update_dashboards_many?: Maybe<Array<Maybe<Dashboards_Mutation_Response>>>;
  /** update data of the table: "datasets" */
  update_datasets?: Maybe<Datasets_Mutation_Response>;
  /** update single row of the table: "datasets" */
  update_datasets_by_pk?: Maybe<Datasets>;
  /** update multiples rows of table: "datasets" */
  update_datasets_many?: Maybe<Array<Maybe<Datasets_Mutation_Response>>>;
  /** update data of the table: "favorite_dashboards" */
  update_favorite_dashboards?: Maybe<Favorite_Dashboards_Mutation_Response>;
  /** update single row of the table: "favorite_dashboards" */
  update_favorite_dashboards_by_pk?: Maybe<Favorite_Dashboards>;
  /** update multiples rows of table: "favorite_dashboards" */
  update_favorite_dashboards_many?: Maybe<Array<Maybe<Favorite_Dashboards_Mutation_Response>>>;
  /** update data of the table: "favorite_queries" */
  update_favorite_queries?: Maybe<Favorite_Queries_Mutation_Response>;
  /** update single row of the table: "favorite_queries" */
  update_favorite_queries_by_pk?: Maybe<Favorite_Queries>;
  /** update multiples rows of table: "favorite_queries" */
  update_favorite_queries_many?: Maybe<Array<Maybe<Favorite_Queries_Mutation_Response>>>;
  /** update data of the table: "favourited_schemas" */
  update_favourited_schemas?: Maybe<Favourited_Schemas_Mutation_Response>;
  /** update single row of the table: "favourited_schemas" */
  update_favourited_schemas_by_pk?: Maybe<Favourited_Schemas>;
  /** update multiples rows of table: "favourited_schemas" */
  update_favourited_schemas_many?: Maybe<Array<Maybe<Favourited_Schemas_Mutation_Response>>>;
  update_folder: Folder;
  /** update data of the table: "get_result_template" */
  update_get_result_template?: Maybe<Get_Result_Template_Mutation_Response>;
  /** update multiples rows of table: "get_result_template" */
  update_get_result_template_many?: Maybe<Array<Maybe<Get_Result_Template_Mutation_Response>>>;
  /** update data of the table: "jobs" */
  update_jobs?: Maybe<Jobs_Mutation_Response>;
  /** update single row of the table: "jobs" */
  update_jobs_by_pk?: Maybe<Jobs>;
  /** update multiples rows of table: "jobs" */
  update_jobs_many?: Maybe<Array<Maybe<Jobs_Mutation_Response>>>;
  /** update data of the table: "memberships" */
  update_memberships?: Maybe<Memberships_Mutation_Response>;
  /** update single row of the table: "memberships" */
  update_memberships_by_pk?: Maybe<Memberships>;
  /** update multiples rows of table: "memberships" */
  update_memberships_many?: Maybe<Array<Maybe<Memberships_Mutation_Response>>>;
  /** update data of the table: "memberships_private_details" */
  update_memberships_private_details?: Maybe<Memberships_Private_Details_Mutation_Response>;
  /** update multiples rows of table: "memberships_private_details" */
  update_memberships_private_details_many?: Maybe<Array<Maybe<Memberships_Private_Details_Mutation_Response>>>;
  /** update data of the table: "onboarding_questions" */
  update_onboarding_questions?: Maybe<Onboarding_Questions_Mutation_Response>;
  /** update single row of the table: "onboarding_questions" */
  update_onboarding_questions_by_pk?: Maybe<Onboarding_Questions>;
  /** update multiples rows of table: "onboarding_questions" */
  update_onboarding_questions_many?: Maybe<Array<Maybe<Onboarding_Questions_Mutation_Response>>>;
  /** update data of the table: "operation_costs" */
  update_operation_costs?: Maybe<Operation_Costs_Mutation_Response>;
  /** update single row of the table: "operation_costs" */
  update_operation_costs_by_pk?: Maybe<Operation_Costs>;
  /** update multiples rows of table: "operation_costs" */
  update_operation_costs_many?: Maybe<Array<Maybe<Operation_Costs_Mutation_Response>>>;
  /** update data of the table: "param_widgets" */
  update_param_widgets?: Maybe<Param_Widgets_Mutation_Response>;
  /** update single row of the table: "param_widgets" */
  update_param_widgets_by_pk?: Maybe<Param_Widgets>;
  /** update multiples rows of table: "param_widgets" */
  update_param_widgets_many?: Maybe<Array<Maybe<Param_Widgets_Mutation_Response>>>;
  /** update data of the table: "pending_api_user_subscription_updates" */
  update_pending_api_user_subscription_updates?: Maybe<Pending_Api_User_Subscription_Updates_Mutation_Response>;
  /** update single row of the table: "pending_api_user_subscription_updates" */
  update_pending_api_user_subscription_updates_by_pk?: Maybe<Pending_Api_User_Subscription_Updates>;
  /** update multiples rows of table: "pending_api_user_subscription_updates" */
  update_pending_api_user_subscription_updates_many?: Maybe<Array<Maybe<Pending_Api_User_Subscription_Updates_Mutation_Response>>>;
  /** update data of the table: "pending_team_subscription_updates" */
  update_pending_team_subscription_updates?: Maybe<Pending_Team_Subscription_Updates_Mutation_Response>;
  /** update single row of the table: "pending_team_subscription_updates" */
  update_pending_team_subscription_updates_by_pk?: Maybe<Pending_Team_Subscription_Updates>;
  /** update multiples rows of table: "pending_team_subscription_updates" */
  update_pending_team_subscription_updates_many?: Maybe<Array<Maybe<Pending_Team_Subscription_Updates_Mutation_Response>>>;
  /** update data of the table: "pending_user_subscription_updates" */
  update_pending_user_subscription_updates?: Maybe<Pending_User_Subscription_Updates_Mutation_Response>;
  /** update single row of the table: "pending_user_subscription_updates" */
  update_pending_user_subscription_updates_by_pk?: Maybe<Pending_User_Subscription_Updates>;
  /** update multiples rows of table: "pending_user_subscription_updates" */
  update_pending_user_subscription_updates_many?: Maybe<Array<Maybe<Pending_User_Subscription_Updates_Mutation_Response>>>;
  /** update data of the table: "pro_badge" */
  update_pro_badge?: Maybe<Pro_Badge_Mutation_Response>;
  /** update multiples rows of table: "pro_badge" */
  update_pro_badge_many?: Maybe<Array<Maybe<Pro_Badge_Mutation_Response>>>;
  /** update data of the table: "queries" */
  update_queries?: Maybe<Queries_Mutation_Response>;
  /** update single row of the table: "queries" */
  update_queries_by_pk?: Maybe<Queries>;
  /** update multiples rows of table: "queries" */
  update_queries_many?: Maybe<Array<Maybe<Queries_Mutation_Response>>>;
  update_query: UpdateQueryResponse;
  /** update data of the table: "query_errors" */
  update_query_errors?: Maybe<Query_Errors_Mutation_Response>;
  /** update single row of the table: "query_errors" */
  update_query_errors_by_pk?: Maybe<Query_Errors>;
  /** update multiples rows of table: "query_errors" */
  update_query_errors_many?: Maybe<Array<Maybe<Query_Errors_Mutation_Response>>>;
  /** update data of the table: "query_event_metadata" */
  update_query_event_metadata?: Maybe<Query_Event_Metadata_Mutation_Response>;
  /** update single row of the table: "query_event_metadata" */
  update_query_event_metadata_by_pk?: Maybe<Query_Event_Metadata>;
  /** update multiples rows of table: "query_event_metadata" */
  update_query_event_metadata_many?: Maybe<Array<Maybe<Query_Event_Metadata_Mutation_Response>>>;
  /** update data of the table: "query_event_types" */
  update_query_event_types?: Maybe<Query_Event_Types_Mutation_Response>;
  /** update single row of the table: "query_event_types" */
  update_query_event_types_by_pk?: Maybe<Query_Event_Types>;
  /** update multiples rows of table: "query_event_types" */
  update_query_event_types_many?: Maybe<Array<Maybe<Query_Event_Types_Mutation_Response>>>;
  /** update data of the table: "query_events" */
  update_query_events?: Maybe<Query_Events_Mutation_Response>;
  /** update single row of the table: "query_events" */
  update_query_events_by_pk?: Maybe<Query_Events>;
  /** update multiples rows of table: "query_events" */
  update_query_events_many?: Maybe<Array<Maybe<Query_Events_Mutation_Response>>>;
  /** update data of the table: "query_results" */
  update_query_results?: Maybe<Query_Results_Mutation_Response>;
  /** update single row of the table: "query_results" */
  update_query_results_by_pk?: Maybe<Query_Results>;
  /** update multiples rows of table: "query_results" */
  update_query_results_many?: Maybe<Array<Maybe<Query_Results_Mutation_Response>>>;
  update_query_schedule: UpdateQueryScheduleResponse;
  /** update_team_account_for_service_tier */
  update_team_account_for_service_tier?: Maybe<UpdateTeamAccountForServiceTierResponse>;
  /** update data of the table: "team_members_details" */
  update_team_members_details?: Maybe<Team_Members_Details_Mutation_Response>;
  /** update multiples rows of table: "team_members_details" */
  update_team_members_details_many?: Maybe<Array<Maybe<Team_Members_Details_Mutation_Response>>>;
  /** update data of the table: "team_service_tiers" */
  update_team_service_tiers?: Maybe<Team_Service_Tiers_Mutation_Response>;
  /** update single row of the table: "team_service_tiers" */
  update_team_service_tiers_by_pk?: Maybe<Team_Service_Tiers>;
  /** update multiples rows of table: "team_service_tiers" */
  update_team_service_tiers_many?: Maybe<Array<Maybe<Team_Service_Tiers_Mutation_Response>>>;
  /** update data of the table: "teams" */
  update_teams?: Maybe<Teams_Mutation_Response>;
  /** update single row of the table: "teams" */
  update_teams_by_pk?: Maybe<Teams>;
  /** update multiples rows of table: "teams" */
  update_teams_many?: Maybe<Array<Maybe<Teams_Mutation_Response>>>;
  /** update data of the table: "text_widgets" */
  update_text_widgets?: Maybe<Text_Widgets_Mutation_Response>;
  /** update single row of the table: "text_widgets" */
  update_text_widgets_by_pk?: Maybe<Text_Widgets>;
  /** update multiples rows of table: "text_widgets" */
  update_text_widgets_many?: Maybe<Array<Maybe<Text_Widgets_Mutation_Response>>>;
  /** update data of the table: "user_nonce" */
  update_user_nonce?: Maybe<User_Nonce_Mutation_Response>;
  /** update single row of the table: "user_nonce" */
  update_user_nonce_by_pk?: Maybe<User_Nonce>;
  /** update multiples rows of table: "user_nonce" */
  update_user_nonce_many?: Maybe<Array<Maybe<User_Nonce_Mutation_Response>>>;
  /** update data of the table: "user_private" */
  update_user_private?: Maybe<User_Private_Mutation_Response>;
  /** update multiples rows of table: "user_private" */
  update_user_private_many?: Maybe<Array<Maybe<User_Private_Mutation_Response>>>;
  /** update data of the table: "user_service_tiers" */
  update_user_service_tiers?: Maybe<User_Service_Tiers_Mutation_Response>;
  /** update single row of the table: "user_service_tiers" */
  update_user_service_tiers_by_pk?: Maybe<User_Service_Tiers>;
  /** update multiples rows of table: "user_service_tiers" */
  update_user_service_tiers_many?: Maybe<Array<Maybe<User_Service_Tiers_Mutation_Response>>>;
  /** update data of the table: "users" */
  update_users?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many?: Maybe<Array<Maybe<Users_Mutation_Response>>>;
  /** update data of the table: "visualization_widgets" */
  update_visualization_widgets?: Maybe<Visualization_Widgets_Mutation_Response>;
  /** update single row of the table: "visualization_widgets" */
  update_visualization_widgets_by_pk?: Maybe<Visualization_Widgets>;
  /** update multiples rows of table: "visualization_widgets" */
  update_visualization_widgets_many?: Maybe<Array<Maybe<Visualization_Widgets_Mutation_Response>>>;
  /** update data of the table: "visualizations" */
  update_visualizations?: Maybe<Visualizations_Mutation_Response>;
  /** update single row of the table: "visualizations" */
  update_visualizations_by_pk?: Maybe<Visualizations>;
  /** update multiples rows of table: "visualizations" */
  update_visualizations_many?: Maybe<Array<Maybe<Visualizations_Mutation_Response>>>;
  /** update data of the table: "wand_completions" */
  update_wand_completions?: Maybe<Wand_Completions_Mutation_Response>;
  /** update single row of the table: "wand_completions" */
  update_wand_completions_by_pk?: Maybe<Wand_Completions>;
  /** update multiples rows of table: "wand_completions" */
  update_wand_completions_many?: Maybe<Array<Maybe<Wand_Completions_Mutation_Response>>>;
  upgrade_api_user_subscription: UpgradeApiUserSubscriptionResponse;
  /** upgrade_team_subscription */
  upgrade_team_subscription: UpgradeTeamSubscriptionResponse;
  upgrade_user_subscription: UpgradeUserSubscriptionResponse;
  upsert_query_event_metadata: QueryEventMetadata;
  verify_email?: Maybe<VerifyEmailOutput>;
};


/** mutation root */
export type Mutation_RootAccept_InviteArgs = {
  membership_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootAccept_Invite_V2Args = {
  membership_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCancel_ExecutionArgs = {
  execution_id: Scalars['String'];
  parameters?: Maybe<Array<Parameter>>;
  query_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootCancel_Team_Pending_Subscription_ChangeArgs = {
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootChange_EmailArgs = {
  new_email: Scalars['String'];
};


/** mutation root */
export type Mutation_RootChange_PasswordArgs = {
  current_password: Scalars['String'];
  new_password: Scalars['String'];
};


/** mutation root */
export type Mutation_RootComplete_Nlq_ModelArgs = {
  model: Scalars['String'];
  prompt: Scalars['String'];
  table: Scalars['String'];
};


/** mutation root */
export type Mutation_RootComplete_Stripe_Checkout_SessionArgs = {
  checkout_session_id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootCreate_Dashboard_ScheduleArgs = {
  cron_expression: Scalars['String'];
  dashboard_id: Scalars['Int'];
  performance: Scalars['String'];
};


/** mutation root */
export type Mutation_RootCreate_FolderArgs = {
  folder: CreateFolderInput;
};


/** mutation root */
export type Mutation_RootCreate_Materialized_ViewArgs = {
  creator: ContextOwner;
  is_private: Scalars['Boolean'];
  name?: Maybe<Scalars['String']>;
  performance: Scalars['String'];
  query_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootCreate_QueryArgs = {
  query: CreateQueryInput;
};


/** mutation root */
export type Mutation_RootCreate_Query_ScheduleArgs = {
  cron_expression: Scalars['String'];
  performance: Scalars['String'];
  query_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootCreate_TeamArgs = {
  handle: Scalars['String'];
  name: Scalars['String'];
  profile_image_url?: Maybe<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootCreate_Team_Api_KeyArgs = {
  name: Scalars['String'];
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootCreate_Team_Checkout_SessionArgs = {
  redirect_path: Scalars['String'];
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootCreate_User_Api_KeyArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootCreate_User_Checkout_SessionArgs = {
  redirect_path?: Maybe<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootCreate_Wand_QueryArgs = {
  prompt: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDebug_Wand_QueryArgs = {
  error: Scalars['String'];
  query: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Api_KeysArgs = {
  where: Api_Keys_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Api_Keys_By_PkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Api_User_Service_TiersArgs = {
  where: Api_User_Service_Tiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Api_User_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Arrakis_SchemasArgs = {
  where: Arrakis_Schemas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arrakis_Schemas_By_PkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Blockchain_SchemasArgs = {
  where: Blockchain_Schemas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Blockchain_Schemas_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Contract_SubmissionsArgs = {
  where: Contract_Submissions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Contract_Submissions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Dashboard_ScheduleArgs = {
  cron_job_id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Dashboard_Trending_ScoresArgs = {
  where: Dashboard_Trending_Scores_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Dashboard_Trending_Scores_By_PkArgs = {
  dashboard_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_DashboardsArgs = {
  where: Dashboards_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Dashboards_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_DatasetsArgs = {
  where: Datasets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Datasets_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Favorite_DashboardsArgs = {
  where: Favorite_Dashboards_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Favorite_Dashboards_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Favorite_QueriesArgs = {
  where: Favorite_Queries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Favorite_Queries_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Favourited_SchemasArgs = {
  where: Favourited_Schemas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Favourited_Schemas_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Get_Result_TemplateArgs = {
  where: Get_Result_Template_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_JobsArgs = {
  where: Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_MembershipsArgs = {
  where: Memberships_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Memberships_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Memberships_Private_DetailsArgs = {
  where: Memberships_Private_Details_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Onboarding_QuestionsArgs = {
  where: Onboarding_Questions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Onboarding_Questions_By_PkArgs = {
  user_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Operation_CostsArgs = {
  where: Operation_Costs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Operation_Costs_By_PkArgs = {
  key: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Param_WidgetsArgs = {
  where: Param_Widgets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Param_Widgets_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Pending_Api_User_Subscription_UpdatesArgs = {
  where: Pending_Api_User_Subscription_Updates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Pending_Api_User_Subscription_Updates_By_PkArgs = {
  user_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Pending_Team_Subscription_UpdatesArgs = {
  where: Pending_Team_Subscription_Updates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Pending_Team_Subscription_Updates_By_PkArgs = {
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Pending_User_Subscription_UpdatesArgs = {
  where: Pending_User_Subscription_Updates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Pending_User_Subscription_Updates_By_PkArgs = {
  user_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Pro_BadgeArgs = {
  where: Pro_Badge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_QueriesArgs = {
  where: Queries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Queries_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Query_ErrorsArgs = {
  where: Query_Errors_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Query_Errors_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Query_Event_MetadataArgs = {
  where: Query_Event_Metadata_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Query_Event_Metadata_By_PkArgs = {
  query_event_id: Scalars['bpchar'];
};


/** mutation root */
export type Mutation_RootDelete_Query_Event_TypesArgs = {
  where: Query_Event_Types_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Query_Event_Types_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Query_EventsArgs = {
  where: Query_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Query_Events_By_PkArgs = {
  id: Scalars['bpchar'];
};


/** mutation root */
export type Mutation_RootDelete_Query_ResultsArgs = {
  where: Query_Results_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Query_Results_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Query_ScheduleArgs = {
  cron_job_id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_TeamArgs = {
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Team_Api_KeyArgs = {
  id: Scalars['String'];
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Team_Members_DetailsArgs = {
  where: Team_Members_Details_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Team_Service_TiersArgs = {
  where: Team_Service_Tiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Team_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_TeamsArgs = {
  where: Teams_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Teams_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Text_WidgetsArgs = {
  where: Text_Widgets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Text_Widgets_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_User_Api_KeyArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_User_NonceArgs = {
  where: User_Nonce_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Nonce_By_PkArgs = {
  ethereum_address: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_User_PrivateArgs = {
  where: User_Private_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Service_TiersArgs = {
  where: User_Service_Tiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Visualization_WidgetsArgs = {
  where: Visualization_Widgets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Visualization_Widgets_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_VisualizationsArgs = {
  where: Visualizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Visualizations_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Wand_CompletionsArgs = {
  where: Wand_Completions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Wand_Completions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDowngrade_Api_User_SubscriptionArgs = {
  service_tier_name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDowngrade_Team_SubscriptionArgs = {
  service_tier_name: Scalars['String'];
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDowngrade_User_SubscriptionArgs = {
  service_tier_name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootEdit_Wand_QueryArgs = {
  prompt: Scalars['String'];
  query: Scalars['String'];
};


/** mutation root */
export type Mutation_RootExecute_Query_V3Args = {
  executor: ContextOwner;
  parameters?: Maybe<Array<Parameter>>;
  performance?: Maybe<Scalars['String']>;
  query_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootFork_Dashboard_V2Args = {
  dashboard_id: Scalars['Int'];
  dashboard_name: Scalars['String'];
  dashboard_slug: Scalars['String'];
  forkTo: ContextOwner;
};


/** mutation root */
export type Mutation_RootFork_QueryArgs = {
  query_id: Scalars['Int'];
  user_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootFork_Query_V3Args = {
  forkTo: ContextOwner;
  query_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootGenerate_Data_Upload_UrlArgs = {
  content_length: Scalars['Int'];
  file_name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootGenerate_Upload_UrlArgs = {
  content_length: Scalars['Int'];
  file_type: Scalars['String'];
  upload_type: Scalars['String'];
};


/** mutation root */
export type Mutation_RootGet_Table_PreviewArgs = {
  table: Scalars['String'];
};


/** mutation root */
export type Mutation_RootInsert_Api_KeysArgs = {
  objects: Array<Api_Keys_Insert_Input>;
  on_conflict?: Maybe<Api_Keys_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Api_Keys_OneArgs = {
  object: Api_Keys_Insert_Input;
  on_conflict?: Maybe<Api_Keys_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Api_User_Service_TiersArgs = {
  objects: Array<Api_User_Service_Tiers_Insert_Input>;
  on_conflict?: Maybe<Api_User_Service_Tiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Api_User_Service_Tiers_OneArgs = {
  object: Api_User_Service_Tiers_Insert_Input;
  on_conflict?: Maybe<Api_User_Service_Tiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arrakis_SchemasArgs = {
  objects: Array<Arrakis_Schemas_Insert_Input>;
  on_conflict?: Maybe<Arrakis_Schemas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arrakis_Schemas_OneArgs = {
  object: Arrakis_Schemas_Insert_Input;
  on_conflict?: Maybe<Arrakis_Schemas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Blockchain_SchemasArgs = {
  objects: Array<Blockchain_Schemas_Insert_Input>;
  on_conflict?: Maybe<Blockchain_Schemas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Blockchain_Schemas_OneArgs = {
  object: Blockchain_Schemas_Insert_Input;
  on_conflict?: Maybe<Blockchain_Schemas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Contract_SubmissionsArgs = {
  objects: Array<Contract_Submissions_Insert_Input>;
  on_conflict?: Maybe<Contract_Submissions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Contract_Submissions_OneArgs = {
  object: Contract_Submissions_Insert_Input;
  on_conflict?: Maybe<Contract_Submissions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Dashboard_Trending_ScoresArgs = {
  objects: Array<Dashboard_Trending_Scores_Insert_Input>;
  on_conflict?: Maybe<Dashboard_Trending_Scores_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Dashboard_Trending_Scores_OneArgs = {
  object: Dashboard_Trending_Scores_Insert_Input;
  on_conflict?: Maybe<Dashboard_Trending_Scores_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DashboardsArgs = {
  objects: Array<Dashboards_Insert_Input>;
  on_conflict?: Maybe<Dashboards_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Dashboards_OneArgs = {
  object: Dashboards_Insert_Input;
  on_conflict?: Maybe<Dashboards_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DatasetsArgs = {
  objects: Array<Datasets_Insert_Input>;
  on_conflict?: Maybe<Datasets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Datasets_OneArgs = {
  object: Datasets_Insert_Input;
  on_conflict?: Maybe<Datasets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favorite_DashboardsArgs = {
  objects: Array<Favorite_Dashboards_Insert_Input>;
  on_conflict?: Maybe<Favorite_Dashboards_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favorite_Dashboards_OneArgs = {
  object: Favorite_Dashboards_Insert_Input;
  on_conflict?: Maybe<Favorite_Dashboards_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favorite_QueriesArgs = {
  objects: Array<Favorite_Queries_Insert_Input>;
  on_conflict?: Maybe<Favorite_Queries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favorite_Queries_OneArgs = {
  object: Favorite_Queries_Insert_Input;
  on_conflict?: Maybe<Favorite_Queries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favourited_SchemasArgs = {
  objects: Array<Favourited_Schemas_Insert_Input>;
  on_conflict?: Maybe<Favourited_Schemas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favourited_Schemas_OneArgs = {
  object: Favourited_Schemas_Insert_Input;
  on_conflict?: Maybe<Favourited_Schemas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Get_Result_TemplateArgs = {
  objects: Array<Get_Result_Template_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Get_Result_Template_OneArgs = {
  object: Get_Result_Template_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_JobsArgs = {
  objects: Array<Jobs_Insert_Input>;
  on_conflict?: Maybe<Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Jobs_OneArgs = {
  object: Jobs_Insert_Input;
  on_conflict?: Maybe<Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MembershipsArgs = {
  objects: Array<Memberships_Insert_Input>;
  on_conflict?: Maybe<Memberships_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Memberships_OneArgs = {
  object: Memberships_Insert_Input;
  on_conflict?: Maybe<Memberships_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Memberships_Private_DetailsArgs = {
  objects: Array<Memberships_Private_Details_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Memberships_Private_Details_OneArgs = {
  object: Memberships_Private_Details_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Onboarding_QuestionsArgs = {
  objects: Array<Onboarding_Questions_Insert_Input>;
  on_conflict?: Maybe<Onboarding_Questions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Onboarding_Questions_OneArgs = {
  object: Onboarding_Questions_Insert_Input;
  on_conflict?: Maybe<Onboarding_Questions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Operation_CostsArgs = {
  objects: Array<Operation_Costs_Insert_Input>;
  on_conflict?: Maybe<Operation_Costs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Operation_Costs_OneArgs = {
  object: Operation_Costs_Insert_Input;
  on_conflict?: Maybe<Operation_Costs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Param_WidgetsArgs = {
  objects: Array<Param_Widgets_Insert_Input>;
  on_conflict?: Maybe<Param_Widgets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Param_Widgets_OneArgs = {
  object: Param_Widgets_Insert_Input;
  on_conflict?: Maybe<Param_Widgets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pending_Api_User_Subscription_UpdatesArgs = {
  objects: Array<Pending_Api_User_Subscription_Updates_Insert_Input>;
  on_conflict?: Maybe<Pending_Api_User_Subscription_Updates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pending_Api_User_Subscription_Updates_OneArgs = {
  object: Pending_Api_User_Subscription_Updates_Insert_Input;
  on_conflict?: Maybe<Pending_Api_User_Subscription_Updates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pending_Team_Subscription_UpdatesArgs = {
  objects: Array<Pending_Team_Subscription_Updates_Insert_Input>;
  on_conflict?: Maybe<Pending_Team_Subscription_Updates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pending_Team_Subscription_Updates_OneArgs = {
  object: Pending_Team_Subscription_Updates_Insert_Input;
  on_conflict?: Maybe<Pending_Team_Subscription_Updates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pending_User_Subscription_UpdatesArgs = {
  objects: Array<Pending_User_Subscription_Updates_Insert_Input>;
  on_conflict?: Maybe<Pending_User_Subscription_Updates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pending_User_Subscription_Updates_OneArgs = {
  object: Pending_User_Subscription_Updates_Insert_Input;
  on_conflict?: Maybe<Pending_User_Subscription_Updates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pro_BadgeArgs = {
  objects: Array<Pro_Badge_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Pro_Badge_OneArgs = {
  object: Pro_Badge_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_QueriesArgs = {
  objects: Array<Queries_Insert_Input>;
  on_conflict?: Maybe<Queries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Queries_OneArgs = {
  object: Queries_Insert_Input;
  on_conflict?: Maybe<Queries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_ErrorsArgs = {
  objects: Array<Query_Errors_Insert_Input>;
  on_conflict?: Maybe<Query_Errors_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_Errors_OneArgs = {
  object: Query_Errors_Insert_Input;
  on_conflict?: Maybe<Query_Errors_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_Event_MetadataArgs = {
  objects: Array<Query_Event_Metadata_Insert_Input>;
  on_conflict?: Maybe<Query_Event_Metadata_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_Event_Metadata_OneArgs = {
  object: Query_Event_Metadata_Insert_Input;
  on_conflict?: Maybe<Query_Event_Metadata_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_Event_TypesArgs = {
  objects: Array<Query_Event_Types_Insert_Input>;
  on_conflict?: Maybe<Query_Event_Types_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_Event_Types_OneArgs = {
  object: Query_Event_Types_Insert_Input;
  on_conflict?: Maybe<Query_Event_Types_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_EventsArgs = {
  objects: Array<Query_Events_Insert_Input>;
  on_conflict?: Maybe<Query_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_Events_OneArgs = {
  object: Query_Events_Insert_Input;
  on_conflict?: Maybe<Query_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_ResultsArgs = {
  objects: Array<Query_Results_Insert_Input>;
  on_conflict?: Maybe<Query_Results_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Query_Results_OneArgs = {
  object: Query_Results_Insert_Input;
  on_conflict?: Maybe<Query_Results_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Team_Members_DetailsArgs = {
  objects: Array<Team_Members_Details_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Team_Members_Details_OneArgs = {
  object: Team_Members_Details_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Team_Service_TiersArgs = {
  objects: Array<Team_Service_Tiers_Insert_Input>;
  on_conflict?: Maybe<Team_Service_Tiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Team_Service_Tiers_OneArgs = {
  object: Team_Service_Tiers_Insert_Input;
  on_conflict?: Maybe<Team_Service_Tiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TeamsArgs = {
  objects: Array<Teams_Insert_Input>;
  on_conflict?: Maybe<Teams_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Teams_OneArgs = {
  object: Teams_Insert_Input;
  on_conflict?: Maybe<Teams_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Text_WidgetsArgs = {
  objects: Array<Text_Widgets_Insert_Input>;
  on_conflict?: Maybe<Text_Widgets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Text_Widgets_OneArgs = {
  object: Text_Widgets_Insert_Input;
  on_conflict?: Maybe<Text_Widgets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_NonceArgs = {
  objects: Array<User_Nonce_Insert_Input>;
  on_conflict?: Maybe<User_Nonce_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Nonce_OneArgs = {
  object: User_Nonce_Insert_Input;
  on_conflict?: Maybe<User_Nonce_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_PrivateArgs = {
  objects: Array<User_Private_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Private_OneArgs = {
  object: User_Private_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_Service_TiersArgs = {
  objects: Array<User_Service_Tiers_Insert_Input>;
  on_conflict?: Maybe<User_Service_Tiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Service_Tiers_OneArgs = {
  object: User_Service_Tiers_Insert_Input;
  on_conflict?: Maybe<User_Service_Tiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: Maybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict?: Maybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Visualization_WidgetsArgs = {
  objects: Array<Visualization_Widgets_Insert_Input>;
  on_conflict?: Maybe<Visualization_Widgets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Visualization_Widgets_OneArgs = {
  object: Visualization_Widgets_Insert_Input;
  on_conflict?: Maybe<Visualization_Widgets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VisualizationsArgs = {
  objects: Array<Visualizations_Insert_Input>;
  on_conflict?: Maybe<Visualizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Visualizations_OneArgs = {
  object: Visualizations_Insert_Input;
  on_conflict?: Maybe<Visualizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Wand_CompletionsArgs = {
  objects: Array<Wand_Completions_Insert_Input>;
  on_conflict?: Maybe<Wand_Completions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Wand_Completions_OneArgs = {
  object: Wand_Completions_Insert_Input;
  on_conflict?: Maybe<Wand_Completions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInvite_MemberArgs = {
  role: Scalars['String'];
  team_id: Scalars['Int'];
  user_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootInvite_Member_V2Args = {
  role: Scalars['String'];
  team_id: Scalars['Int'];
  usernameOrEmail: Scalars['String'];
};


/** mutation root */
export type Mutation_RootMigrate_ContentArgs = {
  redirect?: Maybe<Scalars['Boolean']>;
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootMigrate_Legacy_PlanArgs = {
  input: MigrateLegacyPlanInput;
};


/** mutation root */
export type Mutation_RootPatch_Dashboard_SettingsArgs = {
  dashboard_settings: DashboardSettings;
};


/** mutation root */
export type Mutation_RootPatch_Query_SettingsArgs = {
  query_settings: QuerySettings;
};


/** mutation root */
export type Mutation_RootRemove_MemberArgs = {
  membership_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootResend_InviteArgs = {
  membership_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootResend_Invite_V2Args = {
  membership_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootRestore_QueryArgs = {
  query_event_id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootSet_Max_Executions_Overage_Cost_CentsArgs = {
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
};


/** mutation root */
export type Mutation_RootSet_Max_Overage_CentsArgs = {
  max_overage_cents?: Maybe<Scalars['Int']>;
};


/** mutation root */
export type Mutation_RootSet_Team_Max_Executions_Overage_Cost_CentsArgs = {
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootSet_Team_Max_Overage_CentsArgs = {
  max_overage_cents?: Maybe<Scalars['Int']>;
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootTerminate_Api_User_SubscriptionArgs = {
  is_forced?: Maybe<Scalars['Boolean']>;
  subscription_id: Scalars['String'];
  user_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootTransfer_DashboardsArgs = {
  dashboard_ids: Array<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};


/** mutation root */
export type Mutation_RootTransfer_QueriesArgs = {
  query_ids: Array<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};


/** mutation root */
export type Mutation_RootUpdate_Account_For_Service_TierArgs = {
  service_tier_id: Scalars['Int'];
  user_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootUpdate_Api_KeysArgs = {
  _inc?: Maybe<Api_Keys_Inc_Input>;
  _set?: Maybe<Api_Keys_Set_Input>;
  where: Api_Keys_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Api_Keys_By_PkArgs = {
  _inc?: Maybe<Api_Keys_Inc_Input>;
  _set?: Maybe<Api_Keys_Set_Input>;
  pk_columns: Api_Keys_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Api_Keys_ManyArgs = {
  updates: Array<Api_Keys_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Api_User_Service_TiersArgs = {
  _inc?: Maybe<Api_User_Service_Tiers_Inc_Input>;
  _set?: Maybe<Api_User_Service_Tiers_Set_Input>;
  where: Api_User_Service_Tiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Api_User_Service_Tiers_By_PkArgs = {
  _inc?: Maybe<Api_User_Service_Tiers_Inc_Input>;
  _set?: Maybe<Api_User_Service_Tiers_Set_Input>;
  pk_columns: Api_User_Service_Tiers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Api_User_Service_Tiers_ManyArgs = {
  updates: Array<Api_User_Service_Tiers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Arrakis_SchemasArgs = {
  _append?: Maybe<Arrakis_Schemas_Append_Input>;
  _delete_at_path?: Maybe<Arrakis_Schemas_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Arrakis_Schemas_Delete_Elem_Input>;
  _delete_key?: Maybe<Arrakis_Schemas_Delete_Key_Input>;
  _inc?: Maybe<Arrakis_Schemas_Inc_Input>;
  _prepend?: Maybe<Arrakis_Schemas_Prepend_Input>;
  _set?: Maybe<Arrakis_Schemas_Set_Input>;
  where: Arrakis_Schemas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arrakis_Schemas_By_PkArgs = {
  _append?: Maybe<Arrakis_Schemas_Append_Input>;
  _delete_at_path?: Maybe<Arrakis_Schemas_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Arrakis_Schemas_Delete_Elem_Input>;
  _delete_key?: Maybe<Arrakis_Schemas_Delete_Key_Input>;
  _inc?: Maybe<Arrakis_Schemas_Inc_Input>;
  _prepend?: Maybe<Arrakis_Schemas_Prepend_Input>;
  _set?: Maybe<Arrakis_Schemas_Set_Input>;
  pk_columns: Arrakis_Schemas_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arrakis_Schemas_ManyArgs = {
  updates: Array<Arrakis_Schemas_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Blockchain_SchemasArgs = {
  _inc?: Maybe<Blockchain_Schemas_Inc_Input>;
  _set?: Maybe<Blockchain_Schemas_Set_Input>;
  where: Blockchain_Schemas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Blockchain_Schemas_By_PkArgs = {
  _inc?: Maybe<Blockchain_Schemas_Inc_Input>;
  _set?: Maybe<Blockchain_Schemas_Set_Input>;
  pk_columns: Blockchain_Schemas_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Blockchain_Schemas_ManyArgs = {
  updates: Array<Blockchain_Schemas_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Contract_SubmissionsArgs = {
  _append?: Maybe<Contract_Submissions_Append_Input>;
  _delete_at_path?: Maybe<Contract_Submissions_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Contract_Submissions_Delete_Elem_Input>;
  _delete_key?: Maybe<Contract_Submissions_Delete_Key_Input>;
  _prepend?: Maybe<Contract_Submissions_Prepend_Input>;
  _set?: Maybe<Contract_Submissions_Set_Input>;
  where: Contract_Submissions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Contract_Submissions_By_PkArgs = {
  _append?: Maybe<Contract_Submissions_Append_Input>;
  _delete_at_path?: Maybe<Contract_Submissions_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Contract_Submissions_Delete_Elem_Input>;
  _delete_key?: Maybe<Contract_Submissions_Delete_Key_Input>;
  _prepend?: Maybe<Contract_Submissions_Prepend_Input>;
  _set?: Maybe<Contract_Submissions_Set_Input>;
  pk_columns: Contract_Submissions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Contract_Submissions_ManyArgs = {
  updates: Array<Contract_Submissions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Dashboard_ScheduleArgs = {
  cron_expression: Scalars['String'];
  cron_job_id: Scalars['String'];
  performance: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdate_Dashboard_Trending_ScoresArgs = {
  _inc?: Maybe<Dashboard_Trending_Scores_Inc_Input>;
  _set?: Maybe<Dashboard_Trending_Scores_Set_Input>;
  where: Dashboard_Trending_Scores_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Dashboard_Trending_Scores_By_PkArgs = {
  _inc?: Maybe<Dashboard_Trending_Scores_Inc_Input>;
  _set?: Maybe<Dashboard_Trending_Scores_Set_Input>;
  pk_columns: Dashboard_Trending_Scores_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Dashboard_Trending_Scores_ManyArgs = {
  updates: Array<Dashboard_Trending_Scores_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DashboardsArgs = {
  _append?: Maybe<Dashboards_Append_Input>;
  _delete_at_path?: Maybe<Dashboards_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dashboards_Delete_Elem_Input>;
  _delete_key?: Maybe<Dashboards_Delete_Key_Input>;
  _inc?: Maybe<Dashboards_Inc_Input>;
  _prepend?: Maybe<Dashboards_Prepend_Input>;
  _set?: Maybe<Dashboards_Set_Input>;
  where: Dashboards_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Dashboards_By_PkArgs = {
  _append?: Maybe<Dashboards_Append_Input>;
  _delete_at_path?: Maybe<Dashboards_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dashboards_Delete_Elem_Input>;
  _delete_key?: Maybe<Dashboards_Delete_Key_Input>;
  _inc?: Maybe<Dashboards_Inc_Input>;
  _prepend?: Maybe<Dashboards_Prepend_Input>;
  _set?: Maybe<Dashboards_Set_Input>;
  pk_columns: Dashboards_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Dashboards_ManyArgs = {
  updates: Array<Dashboards_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DatasetsArgs = {
  _inc?: Maybe<Datasets_Inc_Input>;
  _set?: Maybe<Datasets_Set_Input>;
  where: Datasets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Datasets_By_PkArgs = {
  _inc?: Maybe<Datasets_Inc_Input>;
  _set?: Maybe<Datasets_Set_Input>;
  pk_columns: Datasets_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Datasets_ManyArgs = {
  updates: Array<Datasets_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Favorite_DashboardsArgs = {
  _inc?: Maybe<Favorite_Dashboards_Inc_Input>;
  _set?: Maybe<Favorite_Dashboards_Set_Input>;
  where: Favorite_Dashboards_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Favorite_Dashboards_By_PkArgs = {
  _inc?: Maybe<Favorite_Dashboards_Inc_Input>;
  _set?: Maybe<Favorite_Dashboards_Set_Input>;
  pk_columns: Favorite_Dashboards_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Favorite_Dashboards_ManyArgs = {
  updates: Array<Favorite_Dashboards_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Favorite_QueriesArgs = {
  _inc?: Maybe<Favorite_Queries_Inc_Input>;
  _set?: Maybe<Favorite_Queries_Set_Input>;
  where: Favorite_Queries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Favorite_Queries_By_PkArgs = {
  _inc?: Maybe<Favorite_Queries_Inc_Input>;
  _set?: Maybe<Favorite_Queries_Set_Input>;
  pk_columns: Favorite_Queries_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Favorite_Queries_ManyArgs = {
  updates: Array<Favorite_Queries_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Favourited_SchemasArgs = {
  _inc?: Maybe<Favourited_Schemas_Inc_Input>;
  _set?: Maybe<Favourited_Schemas_Set_Input>;
  where: Favourited_Schemas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Favourited_Schemas_By_PkArgs = {
  _inc?: Maybe<Favourited_Schemas_Inc_Input>;
  _set?: Maybe<Favourited_Schemas_Set_Input>;
  pk_columns: Favourited_Schemas_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Favourited_Schemas_ManyArgs = {
  updates: Array<Favourited_Schemas_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FolderArgs = {
  folder: UpdateFolderInput;
};


/** mutation root */
export type Mutation_RootUpdate_Get_Result_TemplateArgs = {
  _set?: Maybe<Get_Result_Template_Set_Input>;
  where: Get_Result_Template_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Get_Result_Template_ManyArgs = {
  updates: Array<Get_Result_Template_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_JobsArgs = {
  _append?: Maybe<Jobs_Append_Input>;
  _delete_at_path?: Maybe<Jobs_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Jobs_Delete_Elem_Input>;
  _delete_key?: Maybe<Jobs_Delete_Key_Input>;
  _inc?: Maybe<Jobs_Inc_Input>;
  _prepend?: Maybe<Jobs_Prepend_Input>;
  _set?: Maybe<Jobs_Set_Input>;
  where: Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Jobs_By_PkArgs = {
  _append?: Maybe<Jobs_Append_Input>;
  _delete_at_path?: Maybe<Jobs_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Jobs_Delete_Elem_Input>;
  _delete_key?: Maybe<Jobs_Delete_Key_Input>;
  _inc?: Maybe<Jobs_Inc_Input>;
  _prepend?: Maybe<Jobs_Prepend_Input>;
  _set?: Maybe<Jobs_Set_Input>;
  pk_columns: Jobs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Jobs_ManyArgs = {
  updates: Array<Jobs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_MembershipsArgs = {
  _inc?: Maybe<Memberships_Inc_Input>;
  _set?: Maybe<Memberships_Set_Input>;
  where: Memberships_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Memberships_By_PkArgs = {
  _inc?: Maybe<Memberships_Inc_Input>;
  _set?: Maybe<Memberships_Set_Input>;
  pk_columns: Memberships_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Memberships_ManyArgs = {
  updates: Array<Memberships_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Memberships_Private_DetailsArgs = {
  _inc?: Maybe<Memberships_Private_Details_Inc_Input>;
  _set?: Maybe<Memberships_Private_Details_Set_Input>;
  where: Memberships_Private_Details_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Memberships_Private_Details_ManyArgs = {
  updates: Array<Memberships_Private_Details_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Onboarding_QuestionsArgs = {
  _inc?: Maybe<Onboarding_Questions_Inc_Input>;
  _set?: Maybe<Onboarding_Questions_Set_Input>;
  where: Onboarding_Questions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Onboarding_Questions_By_PkArgs = {
  _inc?: Maybe<Onboarding_Questions_Inc_Input>;
  _set?: Maybe<Onboarding_Questions_Set_Input>;
  pk_columns: Onboarding_Questions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Onboarding_Questions_ManyArgs = {
  updates: Array<Onboarding_Questions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Operation_CostsArgs = {
  _append?: Maybe<Operation_Costs_Append_Input>;
  _delete_at_path?: Maybe<Operation_Costs_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Operation_Costs_Delete_Elem_Input>;
  _delete_key?: Maybe<Operation_Costs_Delete_Key_Input>;
  _prepend?: Maybe<Operation_Costs_Prepend_Input>;
  _set?: Maybe<Operation_Costs_Set_Input>;
  where: Operation_Costs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Operation_Costs_By_PkArgs = {
  _append?: Maybe<Operation_Costs_Append_Input>;
  _delete_at_path?: Maybe<Operation_Costs_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Operation_Costs_Delete_Elem_Input>;
  _delete_key?: Maybe<Operation_Costs_Delete_Key_Input>;
  _prepend?: Maybe<Operation_Costs_Prepend_Input>;
  _set?: Maybe<Operation_Costs_Set_Input>;
  pk_columns: Operation_Costs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Operation_Costs_ManyArgs = {
  updates: Array<Operation_Costs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Param_WidgetsArgs = {
  _append?: Maybe<Param_Widgets_Append_Input>;
  _delete_at_path?: Maybe<Param_Widgets_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Param_Widgets_Delete_Elem_Input>;
  _delete_key?: Maybe<Param_Widgets_Delete_Key_Input>;
  _inc?: Maybe<Param_Widgets_Inc_Input>;
  _prepend?: Maybe<Param_Widgets_Prepend_Input>;
  _set?: Maybe<Param_Widgets_Set_Input>;
  where: Param_Widgets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Param_Widgets_By_PkArgs = {
  _append?: Maybe<Param_Widgets_Append_Input>;
  _delete_at_path?: Maybe<Param_Widgets_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Param_Widgets_Delete_Elem_Input>;
  _delete_key?: Maybe<Param_Widgets_Delete_Key_Input>;
  _inc?: Maybe<Param_Widgets_Inc_Input>;
  _prepend?: Maybe<Param_Widgets_Prepend_Input>;
  _set?: Maybe<Param_Widgets_Set_Input>;
  pk_columns: Param_Widgets_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Param_Widgets_ManyArgs = {
  updates: Array<Param_Widgets_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_Api_User_Subscription_UpdatesArgs = {
  _inc?: Maybe<Pending_Api_User_Subscription_Updates_Inc_Input>;
  _set?: Maybe<Pending_Api_User_Subscription_Updates_Set_Input>;
  where: Pending_Api_User_Subscription_Updates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_Api_User_Subscription_Updates_By_PkArgs = {
  _inc?: Maybe<Pending_Api_User_Subscription_Updates_Inc_Input>;
  _set?: Maybe<Pending_Api_User_Subscription_Updates_Set_Input>;
  pk_columns: Pending_Api_User_Subscription_Updates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_Api_User_Subscription_Updates_ManyArgs = {
  updates: Array<Pending_Api_User_Subscription_Updates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_Team_Subscription_UpdatesArgs = {
  _append?: Maybe<Pending_Team_Subscription_Updates_Append_Input>;
  _delete_at_path?: Maybe<Pending_Team_Subscription_Updates_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Pending_Team_Subscription_Updates_Delete_Elem_Input>;
  _delete_key?: Maybe<Pending_Team_Subscription_Updates_Delete_Key_Input>;
  _inc?: Maybe<Pending_Team_Subscription_Updates_Inc_Input>;
  _prepend?: Maybe<Pending_Team_Subscription_Updates_Prepend_Input>;
  _set?: Maybe<Pending_Team_Subscription_Updates_Set_Input>;
  where: Pending_Team_Subscription_Updates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_Team_Subscription_Updates_By_PkArgs = {
  _append?: Maybe<Pending_Team_Subscription_Updates_Append_Input>;
  _delete_at_path?: Maybe<Pending_Team_Subscription_Updates_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Pending_Team_Subscription_Updates_Delete_Elem_Input>;
  _delete_key?: Maybe<Pending_Team_Subscription_Updates_Delete_Key_Input>;
  _inc?: Maybe<Pending_Team_Subscription_Updates_Inc_Input>;
  _prepend?: Maybe<Pending_Team_Subscription_Updates_Prepend_Input>;
  _set?: Maybe<Pending_Team_Subscription_Updates_Set_Input>;
  pk_columns: Pending_Team_Subscription_Updates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_Team_Subscription_Updates_ManyArgs = {
  updates: Array<Pending_Team_Subscription_Updates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_User_Subscription_UpdatesArgs = {
  _append?: Maybe<Pending_User_Subscription_Updates_Append_Input>;
  _delete_at_path?: Maybe<Pending_User_Subscription_Updates_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Pending_User_Subscription_Updates_Delete_Elem_Input>;
  _delete_key?: Maybe<Pending_User_Subscription_Updates_Delete_Key_Input>;
  _inc?: Maybe<Pending_User_Subscription_Updates_Inc_Input>;
  _prepend?: Maybe<Pending_User_Subscription_Updates_Prepend_Input>;
  _set?: Maybe<Pending_User_Subscription_Updates_Set_Input>;
  where: Pending_User_Subscription_Updates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_User_Subscription_Updates_By_PkArgs = {
  _append?: Maybe<Pending_User_Subscription_Updates_Append_Input>;
  _delete_at_path?: Maybe<Pending_User_Subscription_Updates_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Pending_User_Subscription_Updates_Delete_Elem_Input>;
  _delete_key?: Maybe<Pending_User_Subscription_Updates_Delete_Key_Input>;
  _inc?: Maybe<Pending_User_Subscription_Updates_Inc_Input>;
  _prepend?: Maybe<Pending_User_Subscription_Updates_Prepend_Input>;
  _set?: Maybe<Pending_User_Subscription_Updates_Set_Input>;
  pk_columns: Pending_User_Subscription_Updates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Pending_User_Subscription_Updates_ManyArgs = {
  updates: Array<Pending_User_Subscription_Updates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Pro_BadgeArgs = {
  _inc?: Maybe<Pro_Badge_Inc_Input>;
  _set?: Maybe<Pro_Badge_Set_Input>;
  where: Pro_Badge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pro_Badge_ManyArgs = {
  updates: Array<Pro_Badge_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_QueriesArgs = {
  _append?: Maybe<Queries_Append_Input>;
  _delete_at_path?: Maybe<Queries_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Queries_Delete_Elem_Input>;
  _delete_key?: Maybe<Queries_Delete_Key_Input>;
  _inc?: Maybe<Queries_Inc_Input>;
  _prepend?: Maybe<Queries_Prepend_Input>;
  _set?: Maybe<Queries_Set_Input>;
  where: Queries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Queries_By_PkArgs = {
  _append?: Maybe<Queries_Append_Input>;
  _delete_at_path?: Maybe<Queries_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Queries_Delete_Elem_Input>;
  _delete_key?: Maybe<Queries_Delete_Key_Input>;
  _inc?: Maybe<Queries_Inc_Input>;
  _prepend?: Maybe<Queries_Prepend_Input>;
  _set?: Maybe<Queries_Set_Input>;
  pk_columns: Queries_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Queries_ManyArgs = {
  updates: Array<Queries_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_QueryArgs = {
  query: UpdateQueryInput;
};


/** mutation root */
export type Mutation_RootUpdate_Query_ErrorsArgs = {
  _append?: Maybe<Query_Errors_Append_Input>;
  _delete_at_path?: Maybe<Query_Errors_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Query_Errors_Delete_Elem_Input>;
  _delete_key?: Maybe<Query_Errors_Delete_Key_Input>;
  _inc?: Maybe<Query_Errors_Inc_Input>;
  _prepend?: Maybe<Query_Errors_Prepend_Input>;
  _set?: Maybe<Query_Errors_Set_Input>;
  where: Query_Errors_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Errors_By_PkArgs = {
  _append?: Maybe<Query_Errors_Append_Input>;
  _delete_at_path?: Maybe<Query_Errors_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Query_Errors_Delete_Elem_Input>;
  _delete_key?: Maybe<Query_Errors_Delete_Key_Input>;
  _inc?: Maybe<Query_Errors_Inc_Input>;
  _prepend?: Maybe<Query_Errors_Prepend_Input>;
  _set?: Maybe<Query_Errors_Set_Input>;
  pk_columns: Query_Errors_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Errors_ManyArgs = {
  updates: Array<Query_Errors_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Event_MetadataArgs = {
  _inc?: Maybe<Query_Event_Metadata_Inc_Input>;
  _set?: Maybe<Query_Event_Metadata_Set_Input>;
  where: Query_Event_Metadata_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Event_Metadata_By_PkArgs = {
  _inc?: Maybe<Query_Event_Metadata_Inc_Input>;
  _set?: Maybe<Query_Event_Metadata_Set_Input>;
  pk_columns: Query_Event_Metadata_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Event_Metadata_ManyArgs = {
  updates: Array<Query_Event_Metadata_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Event_TypesArgs = {
  _set?: Maybe<Query_Event_Types_Set_Input>;
  where: Query_Event_Types_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Event_Types_By_PkArgs = {
  _set?: Maybe<Query_Event_Types_Set_Input>;
  pk_columns: Query_Event_Types_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Event_Types_ManyArgs = {
  updates: Array<Query_Event_Types_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Query_EventsArgs = {
  _append?: Maybe<Query_Events_Append_Input>;
  _delete_at_path?: Maybe<Query_Events_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Query_Events_Delete_Elem_Input>;
  _delete_key?: Maybe<Query_Events_Delete_Key_Input>;
  _inc?: Maybe<Query_Events_Inc_Input>;
  _prepend?: Maybe<Query_Events_Prepend_Input>;
  _set?: Maybe<Query_Events_Set_Input>;
  where: Query_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Events_By_PkArgs = {
  _append?: Maybe<Query_Events_Append_Input>;
  _delete_at_path?: Maybe<Query_Events_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Query_Events_Delete_Elem_Input>;
  _delete_key?: Maybe<Query_Events_Delete_Key_Input>;
  _inc?: Maybe<Query_Events_Inc_Input>;
  _prepend?: Maybe<Query_Events_Prepend_Input>;
  _set?: Maybe<Query_Events_Set_Input>;
  pk_columns: Query_Events_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Events_ManyArgs = {
  updates: Array<Query_Events_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Query_ResultsArgs = {
  _append?: Maybe<Query_Results_Append_Input>;
  _delete_at_path?: Maybe<Query_Results_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Query_Results_Delete_Elem_Input>;
  _delete_key?: Maybe<Query_Results_Delete_Key_Input>;
  _inc?: Maybe<Query_Results_Inc_Input>;
  _prepend?: Maybe<Query_Results_Prepend_Input>;
  _set?: Maybe<Query_Results_Set_Input>;
  where: Query_Results_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Results_By_PkArgs = {
  _append?: Maybe<Query_Results_Append_Input>;
  _delete_at_path?: Maybe<Query_Results_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Query_Results_Delete_Elem_Input>;
  _delete_key?: Maybe<Query_Results_Delete_Key_Input>;
  _inc?: Maybe<Query_Results_Inc_Input>;
  _prepend?: Maybe<Query_Results_Prepend_Input>;
  _set?: Maybe<Query_Results_Set_Input>;
  pk_columns: Query_Results_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Query_Results_ManyArgs = {
  updates: Array<Query_Results_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Query_ScheduleArgs = {
  cron_expression: Scalars['String'];
  cron_job_id: Scalars['String'];
  performance: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdate_Team_Account_For_Service_TierArgs = {
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootUpdate_Team_Members_DetailsArgs = {
  _append?: Maybe<Team_Members_Details_Append_Input>;
  _delete_at_path?: Maybe<Team_Members_Details_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Team_Members_Details_Delete_Elem_Input>;
  _delete_key?: Maybe<Team_Members_Details_Delete_Key_Input>;
  _inc?: Maybe<Team_Members_Details_Inc_Input>;
  _prepend?: Maybe<Team_Members_Details_Prepend_Input>;
  _set?: Maybe<Team_Members_Details_Set_Input>;
  where: Team_Members_Details_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Team_Members_Details_ManyArgs = {
  updates: Array<Team_Members_Details_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Team_Service_TiersArgs = {
  _inc?: Maybe<Team_Service_Tiers_Inc_Input>;
  _set?: Maybe<Team_Service_Tiers_Set_Input>;
  where: Team_Service_Tiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Team_Service_Tiers_By_PkArgs = {
  _inc?: Maybe<Team_Service_Tiers_Inc_Input>;
  _set?: Maybe<Team_Service_Tiers_Set_Input>;
  pk_columns: Team_Service_Tiers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Team_Service_Tiers_ManyArgs = {
  updates: Array<Team_Service_Tiers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TeamsArgs = {
  _append?: Maybe<Teams_Append_Input>;
  _delete_at_path?: Maybe<Teams_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Teams_Delete_Elem_Input>;
  _delete_key?: Maybe<Teams_Delete_Key_Input>;
  _inc?: Maybe<Teams_Inc_Input>;
  _prepend?: Maybe<Teams_Prepend_Input>;
  _set?: Maybe<Teams_Set_Input>;
  where: Teams_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Teams_By_PkArgs = {
  _append?: Maybe<Teams_Append_Input>;
  _delete_at_path?: Maybe<Teams_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Teams_Delete_Elem_Input>;
  _delete_key?: Maybe<Teams_Delete_Key_Input>;
  _inc?: Maybe<Teams_Inc_Input>;
  _prepend?: Maybe<Teams_Prepend_Input>;
  _set?: Maybe<Teams_Set_Input>;
  pk_columns: Teams_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Teams_ManyArgs = {
  updates: Array<Teams_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Text_WidgetsArgs = {
  _append?: Maybe<Text_Widgets_Append_Input>;
  _delete_at_path?: Maybe<Text_Widgets_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Text_Widgets_Delete_Elem_Input>;
  _delete_key?: Maybe<Text_Widgets_Delete_Key_Input>;
  _inc?: Maybe<Text_Widgets_Inc_Input>;
  _prepend?: Maybe<Text_Widgets_Prepend_Input>;
  _set?: Maybe<Text_Widgets_Set_Input>;
  where: Text_Widgets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Text_Widgets_By_PkArgs = {
  _append?: Maybe<Text_Widgets_Append_Input>;
  _delete_at_path?: Maybe<Text_Widgets_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Text_Widgets_Delete_Elem_Input>;
  _delete_key?: Maybe<Text_Widgets_Delete_Key_Input>;
  _inc?: Maybe<Text_Widgets_Inc_Input>;
  _prepend?: Maybe<Text_Widgets_Prepend_Input>;
  _set?: Maybe<Text_Widgets_Set_Input>;
  pk_columns: Text_Widgets_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Text_Widgets_ManyArgs = {
  updates: Array<Text_Widgets_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_NonceArgs = {
  _set?: Maybe<User_Nonce_Set_Input>;
  where: User_Nonce_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Nonce_By_PkArgs = {
  _set?: Maybe<User_Nonce_Set_Input>;
  pk_columns: User_Nonce_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Nonce_ManyArgs = {
  updates: Array<User_Nonce_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_PrivateArgs = {
  _append?: Maybe<User_Private_Append_Input>;
  _delete_at_path?: Maybe<User_Private_Delete_At_Path_Input>;
  _delete_elem?: Maybe<User_Private_Delete_Elem_Input>;
  _delete_key?: Maybe<User_Private_Delete_Key_Input>;
  _inc?: Maybe<User_Private_Inc_Input>;
  _prepend?: Maybe<User_Private_Prepend_Input>;
  _set?: Maybe<User_Private_Set_Input>;
  where: User_Private_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Private_ManyArgs = {
  updates: Array<User_Private_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Service_TiersArgs = {
  _inc?: Maybe<User_Service_Tiers_Inc_Input>;
  _set?: Maybe<User_Service_Tiers_Set_Input>;
  where: User_Service_Tiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Service_Tiers_By_PkArgs = {
  _inc?: Maybe<User_Service_Tiers_Inc_Input>;
  _set?: Maybe<User_Service_Tiers_Set_Input>;
  pk_columns: User_Service_Tiers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Service_Tiers_ManyArgs = {
  updates: Array<User_Service_Tiers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _append?: Maybe<Users_Append_Input>;
  _delete_at_path?: Maybe<Users_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Users_Delete_Elem_Input>;
  _delete_key?: Maybe<Users_Delete_Key_Input>;
  _inc?: Maybe<Users_Inc_Input>;
  _prepend?: Maybe<Users_Prepend_Input>;
  _set?: Maybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _append?: Maybe<Users_Append_Input>;
  _delete_at_path?: Maybe<Users_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Users_Delete_Elem_Input>;
  _delete_key?: Maybe<Users_Delete_Key_Input>;
  _inc?: Maybe<Users_Inc_Input>;
  _prepend?: Maybe<Users_Prepend_Input>;
  _set?: Maybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Visualization_WidgetsArgs = {
  _append?: Maybe<Visualization_Widgets_Append_Input>;
  _delete_at_path?: Maybe<Visualization_Widgets_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Visualization_Widgets_Delete_Elem_Input>;
  _delete_key?: Maybe<Visualization_Widgets_Delete_Key_Input>;
  _inc?: Maybe<Visualization_Widgets_Inc_Input>;
  _prepend?: Maybe<Visualization_Widgets_Prepend_Input>;
  _set?: Maybe<Visualization_Widgets_Set_Input>;
  where: Visualization_Widgets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Visualization_Widgets_By_PkArgs = {
  _append?: Maybe<Visualization_Widgets_Append_Input>;
  _delete_at_path?: Maybe<Visualization_Widgets_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Visualization_Widgets_Delete_Elem_Input>;
  _delete_key?: Maybe<Visualization_Widgets_Delete_Key_Input>;
  _inc?: Maybe<Visualization_Widgets_Inc_Input>;
  _prepend?: Maybe<Visualization_Widgets_Prepend_Input>;
  _set?: Maybe<Visualization_Widgets_Set_Input>;
  pk_columns: Visualization_Widgets_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Visualization_Widgets_ManyArgs = {
  updates: Array<Visualization_Widgets_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_VisualizationsArgs = {
  _append?: Maybe<Visualizations_Append_Input>;
  _delete_at_path?: Maybe<Visualizations_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Visualizations_Delete_Elem_Input>;
  _delete_key?: Maybe<Visualizations_Delete_Key_Input>;
  _inc?: Maybe<Visualizations_Inc_Input>;
  _prepend?: Maybe<Visualizations_Prepend_Input>;
  _set?: Maybe<Visualizations_Set_Input>;
  where: Visualizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Visualizations_By_PkArgs = {
  _append?: Maybe<Visualizations_Append_Input>;
  _delete_at_path?: Maybe<Visualizations_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Visualizations_Delete_Elem_Input>;
  _delete_key?: Maybe<Visualizations_Delete_Key_Input>;
  _inc?: Maybe<Visualizations_Inc_Input>;
  _prepend?: Maybe<Visualizations_Prepend_Input>;
  _set?: Maybe<Visualizations_Set_Input>;
  pk_columns: Visualizations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Visualizations_ManyArgs = {
  updates: Array<Visualizations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Wand_CompletionsArgs = {
  _inc?: Maybe<Wand_Completions_Inc_Input>;
  _set?: Maybe<Wand_Completions_Set_Input>;
  where: Wand_Completions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Wand_Completions_By_PkArgs = {
  _inc?: Maybe<Wand_Completions_Inc_Input>;
  _set?: Maybe<Wand_Completions_Set_Input>;
  pk_columns: Wand_Completions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Wand_Completions_ManyArgs = {
  updates: Array<Wand_Completions_Updates>;
};


/** mutation root */
export type Mutation_RootUpgrade_Api_User_SubscriptionArgs = {
  service_tier_name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpgrade_Team_SubscriptionArgs = {
  service_tier_name: Scalars['String'];
  team_id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootUpgrade_User_SubscriptionArgs = {
  service_tier_name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpsert_Query_Event_MetadataArgs = {
  metadata: UpsertQueryEventMetadataInput;
  query_event_id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootVerify_EmailArgs = {
  code: Scalars['String'];
};


/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: Maybe<Scalars['numeric']>;
  _gt?: Maybe<Scalars['numeric']>;
  _gte?: Maybe<Scalars['numeric']>;
  _in?: Maybe<Array<Scalars['numeric']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['numeric']>;
  _lte?: Maybe<Scalars['numeric']>;
  _neq?: Maybe<Scalars['numeric']>;
  _nin?: Maybe<Array<Scalars['numeric']>>;
};

/** columns and relationships of "onboarding_questions" */
export type Onboarding_Questions = {
  __typename?: 'onboarding_questions';
  achieve_with_dune: Scalars['String'];
  blockchain_experience: Scalars['String'];
  brings_to_dune: Scalars['String'];
  created_at: Scalars['timestamptz'];
  organization_size?: Maybe<Scalars['String']>;
  sql_experience?: Maybe<Scalars['String']>;
  /** An object relationship */
  user: Users;
  user_id: Scalars['Int'];
  version: Scalars['String'];
};

/** aggregated selection of "onboarding_questions" */
export type Onboarding_Questions_Aggregate = {
  __typename?: 'onboarding_questions_aggregate';
  aggregate?: Maybe<Onboarding_Questions_Aggregate_Fields>;
  nodes: Array<Onboarding_Questions>;
};

/** aggregate fields of "onboarding_questions" */
export type Onboarding_Questions_Aggregate_Fields = {
  __typename?: 'onboarding_questions_aggregate_fields';
  avg?: Maybe<Onboarding_Questions_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Onboarding_Questions_Max_Fields>;
  min?: Maybe<Onboarding_Questions_Min_Fields>;
  stddev?: Maybe<Onboarding_Questions_Stddev_Fields>;
  stddev_pop?: Maybe<Onboarding_Questions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Onboarding_Questions_Stddev_Samp_Fields>;
  sum?: Maybe<Onboarding_Questions_Sum_Fields>;
  var_pop?: Maybe<Onboarding_Questions_Var_Pop_Fields>;
  var_samp?: Maybe<Onboarding_Questions_Var_Samp_Fields>;
  variance?: Maybe<Onboarding_Questions_Variance_Fields>;
};


/** aggregate fields of "onboarding_questions" */
export type Onboarding_Questions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Onboarding_Questions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Onboarding_Questions_Avg_Fields = {
  __typename?: 'onboarding_questions_avg_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "onboarding_questions". All fields are combined with a logical 'AND'. */
export type Onboarding_Questions_Bool_Exp = {
  _and?: Maybe<Array<Onboarding_Questions_Bool_Exp>>;
  _not?: Maybe<Onboarding_Questions_Bool_Exp>;
  _or?: Maybe<Array<Onboarding_Questions_Bool_Exp>>;
  achieve_with_dune?: Maybe<String_Comparison_Exp>;
  blockchain_experience?: Maybe<String_Comparison_Exp>;
  brings_to_dune?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  organization_size?: Maybe<String_Comparison_Exp>;
  sql_experience?: Maybe<String_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
  version?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "onboarding_questions" */
export enum Onboarding_Questions_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  OnboardingQuestionsPkey = 'onboarding_questions_pkey'
}

/** input type for incrementing numeric columns in table "onboarding_questions" */
export type Onboarding_Questions_Inc_Input = {
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "onboarding_questions" */
export type Onboarding_Questions_Insert_Input = {
  achieve_with_dune?: Maybe<Scalars['String']>;
  blockchain_experience?: Maybe<Scalars['String']>;
  brings_to_dune?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  organization_size?: Maybe<Scalars['String']>;
  sql_experience?: Maybe<Scalars['String']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Onboarding_Questions_Max_Fields = {
  __typename?: 'onboarding_questions_max_fields';
  achieve_with_dune?: Maybe<Scalars['String']>;
  blockchain_experience?: Maybe<Scalars['String']>;
  brings_to_dune?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  organization_size?: Maybe<Scalars['String']>;
  sql_experience?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Onboarding_Questions_Min_Fields = {
  __typename?: 'onboarding_questions_min_fields';
  achieve_with_dune?: Maybe<Scalars['String']>;
  blockchain_experience?: Maybe<Scalars['String']>;
  brings_to_dune?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  organization_size?: Maybe<Scalars['String']>;
  sql_experience?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "onboarding_questions" */
export type Onboarding_Questions_Mutation_Response = {
  __typename?: 'onboarding_questions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Onboarding_Questions>;
};

/** on_conflict condition type for table "onboarding_questions" */
export type Onboarding_Questions_On_Conflict = {
  constraint: Onboarding_Questions_Constraint;
  update_columns: Array<Onboarding_Questions_Update_Column>;
  where?: Maybe<Onboarding_Questions_Bool_Exp>;
};

/** Ordering options when selecting data from "onboarding_questions". */
export type Onboarding_Questions_Order_By = {
  achieve_with_dune?: Maybe<Order_By>;
  blockchain_experience?: Maybe<Order_By>;
  brings_to_dune?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  organization_size?: Maybe<Order_By>;
  sql_experience?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** primary key columns input for table: onboarding_questions */
export type Onboarding_Questions_Pk_Columns_Input = {
  user_id: Scalars['Int'];
};

/** select columns of table "onboarding_questions" */
export enum Onboarding_Questions_Select_Column {
  /** column name */
  AchieveWithDune = 'achieve_with_dune',
  /** column name */
  BlockchainExperience = 'blockchain_experience',
  /** column name */
  BringsToDune = 'brings_to_dune',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  OrganizationSize = 'organization_size',
  /** column name */
  SqlExperience = 'sql_experience',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "onboarding_questions" */
export type Onboarding_Questions_Set_Input = {
  achieve_with_dune?: Maybe<Scalars['String']>;
  blockchain_experience?: Maybe<Scalars['String']>;
  brings_to_dune?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  organization_size?: Maybe<Scalars['String']>;
  sql_experience?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Onboarding_Questions_Stddev_Fields = {
  __typename?: 'onboarding_questions_stddev_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Onboarding_Questions_Stddev_Pop_Fields = {
  __typename?: 'onboarding_questions_stddev_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Onboarding_Questions_Stddev_Samp_Fields = {
  __typename?: 'onboarding_questions_stddev_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "onboarding_questions" */
export type Onboarding_Questions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Onboarding_Questions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Onboarding_Questions_Stream_Cursor_Value_Input = {
  achieve_with_dune?: Maybe<Scalars['String']>;
  blockchain_experience?: Maybe<Scalars['String']>;
  brings_to_dune?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  organization_size?: Maybe<Scalars['String']>;
  sql_experience?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Onboarding_Questions_Sum_Fields = {
  __typename?: 'onboarding_questions_sum_fields';
  user_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "onboarding_questions" */
export enum Onboarding_Questions_Update_Column {
  /** column name */
  AchieveWithDune = 'achieve_with_dune',
  /** column name */
  BlockchainExperience = 'blockchain_experience',
  /** column name */
  BringsToDune = 'brings_to_dune',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  OrganizationSize = 'organization_size',
  /** column name */
  SqlExperience = 'sql_experience',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

export type Onboarding_Questions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Onboarding_Questions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Onboarding_Questions_Set_Input>;
  where: Onboarding_Questions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Onboarding_Questions_Var_Pop_Fields = {
  __typename?: 'onboarding_questions_var_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Onboarding_Questions_Var_Samp_Fields = {
  __typename?: 'onboarding_questions_var_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Onboarding_Questions_Variance_Fields = {
  __typename?: 'onboarding_questions_variance_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "operation_costs" */
export type Operation_Costs = {
  __typename?: 'operation_costs';
  created_at: Scalars['timestamptz'];
  data: Scalars['jsonb'];
  key: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "operation_costs" */
export type Operation_CostsDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "operation_costs" */
export type Operation_Costs_Aggregate = {
  __typename?: 'operation_costs_aggregate';
  aggregate?: Maybe<Operation_Costs_Aggregate_Fields>;
  nodes: Array<Operation_Costs>;
};

/** aggregate fields of "operation_costs" */
export type Operation_Costs_Aggregate_Fields = {
  __typename?: 'operation_costs_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Operation_Costs_Max_Fields>;
  min?: Maybe<Operation_Costs_Min_Fields>;
};


/** aggregate fields of "operation_costs" */
export type Operation_Costs_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Operation_Costs_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Operation_Costs_Append_Input = {
  data?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "operation_costs". All fields are combined with a logical 'AND'. */
export type Operation_Costs_Bool_Exp = {
  _and?: Maybe<Array<Operation_Costs_Bool_Exp>>;
  _not?: Maybe<Operation_Costs_Bool_Exp>;
  _or?: Maybe<Array<Operation_Costs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  data?: Maybe<Jsonb_Comparison_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "operation_costs" */
export enum Operation_Costs_Constraint {
  /** unique or primary key constraint on columns "key" */
  OperationCostsPkey = 'operation_costs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Operation_Costs_Delete_At_Path_Input = {
  data?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Operation_Costs_Delete_Elem_Input = {
  data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Operation_Costs_Delete_Key_Input = {
  data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "operation_costs" */
export type Operation_Costs_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  data?: Maybe<Scalars['jsonb']>;
  key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Operation_Costs_Max_Fields = {
  __typename?: 'operation_costs_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Operation_Costs_Min_Fields = {
  __typename?: 'operation_costs_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "operation_costs" */
export type Operation_Costs_Mutation_Response = {
  __typename?: 'operation_costs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Operation_Costs>;
};

/** on_conflict condition type for table "operation_costs" */
export type Operation_Costs_On_Conflict = {
  constraint: Operation_Costs_Constraint;
  update_columns: Array<Operation_Costs_Update_Column>;
  where?: Maybe<Operation_Costs_Bool_Exp>;
};

/** Ordering options when selecting data from "operation_costs". */
export type Operation_Costs_Order_By = {
  created_at?: Maybe<Order_By>;
  data?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: operation_costs */
export type Operation_Costs_Pk_Columns_Input = {
  key: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Operation_Costs_Prepend_Input = {
  data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "operation_costs" */
export enum Operation_Costs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "operation_costs" */
export type Operation_Costs_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  data?: Maybe<Scalars['jsonb']>;
  key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "operation_costs" */
export type Operation_Costs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Operation_Costs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Operation_Costs_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  data?: Maybe<Scalars['jsonb']>;
  key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "operation_costs" */
export enum Operation_Costs_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Operation_Costs_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Operation_Costs_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Operation_Costs_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Operation_Costs_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Operation_Costs_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Operation_Costs_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Operation_Costs_Set_Input>;
  where: Operation_Costs_Bool_Exp;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "param_widgets" */
export type Param_Widgets = {
  __typename?: 'param_widgets';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dashboard?: Maybe<Dashboards>;
  /** An array relationship */
  dashboard_api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  dashboard_api_keys_aggregate: Api_Keys_Aggregate;
  dashboard_id?: Maybe<Scalars['Int']>;
  id: Scalars['uuid'];
  key: Scalars['String'];
  options?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  query: Queries;
  query_id: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  visualization_widget: Visualization_Widgets;
  visualization_widget_id: Scalars['Int'];
};


/** columns and relationships of "param_widgets" */
export type Param_WidgetsDashboard_Api_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "param_widgets" */
export type Param_WidgetsDashboard_Api_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "param_widgets" */
export type Param_WidgetsOptionsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "param_widgets" */
export type Param_Widgets_Aggregate = {
  __typename?: 'param_widgets_aggregate';
  aggregate?: Maybe<Param_Widgets_Aggregate_Fields>;
  nodes: Array<Param_Widgets>;
};

export type Param_Widgets_Aggregate_Bool_Exp = {
  count?: Maybe<Param_Widgets_Aggregate_Bool_Exp_Count>;
};

export type Param_Widgets_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Param_Widgets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Param_Widgets_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "param_widgets" */
export type Param_Widgets_Aggregate_Fields = {
  __typename?: 'param_widgets_aggregate_fields';
  avg?: Maybe<Param_Widgets_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Param_Widgets_Max_Fields>;
  min?: Maybe<Param_Widgets_Min_Fields>;
  stddev?: Maybe<Param_Widgets_Stddev_Fields>;
  stddev_pop?: Maybe<Param_Widgets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Param_Widgets_Stddev_Samp_Fields>;
  sum?: Maybe<Param_Widgets_Sum_Fields>;
  var_pop?: Maybe<Param_Widgets_Var_Pop_Fields>;
  var_samp?: Maybe<Param_Widgets_Var_Samp_Fields>;
  variance?: Maybe<Param_Widgets_Variance_Fields>;
};


/** aggregate fields of "param_widgets" */
export type Param_Widgets_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Param_Widgets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "param_widgets" */
export type Param_Widgets_Aggregate_Order_By = {
  avg?: Maybe<Param_Widgets_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Param_Widgets_Max_Order_By>;
  min?: Maybe<Param_Widgets_Min_Order_By>;
  stddev?: Maybe<Param_Widgets_Stddev_Order_By>;
  stddev_pop?: Maybe<Param_Widgets_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Param_Widgets_Stddev_Samp_Order_By>;
  sum?: Maybe<Param_Widgets_Sum_Order_By>;
  var_pop?: Maybe<Param_Widgets_Var_Pop_Order_By>;
  var_samp?: Maybe<Param_Widgets_Var_Samp_Order_By>;
  variance?: Maybe<Param_Widgets_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Param_Widgets_Append_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "param_widgets" */
export type Param_Widgets_Arr_Rel_Insert_Input = {
  data: Array<Param_Widgets_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Param_Widgets_On_Conflict>;
};

/** aggregate avg on columns */
export type Param_Widgets_Avg_Fields = {
  __typename?: 'param_widgets_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  visualization_widget_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "param_widgets" */
export type Param_Widgets_Avg_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "param_widgets". All fields are combined with a logical 'AND'. */
export type Param_Widgets_Bool_Exp = {
  _and?: Maybe<Array<Param_Widgets_Bool_Exp>>;
  _not?: Maybe<Param_Widgets_Bool_Exp>;
  _or?: Maybe<Array<Param_Widgets_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dashboard?: Maybe<Dashboards_Bool_Exp>;
  dashboard_api_keys?: Maybe<Api_Keys_Bool_Exp>;
  dashboard_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  options?: Maybe<Jsonb_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  visualization_widget?: Maybe<Visualization_Widgets_Bool_Exp>;
  visualization_widget_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "param_widgets" */
export enum Param_Widgets_Constraint {
  /** unique or primary key constraint on columns "id" */
  ParamWidgetsPkey = 'param_widgets_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Param_Widgets_Delete_At_Path_Input = {
  options?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Param_Widgets_Delete_Elem_Input = {
  options?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Param_Widgets_Delete_Key_Input = {
  options?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "param_widgets" */
export type Param_Widgets_Inc_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  visualization_widget_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "param_widgets" */
export type Param_Widgets_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  dashboard_api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  options?: Maybe<Scalars['jsonb']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_widget?: Maybe<Visualization_Widgets_Obj_Rel_Insert_Input>;
  visualization_widget_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Param_Widgets_Max_Fields = {
  __typename?: 'param_widgets_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_widget_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "param_widgets" */
export type Param_Widgets_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Param_Widgets_Min_Fields = {
  __typename?: 'param_widgets_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_widget_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "param_widgets" */
export type Param_Widgets_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "param_widgets" */
export type Param_Widgets_Mutation_Response = {
  __typename?: 'param_widgets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Param_Widgets>;
};

/** on_conflict condition type for table "param_widgets" */
export type Param_Widgets_On_Conflict = {
  constraint: Param_Widgets_Constraint;
  update_columns: Array<Param_Widgets_Update_Column>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};

/** Ordering options when selecting data from "param_widgets". */
export type Param_Widgets_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard?: Maybe<Dashboards_Order_By>;
  dashboard_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  options?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  visualization_widget?: Maybe<Visualization_Widgets_Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** primary key columns input for table: param_widgets */
export type Param_Widgets_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Param_Widgets_Prepend_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "param_widgets" */
export enum Param_Widgets_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  Options = 'options',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VisualizationWidgetId = 'visualization_widget_id'
}

/** input type for updating data in table "param_widgets" */
export type Param_Widgets_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  options?: Maybe<Scalars['jsonb']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_widget_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Param_Widgets_Stddev_Fields = {
  __typename?: 'param_widgets_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  visualization_widget_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "param_widgets" */
export type Param_Widgets_Stddev_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Param_Widgets_Stddev_Pop_Fields = {
  __typename?: 'param_widgets_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  visualization_widget_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "param_widgets" */
export type Param_Widgets_Stddev_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Param_Widgets_Stddev_Samp_Fields = {
  __typename?: 'param_widgets_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  visualization_widget_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "param_widgets" */
export type Param_Widgets_Stddev_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "param_widgets" */
export type Param_Widgets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Param_Widgets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Param_Widgets_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  options?: Maybe<Scalars['jsonb']>;
  query_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_widget_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Param_Widgets_Sum_Fields = {
  __typename?: 'param_widgets_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  visualization_widget_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "param_widgets" */
export type Param_Widgets_Sum_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** update columns of table "param_widgets" */
export enum Param_Widgets_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  Options = 'options',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VisualizationWidgetId = 'visualization_widget_id'
}

export type Param_Widgets_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Param_Widgets_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Param_Widgets_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Param_Widgets_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Param_Widgets_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Param_Widgets_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Param_Widgets_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Param_Widgets_Set_Input>;
  where: Param_Widgets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Param_Widgets_Var_Pop_Fields = {
  __typename?: 'param_widgets_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  visualization_widget_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "param_widgets" */
export type Param_Widgets_Var_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Param_Widgets_Var_Samp_Fields = {
  __typename?: 'param_widgets_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  visualization_widget_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "param_widgets" */
export type Param_Widgets_Var_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Param_Widgets_Variance_Fields = {
  __typename?: 'param_widgets_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  visualization_widget_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "param_widgets" */
export type Param_Widgets_Variance_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  visualization_widget_id?: Maybe<Order_By>;
};

/** columns and relationships of "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates = {
  __typename?: 'pending_api_user_subscription_updates';
  /** An object relationship */
  api_user_service_tier?: Maybe<Api_User_Service_Tiers>;
  base_plan_id?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  orb_subscription_id?: Maybe<Scalars['String']>;
  orb_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline: Scalars['timestamptz'];
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['Int'];
};

/** aggregated selection of "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Aggregate = {
  __typename?: 'pending_api_user_subscription_updates_aggregate';
  aggregate?: Maybe<Pending_Api_User_Subscription_Updates_Aggregate_Fields>;
  nodes: Array<Pending_Api_User_Subscription_Updates>;
};

export type Pending_Api_User_Subscription_Updates_Aggregate_Bool_Exp = {
  count?: Maybe<Pending_Api_User_Subscription_Updates_Aggregate_Bool_Exp_Count>;
};

export type Pending_Api_User_Subscription_Updates_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Aggregate_Fields = {
  __typename?: 'pending_api_user_subscription_updates_aggregate_fields';
  avg?: Maybe<Pending_Api_User_Subscription_Updates_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Pending_Api_User_Subscription_Updates_Max_Fields>;
  min?: Maybe<Pending_Api_User_Subscription_Updates_Min_Fields>;
  stddev?: Maybe<Pending_Api_User_Subscription_Updates_Stddev_Fields>;
  stddev_pop?: Maybe<Pending_Api_User_Subscription_Updates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pending_Api_User_Subscription_Updates_Stddev_Samp_Fields>;
  sum?: Maybe<Pending_Api_User_Subscription_Updates_Sum_Fields>;
  var_pop?: Maybe<Pending_Api_User_Subscription_Updates_Var_Pop_Fields>;
  var_samp?: Maybe<Pending_Api_User_Subscription_Updates_Var_Samp_Fields>;
  variance?: Maybe<Pending_Api_User_Subscription_Updates_Variance_Fields>;
};


/** aggregate fields of "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Aggregate_Order_By = {
  avg?: Maybe<Pending_Api_User_Subscription_Updates_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Pending_Api_User_Subscription_Updates_Max_Order_By>;
  min?: Maybe<Pending_Api_User_Subscription_Updates_Min_Order_By>;
  stddev?: Maybe<Pending_Api_User_Subscription_Updates_Stddev_Order_By>;
  stddev_pop?: Maybe<Pending_Api_User_Subscription_Updates_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Pending_Api_User_Subscription_Updates_Stddev_Samp_Order_By>;
  sum?: Maybe<Pending_Api_User_Subscription_Updates_Sum_Order_By>;
  var_pop?: Maybe<Pending_Api_User_Subscription_Updates_Var_Pop_Order_By>;
  var_samp?: Maybe<Pending_Api_User_Subscription_Updates_Var_Samp_Order_By>;
  variance?: Maybe<Pending_Api_User_Subscription_Updates_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Arr_Rel_Insert_Input = {
  data: Array<Pending_Api_User_Subscription_Updates_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Pending_Api_User_Subscription_Updates_On_Conflict>;
};

/** aggregate avg on columns */
export type Pending_Api_User_Subscription_Updates_Avg_Fields = {
  __typename?: 'pending_api_user_subscription_updates_avg_fields';
  service_tier_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Avg_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "pending_api_user_subscription_updates". All fields are combined with a logical 'AND'. */
export type Pending_Api_User_Subscription_Updates_Bool_Exp = {
  _and?: Maybe<Array<Pending_Api_User_Subscription_Updates_Bool_Exp>>;
  _not?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
  _or?: Maybe<Array<Pending_Api_User_Subscription_Updates_Bool_Exp>>;
  api_user_service_tier?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
  base_plan_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  orb_subscription_id?: Maybe<String_Comparison_Exp>;
  orb_subscription_start_date?: Maybe<Timestamptz_Comparison_Exp>;
  service_tier_id?: Maybe<Int_Comparison_Exp>;
  soft_deadline?: Maybe<Timestamptz_Comparison_Exp>;
  update_date?: Maybe<Timestamptz_Comparison_Exp>;
  update_type?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "pending_api_user_subscription_updates" */
export enum Pending_Api_User_Subscription_Updates_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  PendingApiUserSubscriptionUpdatesPkey = 'pending_api_user_subscription_updates_pkey'
}

/** input type for incrementing numeric columns in table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Inc_Input = {
  service_tier_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Insert_Input = {
  api_user_service_tier?: Maybe<Api_User_Service_Tiers_Obj_Rel_Insert_Input>;
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  orb_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Pending_Api_User_Subscription_Updates_Max_Fields = {
  __typename?: 'pending_api_user_subscription_updates_max_fields';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  orb_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Max_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  orb_subscription_start_date?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Pending_Api_User_Subscription_Updates_Min_Fields = {
  __typename?: 'pending_api_user_subscription_updates_min_fields';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  orb_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Min_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  orb_subscription_start_date?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Mutation_Response = {
  __typename?: 'pending_api_user_subscription_updates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Pending_Api_User_Subscription_Updates>;
};

/** input type for inserting object relation for remote table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Obj_Rel_Insert_Input = {
  data: Pending_Api_User_Subscription_Updates_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Pending_Api_User_Subscription_Updates_On_Conflict>;
};

/** on_conflict condition type for table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_On_Conflict = {
  constraint: Pending_Api_User_Subscription_Updates_Constraint;
  update_columns: Array<Pending_Api_User_Subscription_Updates_Update_Column>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};

/** Ordering options when selecting data from "pending_api_user_subscription_updates". */
export type Pending_Api_User_Subscription_Updates_Order_By = {
  api_user_service_tier?: Maybe<Api_User_Service_Tiers_Order_By>;
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  orb_subscription_start_date?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: pending_api_user_subscription_updates */
export type Pending_Api_User_Subscription_Updates_Pk_Columns_Input = {
  user_id: Scalars['Int'];
};

/** select columns of table "pending_api_user_subscription_updates" */
export enum Pending_Api_User_Subscription_Updates_Select_Column {
  /** column name */
  BasePlanId = 'base_plan_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  OrbSubscriptionStartDate = 'orb_subscription_start_date',
  /** column name */
  ServiceTierId = 'service_tier_id',
  /** column name */
  SoftDeadline = 'soft_deadline',
  /** column name */
  UpdateDate = 'update_date',
  /** column name */
  UpdateType = 'update_type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Set_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  orb_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Pending_Api_User_Subscription_Updates_Stddev_Fields = {
  __typename?: 'pending_api_user_subscription_updates_stddev_fields';
  service_tier_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Stddev_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Pending_Api_User_Subscription_Updates_Stddev_Pop_Fields = {
  __typename?: 'pending_api_user_subscription_updates_stddev_pop_fields';
  service_tier_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Stddev_Pop_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Pending_Api_User_Subscription_Updates_Stddev_Samp_Fields = {
  __typename?: 'pending_api_user_subscription_updates_stddev_samp_fields';
  service_tier_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Stddev_Samp_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pending_Api_User_Subscription_Updates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pending_Api_User_Subscription_Updates_Stream_Cursor_Value_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  orb_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Pending_Api_User_Subscription_Updates_Sum_Fields = {
  __typename?: 'pending_api_user_subscription_updates_sum_fields';
  service_tier_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Sum_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** update columns of table "pending_api_user_subscription_updates" */
export enum Pending_Api_User_Subscription_Updates_Update_Column {
  /** column name */
  BasePlanId = 'base_plan_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  OrbSubscriptionStartDate = 'orb_subscription_start_date',
  /** column name */
  ServiceTierId = 'service_tier_id',
  /** column name */
  SoftDeadline = 'soft_deadline',
  /** column name */
  UpdateDate = 'update_date',
  /** column name */
  UpdateType = 'update_type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Pending_Api_User_Subscription_Updates_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Pending_Api_User_Subscription_Updates_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Pending_Api_User_Subscription_Updates_Set_Input>;
  where: Pending_Api_User_Subscription_Updates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Pending_Api_User_Subscription_Updates_Var_Pop_Fields = {
  __typename?: 'pending_api_user_subscription_updates_var_pop_fields';
  service_tier_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Var_Pop_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Pending_Api_User_Subscription_Updates_Var_Samp_Fields = {
  __typename?: 'pending_api_user_subscription_updates_var_samp_fields';
  service_tier_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Var_Samp_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Pending_Api_User_Subscription_Updates_Variance_Fields = {
  __typename?: 'pending_api_user_subscription_updates_variance_fields';
  service_tier_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "pending_api_user_subscription_updates" */
export type Pending_Api_User_Subscription_Updates_Variance_Order_By = {
  service_tier_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** columns and relationships of "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates = {
  __typename?: 'pending_team_subscription_updates';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  metadata: Scalars['jsonb'];
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  service_tier: Team_Service_Tiers;
  service_tier_id: Scalars['Int'];
  soft_deadline: Scalars['timestamptz'];
  /** An object relationship */
  team: Teams;
  team_id: Scalars['Int'];
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type: Scalars['String'];
};


/** columns and relationships of "pending_team_subscription_updates" */
export type Pending_Team_Subscription_UpdatesMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Aggregate = {
  __typename?: 'pending_team_subscription_updates_aggregate';
  aggregate?: Maybe<Pending_Team_Subscription_Updates_Aggregate_Fields>;
  nodes: Array<Pending_Team_Subscription_Updates>;
};

export type Pending_Team_Subscription_Updates_Aggregate_Bool_Exp = {
  count?: Maybe<Pending_Team_Subscription_Updates_Aggregate_Bool_Exp_Count>;
};

export type Pending_Team_Subscription_Updates_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Aggregate_Fields = {
  __typename?: 'pending_team_subscription_updates_aggregate_fields';
  avg?: Maybe<Pending_Team_Subscription_Updates_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Pending_Team_Subscription_Updates_Max_Fields>;
  min?: Maybe<Pending_Team_Subscription_Updates_Min_Fields>;
  stddev?: Maybe<Pending_Team_Subscription_Updates_Stddev_Fields>;
  stddev_pop?: Maybe<Pending_Team_Subscription_Updates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pending_Team_Subscription_Updates_Stddev_Samp_Fields>;
  sum?: Maybe<Pending_Team_Subscription_Updates_Sum_Fields>;
  var_pop?: Maybe<Pending_Team_Subscription_Updates_Var_Pop_Fields>;
  var_samp?: Maybe<Pending_Team_Subscription_Updates_Var_Samp_Fields>;
  variance?: Maybe<Pending_Team_Subscription_Updates_Variance_Fields>;
};


/** aggregate fields of "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Aggregate_Order_By = {
  avg?: Maybe<Pending_Team_Subscription_Updates_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Pending_Team_Subscription_Updates_Max_Order_By>;
  min?: Maybe<Pending_Team_Subscription_Updates_Min_Order_By>;
  stddev?: Maybe<Pending_Team_Subscription_Updates_Stddev_Order_By>;
  stddev_pop?: Maybe<Pending_Team_Subscription_Updates_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Pending_Team_Subscription_Updates_Stddev_Samp_Order_By>;
  sum?: Maybe<Pending_Team_Subscription_Updates_Sum_Order_By>;
  var_pop?: Maybe<Pending_Team_Subscription_Updates_Var_Pop_Order_By>;
  var_samp?: Maybe<Pending_Team_Subscription_Updates_Var_Samp_Order_By>;
  variance?: Maybe<Pending_Team_Subscription_Updates_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Pending_Team_Subscription_Updates_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Arr_Rel_Insert_Input = {
  data: Array<Pending_Team_Subscription_Updates_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Pending_Team_Subscription_Updates_On_Conflict>;
};

/** aggregate avg on columns */
export type Pending_Team_Subscription_Updates_Avg_Fields = {
  __typename?: 'pending_team_subscription_updates_avg_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Avg_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "pending_team_subscription_updates". All fields are combined with a logical 'AND'. */
export type Pending_Team_Subscription_Updates_Bool_Exp = {
  _and?: Maybe<Array<Pending_Team_Subscription_Updates_Bool_Exp>>;
  _not?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
  _or?: Maybe<Array<Pending_Team_Subscription_Updates_Bool_Exp>>;
  base_plan_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  orb_subscription_anchor_day?: Maybe<Int_Comparison_Exp>;
  orb_subscription_id?: Maybe<String_Comparison_Exp>;
  service_tier?: Maybe<Team_Service_Tiers_Bool_Exp>;
  service_tier_id?: Maybe<Int_Comparison_Exp>;
  soft_deadline?: Maybe<Timestamptz_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  update_date?: Maybe<Timestamptz_Comparison_Exp>;
  update_type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "pending_team_subscription_updates" */
export enum Pending_Team_Subscription_Updates_Constraint {
  /** unique or primary key constraint on columns "team_id" */
  PendingTeamSubscriptionUpdatesPkey = 'pending_team_subscription_updates_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Pending_Team_Subscription_Updates_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Pending_Team_Subscription_Updates_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Pending_Team_Subscription_Updates_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Inc_Input = {
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Insert_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metadata?: Maybe<Scalars['jsonb']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier?: Maybe<Team_Service_Tiers_Obj_Rel_Insert_Input>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  team_id?: Maybe<Scalars['Int']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Pending_Team_Subscription_Updates_Max_Fields = {
  __typename?: 'pending_team_subscription_updates_max_fields';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  team_id?: Maybe<Scalars['Int']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Max_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Pending_Team_Subscription_Updates_Min_Fields = {
  __typename?: 'pending_team_subscription_updates_min_fields';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  team_id?: Maybe<Scalars['Int']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Min_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
};

/** response of any mutation on the table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Mutation_Response = {
  __typename?: 'pending_team_subscription_updates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Pending_Team_Subscription_Updates>;
};

/** on_conflict condition type for table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_On_Conflict = {
  constraint: Pending_Team_Subscription_Updates_Constraint;
  update_columns: Array<Pending_Team_Subscription_Updates_Update_Column>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};

/** Ordering options when selecting data from "pending_team_subscription_updates". */
export type Pending_Team_Subscription_Updates_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  service_tier?: Maybe<Team_Service_Tiers_Order_By>;
  service_tier_id?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  team_id?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
};

/** primary key columns input for table: pending_team_subscription_updates */
export type Pending_Team_Subscription_Updates_Pk_Columns_Input = {
  team_id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Pending_Team_Subscription_Updates_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "pending_team_subscription_updates" */
export enum Pending_Team_Subscription_Updates_Select_Column {
  /** column name */
  BasePlanId = 'base_plan_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  ServiceTierId = 'service_tier_id',
  /** column name */
  SoftDeadline = 'soft_deadline',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdateDate = 'update_date',
  /** column name */
  UpdateType = 'update_type'
}

/** input type for updating data in table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Set_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metadata?: Maybe<Scalars['jsonb']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  team_id?: Maybe<Scalars['Int']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Pending_Team_Subscription_Updates_Stddev_Fields = {
  __typename?: 'pending_team_subscription_updates_stddev_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Stddev_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Pending_Team_Subscription_Updates_Stddev_Pop_Fields = {
  __typename?: 'pending_team_subscription_updates_stddev_pop_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Stddev_Pop_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Pending_Team_Subscription_Updates_Stddev_Samp_Fields = {
  __typename?: 'pending_team_subscription_updates_stddev_samp_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Stddev_Samp_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pending_Team_Subscription_Updates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pending_Team_Subscription_Updates_Stream_Cursor_Value_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metadata?: Maybe<Scalars['jsonb']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  team_id?: Maybe<Scalars['Int']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Pending_Team_Subscription_Updates_Sum_Fields = {
  __typename?: 'pending_team_subscription_updates_sum_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Sum_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** update columns of table "pending_team_subscription_updates" */
export enum Pending_Team_Subscription_Updates_Update_Column {
  /** column name */
  BasePlanId = 'base_plan_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  ServiceTierId = 'service_tier_id',
  /** column name */
  SoftDeadline = 'soft_deadline',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdateDate = 'update_date',
  /** column name */
  UpdateType = 'update_type'
}

export type Pending_Team_Subscription_Updates_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Pending_Team_Subscription_Updates_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Pending_Team_Subscription_Updates_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Pending_Team_Subscription_Updates_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Pending_Team_Subscription_Updates_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Pending_Team_Subscription_Updates_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Pending_Team_Subscription_Updates_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Pending_Team_Subscription_Updates_Set_Input>;
  where: Pending_Team_Subscription_Updates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Pending_Team_Subscription_Updates_Var_Pop_Fields = {
  __typename?: 'pending_team_subscription_updates_var_pop_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Var_Pop_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Pending_Team_Subscription_Updates_Var_Samp_Fields = {
  __typename?: 'pending_team_subscription_updates_var_samp_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Var_Samp_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Pending_Team_Subscription_Updates_Variance_Fields = {
  __typename?: 'pending_team_subscription_updates_variance_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "pending_team_subscription_updates" */
export type Pending_Team_Subscription_Updates_Variance_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
};

/** columns and relationships of "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates = {
  __typename?: 'pending_user_subscription_updates';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  metadata: Scalars['jsonb'];
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier: Scalars['Int'];
  soft_deadline: Scalars['timestamptz'];
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type: Scalars['String'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['Int'];
  /** An object relationship */
  user_service_tier: User_Service_Tiers;
};


/** columns and relationships of "pending_user_subscription_updates" */
export type Pending_User_Subscription_UpdatesMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Aggregate = {
  __typename?: 'pending_user_subscription_updates_aggregate';
  aggregate?: Maybe<Pending_User_Subscription_Updates_Aggregate_Fields>;
  nodes: Array<Pending_User_Subscription_Updates>;
};

export type Pending_User_Subscription_Updates_Aggregate_Bool_Exp = {
  count?: Maybe<Pending_User_Subscription_Updates_Aggregate_Bool_Exp_Count>;
};

export type Pending_User_Subscription_Updates_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Aggregate_Fields = {
  __typename?: 'pending_user_subscription_updates_aggregate_fields';
  avg?: Maybe<Pending_User_Subscription_Updates_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Pending_User_Subscription_Updates_Max_Fields>;
  min?: Maybe<Pending_User_Subscription_Updates_Min_Fields>;
  stddev?: Maybe<Pending_User_Subscription_Updates_Stddev_Fields>;
  stddev_pop?: Maybe<Pending_User_Subscription_Updates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pending_User_Subscription_Updates_Stddev_Samp_Fields>;
  sum?: Maybe<Pending_User_Subscription_Updates_Sum_Fields>;
  var_pop?: Maybe<Pending_User_Subscription_Updates_Var_Pop_Fields>;
  var_samp?: Maybe<Pending_User_Subscription_Updates_Var_Samp_Fields>;
  variance?: Maybe<Pending_User_Subscription_Updates_Variance_Fields>;
};


/** aggregate fields of "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Aggregate_Order_By = {
  avg?: Maybe<Pending_User_Subscription_Updates_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Pending_User_Subscription_Updates_Max_Order_By>;
  min?: Maybe<Pending_User_Subscription_Updates_Min_Order_By>;
  stddev?: Maybe<Pending_User_Subscription_Updates_Stddev_Order_By>;
  stddev_pop?: Maybe<Pending_User_Subscription_Updates_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Pending_User_Subscription_Updates_Stddev_Samp_Order_By>;
  sum?: Maybe<Pending_User_Subscription_Updates_Sum_Order_By>;
  var_pop?: Maybe<Pending_User_Subscription_Updates_Var_Pop_Order_By>;
  var_samp?: Maybe<Pending_User_Subscription_Updates_Var_Samp_Order_By>;
  variance?: Maybe<Pending_User_Subscription_Updates_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Pending_User_Subscription_Updates_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Arr_Rel_Insert_Input = {
  data: Array<Pending_User_Subscription_Updates_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Pending_User_Subscription_Updates_On_Conflict>;
};

/** aggregate avg on columns */
export type Pending_User_Subscription_Updates_Avg_Fields = {
  __typename?: 'pending_user_subscription_updates_avg_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Avg_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "pending_user_subscription_updates". All fields are combined with a logical 'AND'. */
export type Pending_User_Subscription_Updates_Bool_Exp = {
  _and?: Maybe<Array<Pending_User_Subscription_Updates_Bool_Exp>>;
  _not?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
  _or?: Maybe<Array<Pending_User_Subscription_Updates_Bool_Exp>>;
  base_plan_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  orb_subscription_anchor_day?: Maybe<Int_Comparison_Exp>;
  orb_subscription_id?: Maybe<String_Comparison_Exp>;
  service_tier?: Maybe<Int_Comparison_Exp>;
  soft_deadline?: Maybe<Timestamptz_Comparison_Exp>;
  update_date?: Maybe<Timestamptz_Comparison_Exp>;
  update_type?: Maybe<String_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
  user_service_tier?: Maybe<User_Service_Tiers_Bool_Exp>;
};

/** unique or primary key constraints on table "pending_user_subscription_updates" */
export enum Pending_User_Subscription_Updates_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  PendingUserSubscriptionUpdatesPkey = 'pending_user_subscription_updates_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Pending_User_Subscription_Updates_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Pending_User_Subscription_Updates_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Pending_User_Subscription_Updates_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Inc_Input = {
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Insert_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metadata?: Maybe<Scalars['jsonb']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
  user_service_tier?: Maybe<User_Service_Tiers_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Pending_User_Subscription_Updates_Max_Fields = {
  __typename?: 'pending_user_subscription_updates_max_fields';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Max_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Pending_User_Subscription_Updates_Min_Fields = {
  __typename?: 'pending_user_subscription_updates_min_fields';
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Min_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Mutation_Response = {
  __typename?: 'pending_user_subscription_updates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Pending_User_Subscription_Updates>;
};

/** input type for inserting object relation for remote table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Obj_Rel_Insert_Input = {
  data: Pending_User_Subscription_Updates_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Pending_User_Subscription_Updates_On_Conflict>;
};

/** on_conflict condition type for table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_On_Conflict = {
  constraint: Pending_User_Subscription_Updates_Constraint;
  update_columns: Array<Pending_User_Subscription_Updates_Update_Column>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};

/** Ordering options when selecting data from "pending_user_subscription_updates". */
export type Pending_User_Subscription_Updates_Order_By = {
  base_plan_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  soft_deadline?: Maybe<Order_By>;
  update_date?: Maybe<Order_By>;
  update_type?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
  user_service_tier?: Maybe<User_Service_Tiers_Order_By>;
};

/** primary key columns input for table: pending_user_subscription_updates */
export type Pending_User_Subscription_Updates_Pk_Columns_Input = {
  user_id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Pending_User_Subscription_Updates_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "pending_user_subscription_updates" */
export enum Pending_User_Subscription_Updates_Select_Column {
  /** column name */
  BasePlanId = 'base_plan_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  ServiceTier = 'service_tier',
  /** column name */
  SoftDeadline = 'soft_deadline',
  /** column name */
  UpdateDate = 'update_date',
  /** column name */
  UpdateType = 'update_type',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Set_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metadata?: Maybe<Scalars['jsonb']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Pending_User_Subscription_Updates_Stddev_Fields = {
  __typename?: 'pending_user_subscription_updates_stddev_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Stddev_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Pending_User_Subscription_Updates_Stddev_Pop_Fields = {
  __typename?: 'pending_user_subscription_updates_stddev_pop_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Stddev_Pop_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Pending_User_Subscription_Updates_Stddev_Samp_Fields = {
  __typename?: 'pending_user_subscription_updates_stddev_samp_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Stddev_Samp_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pending_User_Subscription_Updates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pending_User_Subscription_Updates_Stream_Cursor_Value_Input = {
  base_plan_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metadata?: Maybe<Scalars['jsonb']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  service_tier?: Maybe<Scalars['Int']>;
  soft_deadline?: Maybe<Scalars['timestamptz']>;
  update_date?: Maybe<Scalars['timestamptz']>;
  update_type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Pending_User_Subscription_Updates_Sum_Fields = {
  __typename?: 'pending_user_subscription_updates_sum_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Sum_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** update columns of table "pending_user_subscription_updates" */
export enum Pending_User_Subscription_Updates_Update_Column {
  /** column name */
  BasePlanId = 'base_plan_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  ServiceTier = 'service_tier',
  /** column name */
  SoftDeadline = 'soft_deadline',
  /** column name */
  UpdateDate = 'update_date',
  /** column name */
  UpdateType = 'update_type',
  /** column name */
  UserId = 'user_id'
}

export type Pending_User_Subscription_Updates_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Pending_User_Subscription_Updates_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Pending_User_Subscription_Updates_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Pending_User_Subscription_Updates_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Pending_User_Subscription_Updates_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Pending_User_Subscription_Updates_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Pending_User_Subscription_Updates_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Pending_User_Subscription_Updates_Set_Input>;
  where: Pending_User_Subscription_Updates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Pending_User_Subscription_Updates_Var_Pop_Fields = {
  __typename?: 'pending_user_subscription_updates_var_pop_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Var_Pop_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Pending_User_Subscription_Updates_Var_Samp_Fields = {
  __typename?: 'pending_user_subscription_updates_var_samp_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Var_Samp_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Pending_User_Subscription_Updates_Variance_Fields = {
  __typename?: 'pending_user_subscription_updates_variance_fields';
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "pending_user_subscription_updates" */
export type Pending_User_Subscription_Updates_Variance_Order_By = {
  orb_subscription_anchor_day?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** columns and relationships of "popular_dashboard_tags" */
export type Popular_Dashboard_Tags = {
  __typename?: 'popular_dashboard_tags';
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** aggregated selection of "popular_dashboard_tags" */
export type Popular_Dashboard_Tags_Aggregate = {
  __typename?: 'popular_dashboard_tags_aggregate';
  aggregate?: Maybe<Popular_Dashboard_Tags_Aggregate_Fields>;
  nodes: Array<Popular_Dashboard_Tags>;
};

/** aggregate fields of "popular_dashboard_tags" */
export type Popular_Dashboard_Tags_Aggregate_Fields = {
  __typename?: 'popular_dashboard_tags_aggregate_fields';
  avg?: Maybe<Popular_Dashboard_Tags_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Popular_Dashboard_Tags_Max_Fields>;
  min?: Maybe<Popular_Dashboard_Tags_Min_Fields>;
  stddev?: Maybe<Popular_Dashboard_Tags_Stddev_Fields>;
  stddev_pop?: Maybe<Popular_Dashboard_Tags_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Popular_Dashboard_Tags_Stddev_Samp_Fields>;
  sum?: Maybe<Popular_Dashboard_Tags_Sum_Fields>;
  var_pop?: Maybe<Popular_Dashboard_Tags_Var_Pop_Fields>;
  var_samp?: Maybe<Popular_Dashboard_Tags_Var_Samp_Fields>;
  variance?: Maybe<Popular_Dashboard_Tags_Variance_Fields>;
};


/** aggregate fields of "popular_dashboard_tags" */
export type Popular_Dashboard_Tags_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Popular_Dashboard_Tags_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Popular_Dashboard_Tags_Avg_Fields = {
  __typename?: 'popular_dashboard_tags_avg_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "popular_dashboard_tags". All fields are combined with a logical 'AND'. */
export type Popular_Dashboard_Tags_Bool_Exp = {
  _and?: Maybe<Array<Popular_Dashboard_Tags_Bool_Exp>>;
  _not?: Maybe<Popular_Dashboard_Tags_Bool_Exp>;
  _or?: Maybe<Array<Popular_Dashboard_Tags_Bool_Exp>>;
  popularity?: Maybe<Bigint_Comparison_Exp>;
  tag?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Popular_Dashboard_Tags_Max_Fields = {
  __typename?: 'popular_dashboard_tags_max_fields';
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Popular_Dashboard_Tags_Min_Fields = {
  __typename?: 'popular_dashboard_tags_min_fields';
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "popular_dashboard_tags". */
export type Popular_Dashboard_Tags_Order_By = {
  popularity?: Maybe<Order_By>;
  tag?: Maybe<Order_By>;
};

/** select columns of table "popular_dashboard_tags" */
export enum Popular_Dashboard_Tags_Select_Column {
  /** column name */
  Popularity = 'popularity',
  /** column name */
  Tag = 'tag'
}

/** aggregate stddev on columns */
export type Popular_Dashboard_Tags_Stddev_Fields = {
  __typename?: 'popular_dashboard_tags_stddev_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Popular_Dashboard_Tags_Stddev_Pop_Fields = {
  __typename?: 'popular_dashboard_tags_stddev_pop_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Popular_Dashboard_Tags_Stddev_Samp_Fields = {
  __typename?: 'popular_dashboard_tags_stddev_samp_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "popular_dashboard_tags" */
export type Popular_Dashboard_Tags_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Popular_Dashboard_Tags_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Popular_Dashboard_Tags_Stream_Cursor_Value_Input = {
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Popular_Dashboard_Tags_Sum_Fields = {
  __typename?: 'popular_dashboard_tags_sum_fields';
  popularity?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Popular_Dashboard_Tags_Var_Pop_Fields = {
  __typename?: 'popular_dashboard_tags_var_pop_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Popular_Dashboard_Tags_Var_Samp_Fields = {
  __typename?: 'popular_dashboard_tags_var_samp_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Popular_Dashboard_Tags_Variance_Fields = {
  __typename?: 'popular_dashboard_tags_variance_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "popular_query_tags" */
export type Popular_Query_Tags = {
  __typename?: 'popular_query_tags';
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** aggregated selection of "popular_query_tags" */
export type Popular_Query_Tags_Aggregate = {
  __typename?: 'popular_query_tags_aggregate';
  aggregate?: Maybe<Popular_Query_Tags_Aggregate_Fields>;
  nodes: Array<Popular_Query_Tags>;
};

/** aggregate fields of "popular_query_tags" */
export type Popular_Query_Tags_Aggregate_Fields = {
  __typename?: 'popular_query_tags_aggregate_fields';
  avg?: Maybe<Popular_Query_Tags_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Popular_Query_Tags_Max_Fields>;
  min?: Maybe<Popular_Query_Tags_Min_Fields>;
  stddev?: Maybe<Popular_Query_Tags_Stddev_Fields>;
  stddev_pop?: Maybe<Popular_Query_Tags_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Popular_Query_Tags_Stddev_Samp_Fields>;
  sum?: Maybe<Popular_Query_Tags_Sum_Fields>;
  var_pop?: Maybe<Popular_Query_Tags_Var_Pop_Fields>;
  var_samp?: Maybe<Popular_Query_Tags_Var_Samp_Fields>;
  variance?: Maybe<Popular_Query_Tags_Variance_Fields>;
};


/** aggregate fields of "popular_query_tags" */
export type Popular_Query_Tags_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Popular_Query_Tags_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Popular_Query_Tags_Avg_Fields = {
  __typename?: 'popular_query_tags_avg_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "popular_query_tags". All fields are combined with a logical 'AND'. */
export type Popular_Query_Tags_Bool_Exp = {
  _and?: Maybe<Array<Popular_Query_Tags_Bool_Exp>>;
  _not?: Maybe<Popular_Query_Tags_Bool_Exp>;
  _or?: Maybe<Array<Popular_Query_Tags_Bool_Exp>>;
  popularity?: Maybe<Bigint_Comparison_Exp>;
  tag?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Popular_Query_Tags_Max_Fields = {
  __typename?: 'popular_query_tags_max_fields';
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Popular_Query_Tags_Min_Fields = {
  __typename?: 'popular_query_tags_min_fields';
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "popular_query_tags". */
export type Popular_Query_Tags_Order_By = {
  popularity?: Maybe<Order_By>;
  tag?: Maybe<Order_By>;
};

/** select columns of table "popular_query_tags" */
export enum Popular_Query_Tags_Select_Column {
  /** column name */
  Popularity = 'popularity',
  /** column name */
  Tag = 'tag'
}

/** aggregate stddev on columns */
export type Popular_Query_Tags_Stddev_Fields = {
  __typename?: 'popular_query_tags_stddev_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Popular_Query_Tags_Stddev_Pop_Fields = {
  __typename?: 'popular_query_tags_stddev_pop_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Popular_Query_Tags_Stddev_Samp_Fields = {
  __typename?: 'popular_query_tags_stddev_samp_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "popular_query_tags" */
export type Popular_Query_Tags_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Popular_Query_Tags_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Popular_Query_Tags_Stream_Cursor_Value_Input = {
  popularity?: Maybe<Scalars['bigint']>;
  tag?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Popular_Query_Tags_Sum_Fields = {
  __typename?: 'popular_query_tags_sum_fields';
  popularity?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Popular_Query_Tags_Var_Pop_Fields = {
  __typename?: 'popular_query_tags_var_pop_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Popular_Query_Tags_Var_Samp_Fields = {
  __typename?: 'popular_query_tags_var_samp_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Popular_Query_Tags_Variance_Fields = {
  __typename?: 'popular_query_tags_variance_fields';
  popularity?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "pro_badge" */
export type Pro_Badge = {
  __typename?: 'pro_badge';
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "pro_badge" */
export type Pro_Badge_Aggregate = {
  __typename?: 'pro_badge_aggregate';
  aggregate?: Maybe<Pro_Badge_Aggregate_Fields>;
  nodes: Array<Pro_Badge>;
};

/** aggregate fields of "pro_badge" */
export type Pro_Badge_Aggregate_Fields = {
  __typename?: 'pro_badge_aggregate_fields';
  avg?: Maybe<Pro_Badge_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Pro_Badge_Max_Fields>;
  min?: Maybe<Pro_Badge_Min_Fields>;
  stddev?: Maybe<Pro_Badge_Stddev_Fields>;
  stddev_pop?: Maybe<Pro_Badge_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pro_Badge_Stddev_Samp_Fields>;
  sum?: Maybe<Pro_Badge_Sum_Fields>;
  var_pop?: Maybe<Pro_Badge_Var_Pop_Fields>;
  var_samp?: Maybe<Pro_Badge_Var_Samp_Fields>;
  variance?: Maybe<Pro_Badge_Variance_Fields>;
};


/** aggregate fields of "pro_badge" */
export type Pro_Badge_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Pro_Badge_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Pro_Badge_Avg_Fields = {
  __typename?: 'pro_badge_avg_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "pro_badge". All fields are combined with a logical 'AND'. */
export type Pro_Badge_Bool_Exp = {
  _and?: Maybe<Array<Pro_Badge_Bool_Exp>>;
  _not?: Maybe<Pro_Badge_Bool_Exp>;
  _or?: Maybe<Array<Pro_Badge_Bool_Exp>>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "pro_badge" */
export type Pro_Badge_Inc_Input = {
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "pro_badge" */
export type Pro_Badge_Insert_Input = {
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Pro_Badge_Max_Fields = {
  __typename?: 'pro_badge_max_fields';
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Pro_Badge_Min_Fields = {
  __typename?: 'pro_badge_min_fields';
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "pro_badge" */
export type Pro_Badge_Mutation_Response = {
  __typename?: 'pro_badge_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Pro_Badge>;
};

/** input type for inserting object relation for remote table "pro_badge" */
export type Pro_Badge_Obj_Rel_Insert_Input = {
  data: Pro_Badge_Insert_Input;
};

/** Ordering options when selecting data from "pro_badge". */
export type Pro_Badge_Order_By = {
  user_id?: Maybe<Order_By>;
};

/** select columns of table "pro_badge" */
export enum Pro_Badge_Select_Column {
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "pro_badge" */
export type Pro_Badge_Set_Input = {
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Pro_Badge_Stddev_Fields = {
  __typename?: 'pro_badge_stddev_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Pro_Badge_Stddev_Pop_Fields = {
  __typename?: 'pro_badge_stddev_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Pro_Badge_Stddev_Samp_Fields = {
  __typename?: 'pro_badge_stddev_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "pro_badge" */
export type Pro_Badge_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pro_Badge_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pro_Badge_Stream_Cursor_Value_Input = {
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Pro_Badge_Sum_Fields = {
  __typename?: 'pro_badge_sum_fields';
  user_id?: Maybe<Scalars['Int']>;
};

export type Pro_Badge_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Pro_Badge_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Pro_Badge_Set_Input>;
  where: Pro_Badge_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Pro_Badge_Var_Pop_Fields = {
  __typename?: 'pro_badge_var_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Pro_Badge_Var_Samp_Fields = {
  __typename?: 'pro_badge_var_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Pro_Badge_Variance_Fields = {
  __typename?: 'pro_badge_variance_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "queries" */
export type Queries = {
  __typename?: 'queries';
  /** An array relationship */
  api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  api_keys_aggregate: Api_Keys_Aggregate;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dataset: Datasets;
  dataset_id: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  /** An array relationship */
  favorite_queries: Array<Favorite_Queries>;
  /** An aggregate relationship */
  favorite_queries_aggregate: Favorite_Queries_Aggregate;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  forked_query?: Maybe<Queries>;
  id: Scalars['Int'];
  is_archived: Scalars['Boolean'];
  is_private: Scalars['Boolean'];
  is_temp: Scalars['Boolean'];
  matview_id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  /** An array relationship */
  param_widgets: Array<Param_Widgets>;
  /** An aggregate relationship */
  param_widgets_aggregate: Param_Widgets_Aggregate;
  parameters: Scalars['jsonb'];
  query: Scalars['String'];
  /** An object relationship */
  query_favorite_count_all?: Maybe<Query_Favorite_Count_All>;
  /** An object relationship */
  query_favorite_count_last_24h?: Maybe<Query_Favorite_Count_Last_24h>;
  /** An object relationship */
  query_favorite_count_last_30d?: Maybe<Query_Favorite_Count_Last_30d>;
  /** An object relationship */
  query_favorite_count_last_7d?: Maybe<Query_Favorite_Count_Last_7d>;
  schedule?: Maybe<Scalars['interval']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  tags?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  team?: Maybe<Teams>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['Int']>;
  version: Scalars['Int'];
  /** An array relationship */
  visualizations: Array<Visualizations>;
  /** An aggregate relationship */
  visualizations_aggregate: Visualizations_Aggregate;
};


/** columns and relationships of "queries" */
export type QueriesApi_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "queries" */
export type QueriesApi_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "queries" */
export type QueriesFavorite_QueriesArgs = {
  distinct_on?: Maybe<Array<Favorite_Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Queries_Order_By>>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};


/** columns and relationships of "queries" */
export type QueriesFavorite_Queries_AggregateArgs = {
  distinct_on?: Maybe<Array<Favorite_Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Queries_Order_By>>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};


/** columns and relationships of "queries" */
export type QueriesParam_WidgetsArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


/** columns and relationships of "queries" */
export type QueriesParam_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


/** columns and relationships of "queries" */
export type QueriesParametersArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "queries" */
export type QueriesTagsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "queries" */
export type QueriesVisualizationsArgs = {
  distinct_on?: Maybe<Array<Visualizations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualizations_Order_By>>;
  where?: Maybe<Visualizations_Bool_Exp>;
};


/** columns and relationships of "queries" */
export type QueriesVisualizations_AggregateArgs = {
  distinct_on?: Maybe<Array<Visualizations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualizations_Order_By>>;
  where?: Maybe<Visualizations_Bool_Exp>;
};

/** aggregated selection of "queries" */
export type Queries_Aggregate = {
  __typename?: 'queries_aggregate';
  aggregate?: Maybe<Queries_Aggregate_Fields>;
  nodes: Array<Queries>;
};

export type Queries_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Queries_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Queries_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Queries_Aggregate_Bool_Exp_Count>;
};

export type Queries_Aggregate_Bool_Exp_Bool_And = {
  arguments: Queries_Select_Column_Queries_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Queries_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Queries_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Queries_Select_Column_Queries_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Queries_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Queries_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Queries_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Queries_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "queries" */
export type Queries_Aggregate_Fields = {
  __typename?: 'queries_aggregate_fields';
  avg?: Maybe<Queries_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Queries_Max_Fields>;
  min?: Maybe<Queries_Min_Fields>;
  stddev?: Maybe<Queries_Stddev_Fields>;
  stddev_pop?: Maybe<Queries_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Queries_Stddev_Samp_Fields>;
  sum?: Maybe<Queries_Sum_Fields>;
  var_pop?: Maybe<Queries_Var_Pop_Fields>;
  var_samp?: Maybe<Queries_Var_Samp_Fields>;
  variance?: Maybe<Queries_Variance_Fields>;
};


/** aggregate fields of "queries" */
export type Queries_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Queries_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "queries" */
export type Queries_Aggregate_Order_By = {
  avg?: Maybe<Queries_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Queries_Max_Order_By>;
  min?: Maybe<Queries_Min_Order_By>;
  stddev?: Maybe<Queries_Stddev_Order_By>;
  stddev_pop?: Maybe<Queries_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Queries_Stddev_Samp_Order_By>;
  sum?: Maybe<Queries_Sum_Order_By>;
  var_pop?: Maybe<Queries_Var_Pop_Order_By>;
  var_samp?: Maybe<Queries_Var_Samp_Order_By>;
  variance?: Maybe<Queries_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Queries_Append_Input = {
  parameters?: Maybe<Scalars['jsonb']>;
  tags?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "queries" */
export type Queries_Arr_Rel_Insert_Input = {
  data: Array<Queries_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Queries_On_Conflict>;
};

/** aggregate avg on columns */
export type Queries_Avg_Fields = {
  __typename?: 'queries_avg_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "queries" */
export type Queries_Avg_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "queries". All fields are combined with a logical 'AND'. */
export type Queries_Bool_Exp = {
  _and?: Maybe<Array<Queries_Bool_Exp>>;
  _not?: Maybe<Queries_Bool_Exp>;
  _or?: Maybe<Array<Queries_Bool_Exp>>;
  api_keys?: Maybe<Api_Keys_Bool_Exp>;
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dataset?: Maybe<Datasets_Bool_Exp>;
  dataset_id?: Maybe<Int_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  favorite_queries?: Maybe<Favorite_Queries_Bool_Exp>;
  favorite_queries_aggregate?: Maybe<Favorite_Queries_Aggregate_Bool_Exp>;
  folder_id?: Maybe<String_Comparison_Exp>;
  fork_of_id?: Maybe<Int_Comparison_Exp>;
  forked_query?: Maybe<Queries_Bool_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  is_archived?: Maybe<Boolean_Comparison_Exp>;
  is_private?: Maybe<Boolean_Comparison_Exp>;
  is_temp?: Maybe<Boolean_Comparison_Exp>;
  matview_id?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  param_widgets?: Maybe<Param_Widgets_Bool_Exp>;
  param_widgets_aggregate?: Maybe<Param_Widgets_Aggregate_Bool_Exp>;
  parameters?: Maybe<Jsonb_Comparison_Exp>;
  query?: Maybe<String_Comparison_Exp>;
  query_favorite_count_all?: Maybe<Query_Favorite_Count_All_Bool_Exp>;
  query_favorite_count_last_24h?: Maybe<Query_Favorite_Count_Last_24h_Bool_Exp>;
  query_favorite_count_last_30d?: Maybe<Query_Favorite_Count_Last_30d_Bool_Exp>;
  query_favorite_count_last_7d?: Maybe<Query_Favorite_Count_Last_7d_Bool_Exp>;
  schedule?: Maybe<Interval_Comparison_Exp>;
  search_vector?: Maybe<Tsvector_Comparison_Exp>;
  tags?: Maybe<Jsonb_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
  version?: Maybe<Int_Comparison_Exp>;
  visualizations?: Maybe<Visualizations_Bool_Exp>;
  visualizations_aggregate?: Maybe<Visualizations_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "queries" */
export enum Queries_Constraint {
  /** unique or primary key constraint on columns "id" */
  QueriesPkey = 'queries_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Queries_Delete_At_Path_Input = {
  parameters?: Maybe<Array<Scalars['String']>>;
  tags?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Queries_Delete_Elem_Input = {
  parameters?: Maybe<Scalars['Int']>;
  tags?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Queries_Delete_Key_Input = {
  parameters?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "queries" */
export type Queries_Inc_Input = {
  dataset_id?: Maybe<Scalars['Int']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "queries" */
export type Queries_Insert_Input = {
  api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset?: Maybe<Datasets_Obj_Rel_Insert_Input>;
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  favorite_queries?: Maybe<Favorite_Queries_Arr_Rel_Insert_Input>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  forked_query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  id?: Maybe<Scalars['Int']>;
  is_archived?: Maybe<Scalars['Boolean']>;
  is_private?: Maybe<Scalars['Boolean']>;
  is_temp?: Maybe<Scalars['Boolean']>;
  matview_id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  param_widgets?: Maybe<Param_Widgets_Arr_Rel_Insert_Input>;
  parameters?: Maybe<Scalars['jsonb']>;
  query?: Maybe<Scalars['String']>;
  query_favorite_count_all?: Maybe<Query_Favorite_Count_All_Obj_Rel_Insert_Input>;
  query_favorite_count_last_24h?: Maybe<Query_Favorite_Count_Last_24h_Obj_Rel_Insert_Input>;
  query_favorite_count_last_30d?: Maybe<Query_Favorite_Count_Last_30d_Obj_Rel_Insert_Input>;
  query_favorite_count_last_7d?: Maybe<Query_Favorite_Count_Last_7d_Obj_Rel_Insert_Input>;
  schedule?: Maybe<Scalars['interval']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  tags?: Maybe<Scalars['jsonb']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['Int']>;
  visualizations?: Maybe<Visualizations_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Queries_Max_Fields = {
  __typename?: 'queries_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  matview_id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "queries" */
export type Queries_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  dataset_id?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  folder_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  matview_id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  query?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Queries_Min_Fields = {
  __typename?: 'queries_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  matview_id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "queries" */
export type Queries_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  dataset_id?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  folder_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  matview_id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  query?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** response of any mutation on the table "queries" */
export type Queries_Mutation_Response = {
  __typename?: 'queries_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Queries>;
};

/** input type for inserting object relation for remote table "queries" */
export type Queries_Obj_Rel_Insert_Input = {
  data: Queries_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Queries_On_Conflict>;
};

/** on_conflict condition type for table "queries" */
export type Queries_On_Conflict = {
  constraint: Queries_Constraint;
  update_columns: Array<Queries_Update_Column>;
  where?: Maybe<Queries_Bool_Exp>;
};

/** Ordering options when selecting data from "queries". */
export type Queries_Order_By = {
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  dataset?: Maybe<Datasets_Order_By>;
  dataset_id?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  favorite_queries_aggregate?: Maybe<Favorite_Queries_Aggregate_Order_By>;
  folder_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  forked_query?: Maybe<Queries_Order_By>;
  id?: Maybe<Order_By>;
  is_archived?: Maybe<Order_By>;
  is_private?: Maybe<Order_By>;
  is_temp?: Maybe<Order_By>;
  matview_id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  param_widgets_aggregate?: Maybe<Param_Widgets_Aggregate_Order_By>;
  parameters?: Maybe<Order_By>;
  query?: Maybe<Order_By>;
  query_favorite_count_all?: Maybe<Query_Favorite_Count_All_Order_By>;
  query_favorite_count_last_24h?: Maybe<Query_Favorite_Count_Last_24h_Order_By>;
  query_favorite_count_last_30d?: Maybe<Query_Favorite_Count_Last_30d_Order_By>;
  query_favorite_count_last_7d?: Maybe<Query_Favorite_Count_Last_7d_Order_By>;
  schedule?: Maybe<Order_By>;
  search_vector?: Maybe<Order_By>;
  tags?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
  visualizations_aggregate?: Maybe<Visualizations_Aggregate_Order_By>;
};

/** primary key columns input for table: queries */
export type Queries_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Queries_Prepend_Input = {
  parameters?: Maybe<Scalars['jsonb']>;
  tags?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "queries" */
export enum Queries_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  Description = 'description',
  /** column name */
  FolderId = 'folder_id',
  /** column name */
  ForkOfId = 'fork_of_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private',
  /** column name */
  IsTemp = 'is_temp',
  /** column name */
  MatviewId = 'matview_id',
  /** column name */
  Name = 'name',
  /** column name */
  Parameters = 'parameters',
  /** column name */
  Query = 'query',
  /** column name */
  Schedule = 'schedule',
  /** column name */
  SearchVector = 'search_vector',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

/** select "queries_aggregate_bool_exp_bool_and_arguments_columns" columns of table "queries" */
export enum Queries_Select_Column_Queries_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private',
  /** column name */
  IsTemp = 'is_temp'
}

/** select "queries_aggregate_bool_exp_bool_or_arguments_columns" columns of table "queries" */
export enum Queries_Select_Column_Queries_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private',
  /** column name */
  IsTemp = 'is_temp'
}

/** input type for updating data in table "queries" */
export type Queries_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  is_archived?: Maybe<Scalars['Boolean']>;
  is_private?: Maybe<Scalars['Boolean']>;
  is_temp?: Maybe<Scalars['Boolean']>;
  matview_id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['jsonb']>;
  query?: Maybe<Scalars['String']>;
  schedule?: Maybe<Scalars['interval']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  tags?: Maybe<Scalars['jsonb']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Queries_Stddev_Fields = {
  __typename?: 'queries_stddev_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "queries" */
export type Queries_Stddev_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Queries_Stddev_Pop_Fields = {
  __typename?: 'queries_stddev_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "queries" */
export type Queries_Stddev_Pop_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Queries_Stddev_Samp_Fields = {
  __typename?: 'queries_stddev_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "queries" */
export type Queries_Stddev_Samp_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** Streaming cursor of the table "queries" */
export type Queries_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Queries_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Queries_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  folder_id?: Maybe<Scalars['String']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  is_archived?: Maybe<Scalars['Boolean']>;
  is_private?: Maybe<Scalars['Boolean']>;
  is_temp?: Maybe<Scalars['Boolean']>;
  matview_id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['jsonb']>;
  query?: Maybe<Scalars['String']>;
  schedule?: Maybe<Scalars['interval']>;
  search_vector?: Maybe<Scalars['tsvector']>;
  tags?: Maybe<Scalars['jsonb']>;
  team_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Queries_Sum_Fields = {
  __typename?: 'queries_sum_fields';
  dataset_id?: Maybe<Scalars['Int']>;
  fork_of_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
  version?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "queries" */
export type Queries_Sum_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** update columns of table "queries" */
export enum Queries_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  Description = 'description',
  /** column name */
  FolderId = 'folder_id',
  /** column name */
  ForkOfId = 'fork_of_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsArchived = 'is_archived',
  /** column name */
  IsPrivate = 'is_private',
  /** column name */
  IsTemp = 'is_temp',
  /** column name */
  MatviewId = 'matview_id',
  /** column name */
  Name = 'name',
  /** column name */
  Parameters = 'parameters',
  /** column name */
  Query = 'query',
  /** column name */
  Schedule = 'schedule',
  /** column name */
  SearchVector = 'search_vector',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

export type Queries_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Queries_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Queries_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Queries_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Queries_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Queries_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Queries_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Queries_Set_Input>;
  where: Queries_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Queries_Var_Pop_Fields = {
  __typename?: 'queries_var_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "queries" */
export type Queries_Var_Pop_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Queries_Var_Samp_Fields = {
  __typename?: 'queries_var_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "queries" */
export type Queries_Var_Samp_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Queries_Variance_Fields = {
  __typename?: 'queries_variance_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  fork_of_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "queries" */
export type Queries_Variance_Order_By = {
  dataset_id?: Maybe<Order_By>;
  fork_of_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** columns and relationships of "query_details" */
export type Query_Details = {
  __typename?: 'query_details';
  /** An object relationship */
  api_keys?: Maybe<Api_Keys>;
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  query?: Maybe<Queries>;
  query_id?: Maybe<Scalars['Int']>;
  show_watermark?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  team?: Maybe<Teams>;
  team_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  visualization?: Maybe<Visualizations>;
};


/** columns and relationships of "query_details" */
export type Query_DetailsParametersArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "query_details" */
export type Query_Details_Aggregate = {
  __typename?: 'query_details_aggregate';
  aggregate?: Maybe<Query_Details_Aggregate_Fields>;
  nodes: Array<Query_Details>;
};

/** aggregate fields of "query_details" */
export type Query_Details_Aggregate_Fields = {
  __typename?: 'query_details_aggregate_fields';
  avg?: Maybe<Query_Details_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Details_Max_Fields>;
  min?: Maybe<Query_Details_Min_Fields>;
  stddev?: Maybe<Query_Details_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Details_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Details_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Details_Sum_Fields>;
  var_pop?: Maybe<Query_Details_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Details_Var_Samp_Fields>;
  variance?: Maybe<Query_Details_Variance_Fields>;
};


/** aggregate fields of "query_details" */
export type Query_Details_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Details_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Query_Details_Avg_Fields = {
  __typename?: 'query_details_avg_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_details". All fields are combined with a logical 'AND'. */
export type Query_Details_Bool_Exp = {
  _and?: Maybe<Array<Query_Details_Bool_Exp>>;
  _not?: Maybe<Query_Details_Bool_Exp>;
  _or?: Maybe<Array<Query_Details_Bool_Exp>>;
  api_keys?: Maybe<Api_Keys_Bool_Exp>;
  dataset_id?: Maybe<Int_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  is_private?: Maybe<Boolean_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  parameters?: Maybe<Jsonb_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  show_watermark?: Maybe<Boolean_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
  visualization?: Maybe<Visualizations_Bool_Exp>;
};

/** input type for inserting data into table "query_details" */
export type Query_Details_Insert_Input = {
  api_keys?: Maybe<Api_Keys_Obj_Rel_Insert_Input>;
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['jsonb']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  show_watermark?: Maybe<Scalars['Boolean']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  team_id?: Maybe<Scalars['Int']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
  visualization?: Maybe<Visualizations_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Query_Details_Max_Fields = {
  __typename?: 'query_details_max_fields';
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Query_Details_Min_Fields = {
  __typename?: 'query_details_min_fields';
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting object relation for remote table "query_details" */
export type Query_Details_Obj_Rel_Insert_Input = {
  data: Query_Details_Insert_Input;
};

/** Ordering options when selecting data from "query_details". */
export type Query_Details_Order_By = {
  api_keys?: Maybe<Api_Keys_Order_By>;
  dataset_id?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  is_private?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  parameters?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_id?: Maybe<Order_By>;
  show_watermark?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  team_id?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
  visualization?: Maybe<Visualizations_Order_By>;
};

/** select columns of table "query_details" */
export enum Query_Details_Select_Column {
  /** column name */
  DatasetId = 'dataset_id',
  /** column name */
  Description = 'description',
  /** column name */
  IsPrivate = 'is_private',
  /** column name */
  Name = 'name',
  /** column name */
  Parameters = 'parameters',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  ShowWatermark = 'show_watermark',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UserId = 'user_id'
}

/** aggregate stddev on columns */
export type Query_Details_Stddev_Fields = {
  __typename?: 'query_details_stddev_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Details_Stddev_Pop_Fields = {
  __typename?: 'query_details_stddev_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Details_Stddev_Samp_Fields = {
  __typename?: 'query_details_stddev_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_details" */
export type Query_Details_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Details_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Details_Stream_Cursor_Value_Input = {
  dataset_id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  is_private?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['jsonb']>;
  query_id?: Maybe<Scalars['Int']>;
  show_watermark?: Maybe<Scalars['Boolean']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Query_Details_Sum_Fields = {
  __typename?: 'query_details_sum_fields';
  dataset_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Query_Details_Var_Pop_Fields = {
  __typename?: 'query_details_var_pop_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Details_Var_Samp_Fields = {
  __typename?: 'query_details_var_samp_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Details_Variance_Fields = {
  __typename?: 'query_details_variance_fields';
  dataset_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_errors" */
export type Query_Errors = {
  __typename?: 'query_errors';
  /** An array relationship */
  api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  api_keys_aggregate: Api_Keys_Aggregate;
  generated_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  job_attempt_number: Scalars['Int'];
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id: Scalars['uuid'];
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  message: Scalars['String'];
  metadata: Scalars['jsonb'];
  /** An object relationship */
  query: Queries;
  query_id: Scalars['Int'];
  query_parameters: Scalars['jsonb'];
  query_version: Scalars['Int'];
  runtime?: Maybe<Scalars['Int']>;
  type: Scalars['String'];
  valid_until?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "query_errors" */
export type Query_ErrorsApi_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "query_errors" */
export type Query_ErrorsApi_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "query_errors" */
export type Query_ErrorsMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "query_errors" */
export type Query_ErrorsQuery_ParametersArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "query_errors" */
export type Query_Errors_Aggregate = {
  __typename?: 'query_errors_aggregate';
  aggregate?: Maybe<Query_Errors_Aggregate_Fields>;
  nodes: Array<Query_Errors>;
};

/** aggregate fields of "query_errors" */
export type Query_Errors_Aggregate_Fields = {
  __typename?: 'query_errors_aggregate_fields';
  avg?: Maybe<Query_Errors_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Errors_Max_Fields>;
  min?: Maybe<Query_Errors_Min_Fields>;
  stddev?: Maybe<Query_Errors_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Errors_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Errors_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Errors_Sum_Fields>;
  var_pop?: Maybe<Query_Errors_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Errors_Var_Samp_Fields>;
  variance?: Maybe<Query_Errors_Variance_Fields>;
};


/** aggregate fields of "query_errors" */
export type Query_Errors_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Errors_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Query_Errors_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Query_Errors_Avg_Fields = {
  __typename?: 'query_errors_avg_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_errors". All fields are combined with a logical 'AND'. */
export type Query_Errors_Bool_Exp = {
  _and?: Maybe<Array<Query_Errors_Bool_Exp>>;
  _not?: Maybe<Query_Errors_Bool_Exp>;
  _or?: Maybe<Array<Query_Errors_Bool_Exp>>;
  api_keys?: Maybe<Api_Keys_Bool_Exp>;
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  generated_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  job_attempt_number?: Maybe<Int_Comparison_Exp>;
  job_category?: Maybe<Job_Categories_Comparison_Exp>;
  job_created_at?: Maybe<Timestamptz_Comparison_Exp>;
  job_id?: Maybe<Uuid_Comparison_Exp>;
  job_priority?: Maybe<Int_Comparison_Exp>;
  job_user_id?: Maybe<Int_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  query_parameters?: Maybe<Jsonb_Comparison_Exp>;
  query_version?: Maybe<Int_Comparison_Exp>;
  runtime?: Maybe<Int_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  valid_until?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "query_errors" */
export enum Query_Errors_Constraint {
  /** unique or primary key constraint on columns "id" */
  QueryErrorsPkey = 'query_errors_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Query_Errors_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
  query_parameters?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Query_Errors_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Query_Errors_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
  query_parameters?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "query_errors" */
export type Query_Errors_Inc_Input = {
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "query_errors" */
export type Query_Errors_Insert_Input = {
  api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  message?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Query_Errors_Max_Fields = {
  __typename?: 'query_errors_max_fields';
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  message?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Query_Errors_Min_Fields = {
  __typename?: 'query_errors_min_fields';
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  message?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "query_errors" */
export type Query_Errors_Mutation_Response = {
  __typename?: 'query_errors_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Query_Errors>;
};

/** on_conflict condition type for table "query_errors" */
export type Query_Errors_On_Conflict = {
  constraint: Query_Errors_Constraint;
  update_columns: Array<Query_Errors_Update_Column>;
  where?: Maybe<Query_Errors_Bool_Exp>;
};

/** Ordering options when selecting data from "query_errors". */
export type Query_Errors_Order_By = {
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  generated_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_attempt_number?: Maybe<Order_By>;
  job_category?: Maybe<Order_By>;
  job_created_at?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
  job_priority?: Maybe<Order_By>;
  job_user_id?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_id?: Maybe<Order_By>;
  query_parameters?: Maybe<Order_By>;
  query_version?: Maybe<Order_By>;
  runtime?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  valid_until?: Maybe<Order_By>;
};

/** primary key columns input for table: query_errors */
export type Query_Errors_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Query_Errors_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "query_errors" */
export enum Query_Errors_Select_Column {
  /** column name */
  GeneratedAt = 'generated_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobAttemptNumber = 'job_attempt_number',
  /** column name */
  JobCategory = 'job_category',
  /** column name */
  JobCreatedAt = 'job_created_at',
  /** column name */
  JobId = 'job_id',
  /** column name */
  JobPriority = 'job_priority',
  /** column name */
  JobUserId = 'job_user_id',
  /** column name */
  Message = 'message',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryParameters = 'query_parameters',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  Runtime = 'runtime',
  /** column name */
  Type = 'type',
  /** column name */
  ValidUntil = 'valid_until'
}

/** input type for updating data in table "query_errors" */
export type Query_Errors_Set_Input = {
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  message?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Query_Errors_Stddev_Fields = {
  __typename?: 'query_errors_stddev_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Errors_Stddev_Pop_Fields = {
  __typename?: 'query_errors_stddev_pop_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Errors_Stddev_Samp_Fields = {
  __typename?: 'query_errors_stddev_samp_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_errors" */
export type Query_Errors_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Errors_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Errors_Stream_Cursor_Value_Input = {
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  message?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Query_Errors_Sum_Fields = {
  __typename?: 'query_errors_sum_fields';
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['Int']>;
};

/** update columns of table "query_errors" */
export enum Query_Errors_Update_Column {
  /** column name */
  GeneratedAt = 'generated_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobAttemptNumber = 'job_attempt_number',
  /** column name */
  JobCategory = 'job_category',
  /** column name */
  JobCreatedAt = 'job_created_at',
  /** column name */
  JobId = 'job_id',
  /** column name */
  JobPriority = 'job_priority',
  /** column name */
  JobUserId = 'job_user_id',
  /** column name */
  Message = 'message',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryParameters = 'query_parameters',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  Runtime = 'runtime',
  /** column name */
  Type = 'type',
  /** column name */
  ValidUntil = 'valid_until'
}

export type Query_Errors_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Query_Errors_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Query_Errors_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Query_Errors_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Query_Errors_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Query_Errors_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Query_Errors_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Query_Errors_Set_Input>;
  where: Query_Errors_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Query_Errors_Var_Pop_Fields = {
  __typename?: 'query_errors_var_pop_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Errors_Var_Samp_Fields = {
  __typename?: 'query_errors_var_samp_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Errors_Variance_Fields = {
  __typename?: 'query_errors_variance_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_event_metadata" */
export type Query_Event_Metadata = {
  __typename?: 'query_event_metadata';
  created_at: Scalars['timestamptz'];
  description: Scalars['String'];
  name: Scalars['String'];
  query_event_id: Scalars['bpchar'];
  updated_at: Scalars['timestamptz'];
  user_id: Scalars['Int'];
};

/** aggregated selection of "query_event_metadata" */
export type Query_Event_Metadata_Aggregate = {
  __typename?: 'query_event_metadata_aggregate';
  aggregate?: Maybe<Query_Event_Metadata_Aggregate_Fields>;
  nodes: Array<Query_Event_Metadata>;
};

/** aggregate fields of "query_event_metadata" */
export type Query_Event_Metadata_Aggregate_Fields = {
  __typename?: 'query_event_metadata_aggregate_fields';
  avg?: Maybe<Query_Event_Metadata_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Event_Metadata_Max_Fields>;
  min?: Maybe<Query_Event_Metadata_Min_Fields>;
  stddev?: Maybe<Query_Event_Metadata_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Event_Metadata_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Event_Metadata_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Event_Metadata_Sum_Fields>;
  var_pop?: Maybe<Query_Event_Metadata_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Event_Metadata_Var_Samp_Fields>;
  variance?: Maybe<Query_Event_Metadata_Variance_Fields>;
};


/** aggregate fields of "query_event_metadata" */
export type Query_Event_Metadata_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Event_Metadata_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Query_Event_Metadata_Avg_Fields = {
  __typename?: 'query_event_metadata_avg_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_event_metadata". All fields are combined with a logical 'AND'. */
export type Query_Event_Metadata_Bool_Exp = {
  _and?: Maybe<Array<Query_Event_Metadata_Bool_Exp>>;
  _not?: Maybe<Query_Event_Metadata_Bool_Exp>;
  _or?: Maybe<Array<Query_Event_Metadata_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  query_event_id?: Maybe<Bpchar_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "query_event_metadata" */
export enum Query_Event_Metadata_Constraint {
  /** unique or primary key constraint on columns "query_event_id" */
  QueryEventMetadataPkey = 'query_event_metadata_pkey'
}

/** input type for incrementing numeric columns in table "query_event_metadata" */
export type Query_Event_Metadata_Inc_Input = {
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "query_event_metadata" */
export type Query_Event_Metadata_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query_event_id?: Maybe<Scalars['bpchar']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Query_Event_Metadata_Max_Fields = {
  __typename?: 'query_event_metadata_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query_event_id?: Maybe<Scalars['bpchar']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Query_Event_Metadata_Min_Fields = {
  __typename?: 'query_event_metadata_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query_event_id?: Maybe<Scalars['bpchar']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "query_event_metadata" */
export type Query_Event_Metadata_Mutation_Response = {
  __typename?: 'query_event_metadata_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Query_Event_Metadata>;
};

/** on_conflict condition type for table "query_event_metadata" */
export type Query_Event_Metadata_On_Conflict = {
  constraint: Query_Event_Metadata_Constraint;
  update_columns: Array<Query_Event_Metadata_Update_Column>;
  where?: Maybe<Query_Event_Metadata_Bool_Exp>;
};

/** Ordering options when selecting data from "query_event_metadata". */
export type Query_Event_Metadata_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  query_event_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: query_event_metadata */
export type Query_Event_Metadata_Pk_Columns_Input = {
  query_event_id: Scalars['bpchar'];
};

/** select columns of table "query_event_metadata" */
export enum Query_Event_Metadata_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
  /** column name */
  QueryEventId = 'query_event_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "query_event_metadata" */
export type Query_Event_Metadata_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query_event_id?: Maybe<Scalars['bpchar']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Query_Event_Metadata_Stddev_Fields = {
  __typename?: 'query_event_metadata_stddev_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Event_Metadata_Stddev_Pop_Fields = {
  __typename?: 'query_event_metadata_stddev_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Event_Metadata_Stddev_Samp_Fields = {
  __typename?: 'query_event_metadata_stddev_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_event_metadata" */
export type Query_Event_Metadata_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Event_Metadata_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Event_Metadata_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  query_event_id?: Maybe<Scalars['bpchar']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Query_Event_Metadata_Sum_Fields = {
  __typename?: 'query_event_metadata_sum_fields';
  user_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "query_event_metadata" */
export enum Query_Event_Metadata_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
  /** column name */
  QueryEventId = 'query_event_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Query_Event_Metadata_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Query_Event_Metadata_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Query_Event_Metadata_Set_Input>;
  where: Query_Event_Metadata_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Query_Event_Metadata_Var_Pop_Fields = {
  __typename?: 'query_event_metadata_var_pop_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Event_Metadata_Var_Samp_Fields = {
  __typename?: 'query_event_metadata_var_samp_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Event_Metadata_Variance_Fields = {
  __typename?: 'query_event_metadata_variance_fields';
  user_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_event_types" */
export type Query_Event_Types = {
  __typename?: 'query_event_types';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "query_event_types" */
export type Query_Event_Types_Aggregate = {
  __typename?: 'query_event_types_aggregate';
  aggregate?: Maybe<Query_Event_Types_Aggregate_Fields>;
  nodes: Array<Query_Event_Types>;
};

/** aggregate fields of "query_event_types" */
export type Query_Event_Types_Aggregate_Fields = {
  __typename?: 'query_event_types_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Query_Event_Types_Max_Fields>;
  min?: Maybe<Query_Event_Types_Min_Fields>;
};


/** aggregate fields of "query_event_types" */
export type Query_Event_Types_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Event_Types_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "query_event_types". All fields are combined with a logical 'AND'. */
export type Query_Event_Types_Bool_Exp = {
  _and?: Maybe<Array<Query_Event_Types_Bool_Exp>>;
  _not?: Maybe<Query_Event_Types_Bool_Exp>;
  _or?: Maybe<Array<Query_Event_Types_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "query_event_types" */
export enum Query_Event_Types_Constraint {
  /** unique or primary key constraint on columns "value" */
  QueryEventTypesPkey = 'query_event_types_pkey'
}

export enum Query_Event_Types_Enum {
  /** Ownership Changed */
  OwnershipChanged = 'ownership_changed',
  /** Query Archived */
  QueryArchived = 'query_archived',
  /** Query Created */
  QueryCreated = 'query_created',
  /** Query Forked */
  QueryForked = 'query_forked',
  /** Query Published */
  QueryPublished = 'query_published',
  /** Query Restored */
  QueryRestored = 'query_restored',
  /** Query Saved */
  QuerySaved = 'query_saved',
  /** Query Unarchived */
  QueryUnarchived = 'query_unarchived',
  /** Query Unpublished */
  QueryUnpublished = 'query_unpublished'
}

/** Boolean expression to compare columns of type "query_event_types_enum". All fields are combined with logical 'AND'. */
export type Query_Event_Types_Enum_Comparison_Exp = {
  _eq?: Maybe<Query_Event_Types_Enum>;
  _in?: Maybe<Array<Query_Event_Types_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Query_Event_Types_Enum>;
  _nin?: Maybe<Array<Query_Event_Types_Enum>>;
};

/** input type for inserting data into table "query_event_types" */
export type Query_Event_Types_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Query_Event_Types_Max_Fields = {
  __typename?: 'query_event_types_max_fields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Query_Event_Types_Min_Fields = {
  __typename?: 'query_event_types_min_fields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "query_event_types" */
export type Query_Event_Types_Mutation_Response = {
  __typename?: 'query_event_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Query_Event_Types>;
};

/** on_conflict condition type for table "query_event_types" */
export type Query_Event_Types_On_Conflict = {
  constraint: Query_Event_Types_Constraint;
  update_columns: Array<Query_Event_Types_Update_Column>;
  where?: Maybe<Query_Event_Types_Bool_Exp>;
};

/** Ordering options when selecting data from "query_event_types". */
export type Query_Event_Types_Order_By = {
  description?: Maybe<Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: query_event_types */
export type Query_Event_Types_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "query_event_types" */
export enum Query_Event_Types_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "query_event_types" */
export type Query_Event_Types_Set_Input = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "query_event_types" */
export type Query_Event_Types_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Event_Types_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Event_Types_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "query_event_types" */
export enum Query_Event_Types_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type Query_Event_Types_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Query_Event_Types_Set_Input>;
  where: Query_Event_Types_Bool_Exp;
};

/** columns and relationships of "query_events" */
export type Query_Events = {
  __typename?: 'query_events';
  created_at: Scalars['timestamptz'];
  dune_service_name: Scalars['String'];
  from: Scalars['jsonb'];
  id: Scalars['bpchar'];
  query_id: Scalars['Int'];
  query_version: Scalars['Int'];
  team_id?: Maybe<Scalars['Int']>;
  to: Scalars['jsonb'];
  type: Query_Event_Types_Enum;
  user_id?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "query_events" */
export type Query_EventsFromArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "query_events" */
export type Query_EventsToArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "query_events" */
export type Query_Events_Aggregate = {
  __typename?: 'query_events_aggregate';
  aggregate?: Maybe<Query_Events_Aggregate_Fields>;
  nodes: Array<Query_Events>;
};

/** aggregate fields of "query_events" */
export type Query_Events_Aggregate_Fields = {
  __typename?: 'query_events_aggregate_fields';
  avg?: Maybe<Query_Events_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Events_Max_Fields>;
  min?: Maybe<Query_Events_Min_Fields>;
  stddev?: Maybe<Query_Events_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Events_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Events_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Events_Sum_Fields>;
  var_pop?: Maybe<Query_Events_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Events_Var_Samp_Fields>;
  variance?: Maybe<Query_Events_Variance_Fields>;
};


/** aggregate fields of "query_events" */
export type Query_Events_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Events_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Query_Events_Append_Input = {
  from?: Maybe<Scalars['jsonb']>;
  to?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Query_Events_Avg_Fields = {
  __typename?: 'query_events_avg_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_events". All fields are combined with a logical 'AND'. */
export type Query_Events_Bool_Exp = {
  _and?: Maybe<Array<Query_Events_Bool_Exp>>;
  _not?: Maybe<Query_Events_Bool_Exp>;
  _or?: Maybe<Array<Query_Events_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dune_service_name?: Maybe<String_Comparison_Exp>;
  from?: Maybe<Jsonb_Comparison_Exp>;
  id?: Maybe<Bpchar_Comparison_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  query_version?: Maybe<Int_Comparison_Exp>;
  team_id?: Maybe<Int_Comparison_Exp>;
  to?: Maybe<Jsonb_Comparison_Exp>;
  type?: Maybe<Query_Event_Types_Enum_Comparison_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "query_events" */
export enum Query_Events_Constraint {
  /** unique or primary key constraint on columns "id" */
  QueryEventsPkey = 'query_events_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Query_Events_Delete_At_Path_Input = {
  from?: Maybe<Array<Scalars['String']>>;
  to?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Query_Events_Delete_Elem_Input = {
  from?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Query_Events_Delete_Key_Input = {
  from?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "query_events" */
export type Query_Events_Inc_Input = {
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "query_events" */
export type Query_Events_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dune_service_name?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['bpchar']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['jsonb']>;
  type?: Maybe<Query_Event_Types_Enum>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Query_Events_Max_Fields = {
  __typename?: 'query_events_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dune_service_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bpchar']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Query_Events_Min_Fields = {
  __typename?: 'query_events_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dune_service_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bpchar']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "query_events" */
export type Query_Events_Mutation_Response = {
  __typename?: 'query_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Query_Events>;
};

/** on_conflict condition type for table "query_events" */
export type Query_Events_On_Conflict = {
  constraint: Query_Events_Constraint;
  update_columns: Array<Query_Events_Update_Column>;
  where?: Maybe<Query_Events_Bool_Exp>;
};

/** Ordering options when selecting data from "query_events". */
export type Query_Events_Order_By = {
  created_at?: Maybe<Order_By>;
  dune_service_name?: Maybe<Order_By>;
  from?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  query_version?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  to?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: query_events */
export type Query_Events_Pk_Columns_Input = {
  id: Scalars['bpchar'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Query_Events_Prepend_Input = {
  from?: Maybe<Scalars['jsonb']>;
  to?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "query_events" */
export enum Query_Events_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuneServiceName = 'dune_service_name',
  /** column name */
  From = 'from',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  To = 'to',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "query_events" */
export type Query_Events_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dune_service_name?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['bpchar']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['jsonb']>;
  type?: Maybe<Query_Event_Types_Enum>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Query_Events_Stddev_Fields = {
  __typename?: 'query_events_stddev_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Events_Stddev_Pop_Fields = {
  __typename?: 'query_events_stddev_pop_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Events_Stddev_Samp_Fields = {
  __typename?: 'query_events_stddev_samp_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_events" */
export type Query_Events_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Events_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Events_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dune_service_name?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['bpchar']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['jsonb']>;
  type?: Maybe<Query_Event_Types_Enum>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Query_Events_Sum_Fields = {
  __typename?: 'query_events_sum_fields';
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "query_events" */
export enum Query_Events_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuneServiceName = 'dune_service_name',
  /** column name */
  From = 'from',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  To = 'to',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'user_id'
}

export type Query_Events_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Query_Events_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Query_Events_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Query_Events_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Query_Events_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Query_Events_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Query_Events_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Query_Events_Set_Input>;
  where: Query_Events_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Query_Events_Var_Pop_Fields = {
  __typename?: 'query_events_var_pop_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Events_Var_Samp_Fields = {
  __typename?: 'query_events_var_samp_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Events_Variance_Fields = {
  __typename?: 'query_events_variance_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  team_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_favorite_count_all" */
export type Query_Favorite_Count_All = {
  __typename?: 'query_favorite_count_all';
  favorite_count?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  query?: Maybe<Queries>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "query_favorite_count_all" */
export type Query_Favorite_Count_All_Aggregate = {
  __typename?: 'query_favorite_count_all_aggregate';
  aggregate?: Maybe<Query_Favorite_Count_All_Aggregate_Fields>;
  nodes: Array<Query_Favorite_Count_All>;
};

/** aggregate fields of "query_favorite_count_all" */
export type Query_Favorite_Count_All_Aggregate_Fields = {
  __typename?: 'query_favorite_count_all_aggregate_fields';
  avg?: Maybe<Query_Favorite_Count_All_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Favorite_Count_All_Max_Fields>;
  min?: Maybe<Query_Favorite_Count_All_Min_Fields>;
  stddev?: Maybe<Query_Favorite_Count_All_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Favorite_Count_All_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Favorite_Count_All_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Favorite_Count_All_Sum_Fields>;
  var_pop?: Maybe<Query_Favorite_Count_All_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Favorite_Count_All_Var_Samp_Fields>;
  variance?: Maybe<Query_Favorite_Count_All_Variance_Fields>;
};


/** aggregate fields of "query_favorite_count_all" */
export type Query_Favorite_Count_All_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Favorite_Count_All_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Query_Favorite_Count_All_Avg_Fields = {
  __typename?: 'query_favorite_count_all_avg_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_favorite_count_all". All fields are combined with a logical 'AND'. */
export type Query_Favorite_Count_All_Bool_Exp = {
  _and?: Maybe<Array<Query_Favorite_Count_All_Bool_Exp>>;
  _not?: Maybe<Query_Favorite_Count_All_Bool_Exp>;
  _or?: Maybe<Array<Query_Favorite_Count_All_Bool_Exp>>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
};

/** input type for inserting data into table "query_favorite_count_all" */
export type Query_Favorite_Count_All_Insert_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Query_Favorite_Count_All_Max_Fields = {
  __typename?: 'query_favorite_count_all_max_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Query_Favorite_Count_All_Min_Fields = {
  __typename?: 'query_favorite_count_all_min_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting object relation for remote table "query_favorite_count_all" */
export type Query_Favorite_Count_All_Obj_Rel_Insert_Input = {
  data: Query_Favorite_Count_All_Insert_Input;
};

/** Ordering options when selecting data from "query_favorite_count_all". */
export type Query_Favorite_Count_All_Order_By = {
  favorite_count?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_id?: Maybe<Order_By>;
};

/** select columns of table "query_favorite_count_all" */
export enum Query_Favorite_Count_All_Select_Column {
  /** column name */
  FavoriteCount = 'favorite_count',
  /** column name */
  QueryId = 'query_id'
}

/** aggregate stddev on columns */
export type Query_Favorite_Count_All_Stddev_Fields = {
  __typename?: 'query_favorite_count_all_stddev_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Favorite_Count_All_Stddev_Pop_Fields = {
  __typename?: 'query_favorite_count_all_stddev_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Favorite_Count_All_Stddev_Samp_Fields = {
  __typename?: 'query_favorite_count_all_stddev_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_favorite_count_all" */
export type Query_Favorite_Count_All_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Favorite_Count_All_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Favorite_Count_All_Stream_Cursor_Value_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Query_Favorite_Count_All_Sum_Fields = {
  __typename?: 'query_favorite_count_all_sum_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Query_Favorite_Count_All_Var_Pop_Fields = {
  __typename?: 'query_favorite_count_all_var_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Favorite_Count_All_Var_Samp_Fields = {
  __typename?: 'query_favorite_count_all_var_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Favorite_Count_All_Variance_Fields = {
  __typename?: 'query_favorite_count_all_variance_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_favorite_count_last_24h" */
export type Query_Favorite_Count_Last_24h = {
  __typename?: 'query_favorite_count_last_24h';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "query_favorite_count_last_24h" */
export type Query_Favorite_Count_Last_24h_Aggregate = {
  __typename?: 'query_favorite_count_last_24h_aggregate';
  aggregate?: Maybe<Query_Favorite_Count_Last_24h_Aggregate_Fields>;
  nodes: Array<Query_Favorite_Count_Last_24h>;
};

/** aggregate fields of "query_favorite_count_last_24h" */
export type Query_Favorite_Count_Last_24h_Aggregate_Fields = {
  __typename?: 'query_favorite_count_last_24h_aggregate_fields';
  avg?: Maybe<Query_Favorite_Count_Last_24h_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Favorite_Count_Last_24h_Max_Fields>;
  min?: Maybe<Query_Favorite_Count_Last_24h_Min_Fields>;
  stddev?: Maybe<Query_Favorite_Count_Last_24h_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Favorite_Count_Last_24h_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Favorite_Count_Last_24h_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Favorite_Count_Last_24h_Sum_Fields>;
  var_pop?: Maybe<Query_Favorite_Count_Last_24h_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Favorite_Count_Last_24h_Var_Samp_Fields>;
  variance?: Maybe<Query_Favorite_Count_Last_24h_Variance_Fields>;
};


/** aggregate fields of "query_favorite_count_last_24h" */
export type Query_Favorite_Count_Last_24h_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Favorite_Count_Last_24h_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Query_Favorite_Count_Last_24h_Avg_Fields = {
  __typename?: 'query_favorite_count_last_24h_avg_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_favorite_count_last_24h". All fields are combined with a logical 'AND'. */
export type Query_Favorite_Count_Last_24h_Bool_Exp = {
  _and?: Maybe<Array<Query_Favorite_Count_Last_24h_Bool_Exp>>;
  _not?: Maybe<Query_Favorite_Count_Last_24h_Bool_Exp>;
  _or?: Maybe<Array<Query_Favorite_Count_Last_24h_Bool_Exp>>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
};

/** input type for inserting data into table "query_favorite_count_last_24h" */
export type Query_Favorite_Count_Last_24h_Insert_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Query_Favorite_Count_Last_24h_Max_Fields = {
  __typename?: 'query_favorite_count_last_24h_max_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Query_Favorite_Count_Last_24h_Min_Fields = {
  __typename?: 'query_favorite_count_last_24h_min_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting object relation for remote table "query_favorite_count_last_24h" */
export type Query_Favorite_Count_Last_24h_Obj_Rel_Insert_Input = {
  data: Query_Favorite_Count_Last_24h_Insert_Input;
};

/** Ordering options when selecting data from "query_favorite_count_last_24h". */
export type Query_Favorite_Count_Last_24h_Order_By = {
  favorite_count?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** select columns of table "query_favorite_count_last_24h" */
export enum Query_Favorite_Count_Last_24h_Select_Column {
  /** column name */
  FavoriteCount = 'favorite_count',
  /** column name */
  QueryId = 'query_id'
}

/** aggregate stddev on columns */
export type Query_Favorite_Count_Last_24h_Stddev_Fields = {
  __typename?: 'query_favorite_count_last_24h_stddev_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Favorite_Count_Last_24h_Stddev_Pop_Fields = {
  __typename?: 'query_favorite_count_last_24h_stddev_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Favorite_Count_Last_24h_Stddev_Samp_Fields = {
  __typename?: 'query_favorite_count_last_24h_stddev_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_favorite_count_last_24h" */
export type Query_Favorite_Count_Last_24h_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Favorite_Count_Last_24h_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Favorite_Count_Last_24h_Stream_Cursor_Value_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Query_Favorite_Count_Last_24h_Sum_Fields = {
  __typename?: 'query_favorite_count_last_24h_sum_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Query_Favorite_Count_Last_24h_Var_Pop_Fields = {
  __typename?: 'query_favorite_count_last_24h_var_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Favorite_Count_Last_24h_Var_Samp_Fields = {
  __typename?: 'query_favorite_count_last_24h_var_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Favorite_Count_Last_24h_Variance_Fields = {
  __typename?: 'query_favorite_count_last_24h_variance_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_favorite_count_last_30d" */
export type Query_Favorite_Count_Last_30d = {
  __typename?: 'query_favorite_count_last_30d';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "query_favorite_count_last_30d" */
export type Query_Favorite_Count_Last_30d_Aggregate = {
  __typename?: 'query_favorite_count_last_30d_aggregate';
  aggregate?: Maybe<Query_Favorite_Count_Last_30d_Aggregate_Fields>;
  nodes: Array<Query_Favorite_Count_Last_30d>;
};

/** aggregate fields of "query_favorite_count_last_30d" */
export type Query_Favorite_Count_Last_30d_Aggregate_Fields = {
  __typename?: 'query_favorite_count_last_30d_aggregate_fields';
  avg?: Maybe<Query_Favorite_Count_Last_30d_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Favorite_Count_Last_30d_Max_Fields>;
  min?: Maybe<Query_Favorite_Count_Last_30d_Min_Fields>;
  stddev?: Maybe<Query_Favorite_Count_Last_30d_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Favorite_Count_Last_30d_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Favorite_Count_Last_30d_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Favorite_Count_Last_30d_Sum_Fields>;
  var_pop?: Maybe<Query_Favorite_Count_Last_30d_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Favorite_Count_Last_30d_Var_Samp_Fields>;
  variance?: Maybe<Query_Favorite_Count_Last_30d_Variance_Fields>;
};


/** aggregate fields of "query_favorite_count_last_30d" */
export type Query_Favorite_Count_Last_30d_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Favorite_Count_Last_30d_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Query_Favorite_Count_Last_30d_Avg_Fields = {
  __typename?: 'query_favorite_count_last_30d_avg_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_favorite_count_last_30d". All fields are combined with a logical 'AND'. */
export type Query_Favorite_Count_Last_30d_Bool_Exp = {
  _and?: Maybe<Array<Query_Favorite_Count_Last_30d_Bool_Exp>>;
  _not?: Maybe<Query_Favorite_Count_Last_30d_Bool_Exp>;
  _or?: Maybe<Array<Query_Favorite_Count_Last_30d_Bool_Exp>>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
};

/** input type for inserting data into table "query_favorite_count_last_30d" */
export type Query_Favorite_Count_Last_30d_Insert_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Query_Favorite_Count_Last_30d_Max_Fields = {
  __typename?: 'query_favorite_count_last_30d_max_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Query_Favorite_Count_Last_30d_Min_Fields = {
  __typename?: 'query_favorite_count_last_30d_min_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting object relation for remote table "query_favorite_count_last_30d" */
export type Query_Favorite_Count_Last_30d_Obj_Rel_Insert_Input = {
  data: Query_Favorite_Count_Last_30d_Insert_Input;
};

/** Ordering options when selecting data from "query_favorite_count_last_30d". */
export type Query_Favorite_Count_Last_30d_Order_By = {
  favorite_count?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** select columns of table "query_favorite_count_last_30d" */
export enum Query_Favorite_Count_Last_30d_Select_Column {
  /** column name */
  FavoriteCount = 'favorite_count',
  /** column name */
  QueryId = 'query_id'
}

/** aggregate stddev on columns */
export type Query_Favorite_Count_Last_30d_Stddev_Fields = {
  __typename?: 'query_favorite_count_last_30d_stddev_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Favorite_Count_Last_30d_Stddev_Pop_Fields = {
  __typename?: 'query_favorite_count_last_30d_stddev_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Favorite_Count_Last_30d_Stddev_Samp_Fields = {
  __typename?: 'query_favorite_count_last_30d_stddev_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_favorite_count_last_30d" */
export type Query_Favorite_Count_Last_30d_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Favorite_Count_Last_30d_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Favorite_Count_Last_30d_Stream_Cursor_Value_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Query_Favorite_Count_Last_30d_Sum_Fields = {
  __typename?: 'query_favorite_count_last_30d_sum_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Query_Favorite_Count_Last_30d_Var_Pop_Fields = {
  __typename?: 'query_favorite_count_last_30d_var_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Favorite_Count_Last_30d_Var_Samp_Fields = {
  __typename?: 'query_favorite_count_last_30d_var_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Favorite_Count_Last_30d_Variance_Fields = {
  __typename?: 'query_favorite_count_last_30d_variance_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_favorite_count_last_7d" */
export type Query_Favorite_Count_Last_7d = {
  __typename?: 'query_favorite_count_last_7d';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "query_favorite_count_last_7d" */
export type Query_Favorite_Count_Last_7d_Aggregate = {
  __typename?: 'query_favorite_count_last_7d_aggregate';
  aggregate?: Maybe<Query_Favorite_Count_Last_7d_Aggregate_Fields>;
  nodes: Array<Query_Favorite_Count_Last_7d>;
};

/** aggregate fields of "query_favorite_count_last_7d" */
export type Query_Favorite_Count_Last_7d_Aggregate_Fields = {
  __typename?: 'query_favorite_count_last_7d_aggregate_fields';
  avg?: Maybe<Query_Favorite_Count_Last_7d_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Favorite_Count_Last_7d_Max_Fields>;
  min?: Maybe<Query_Favorite_Count_Last_7d_Min_Fields>;
  stddev?: Maybe<Query_Favorite_Count_Last_7d_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Favorite_Count_Last_7d_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Favorite_Count_Last_7d_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Favorite_Count_Last_7d_Sum_Fields>;
  var_pop?: Maybe<Query_Favorite_Count_Last_7d_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Favorite_Count_Last_7d_Var_Samp_Fields>;
  variance?: Maybe<Query_Favorite_Count_Last_7d_Variance_Fields>;
};


/** aggregate fields of "query_favorite_count_last_7d" */
export type Query_Favorite_Count_Last_7d_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Favorite_Count_Last_7d_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Query_Favorite_Count_Last_7d_Avg_Fields = {
  __typename?: 'query_favorite_count_last_7d_avg_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_favorite_count_last_7d". All fields are combined with a logical 'AND'. */
export type Query_Favorite_Count_Last_7d_Bool_Exp = {
  _and?: Maybe<Array<Query_Favorite_Count_Last_7d_Bool_Exp>>;
  _not?: Maybe<Query_Favorite_Count_Last_7d_Bool_Exp>;
  _or?: Maybe<Array<Query_Favorite_Count_Last_7d_Bool_Exp>>;
  favorite_count?: Maybe<Bigint_Comparison_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
};

/** input type for inserting data into table "query_favorite_count_last_7d" */
export type Query_Favorite_Count_Last_7d_Insert_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Query_Favorite_Count_Last_7d_Max_Fields = {
  __typename?: 'query_favorite_count_last_7d_max_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Query_Favorite_Count_Last_7d_Min_Fields = {
  __typename?: 'query_favorite_count_last_7d_min_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting object relation for remote table "query_favorite_count_last_7d" */
export type Query_Favorite_Count_Last_7d_Obj_Rel_Insert_Input = {
  data: Query_Favorite_Count_Last_7d_Insert_Input;
};

/** Ordering options when selecting data from "query_favorite_count_last_7d". */
export type Query_Favorite_Count_Last_7d_Order_By = {
  favorite_count?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** select columns of table "query_favorite_count_last_7d" */
export enum Query_Favorite_Count_Last_7d_Select_Column {
  /** column name */
  FavoriteCount = 'favorite_count',
  /** column name */
  QueryId = 'query_id'
}

/** aggregate stddev on columns */
export type Query_Favorite_Count_Last_7d_Stddev_Fields = {
  __typename?: 'query_favorite_count_last_7d_stddev_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Favorite_Count_Last_7d_Stddev_Pop_Fields = {
  __typename?: 'query_favorite_count_last_7d_stddev_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Favorite_Count_Last_7d_Stddev_Samp_Fields = {
  __typename?: 'query_favorite_count_last_7d_stddev_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_favorite_count_last_7d" */
export type Query_Favorite_Count_Last_7d_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Favorite_Count_Last_7d_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Favorite_Count_Last_7d_Stream_Cursor_Value_Input = {
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Query_Favorite_Count_Last_7d_Sum_Fields = {
  __typename?: 'query_favorite_count_last_7d_sum_fields';
  favorite_count?: Maybe<Scalars['bigint']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Query_Favorite_Count_Last_7d_Var_Pop_Fields = {
  __typename?: 'query_favorite_count_last_7d_var_pop_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Favorite_Count_Last_7d_Var_Samp_Fields = {
  __typename?: 'query_favorite_count_last_7d_var_samp_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Favorite_Count_Last_7d_Variance_Fields = {
  __typename?: 'query_favorite_count_last_7d_variance_fields';
  favorite_count?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "query_results" */
export type Query_Results = {
  __typename?: 'query_results';
  /** An array relationship */
  api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  api_keys_aggregate: Api_Keys_Aggregate;
  columns?: Maybe<Scalars['_text']>;
  data: Scalars['json'];
  error?: Maybe<Scalars['jsonb']>;
  generated_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  job_attempt_number: Scalars['Int'];
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id: Scalars['uuid'];
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  query: Queries;
  query_id: Scalars['Int'];
  query_parameters: Scalars['jsonb'];
  query_version: Scalars['Int'];
  runtime?: Maybe<Scalars['float8']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "query_results" */
export type Query_ResultsApi_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "query_results" */
export type Query_ResultsApi_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "query_results" */
export type Query_ResultsDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "query_results" */
export type Query_ResultsErrorArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "query_results" */
export type Query_ResultsQuery_ParametersArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "query_results" */
export type Query_Results_Aggregate = {
  __typename?: 'query_results_aggregate';
  aggregate?: Maybe<Query_Results_Aggregate_Fields>;
  nodes: Array<Query_Results>;
};

/** aggregate fields of "query_results" */
export type Query_Results_Aggregate_Fields = {
  __typename?: 'query_results_aggregate_fields';
  avg?: Maybe<Query_Results_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Query_Results_Max_Fields>;
  min?: Maybe<Query_Results_Min_Fields>;
  stddev?: Maybe<Query_Results_Stddev_Fields>;
  stddev_pop?: Maybe<Query_Results_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Query_Results_Stddev_Samp_Fields>;
  sum?: Maybe<Query_Results_Sum_Fields>;
  var_pop?: Maybe<Query_Results_Var_Pop_Fields>;
  var_samp?: Maybe<Query_Results_Var_Samp_Fields>;
  variance?: Maybe<Query_Results_Variance_Fields>;
};


/** aggregate fields of "query_results" */
export type Query_Results_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Query_Results_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Query_Results_Append_Input = {
  error?: Maybe<Scalars['jsonb']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Query_Results_Avg_Fields = {
  __typename?: 'query_results_avg_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "query_results". All fields are combined with a logical 'AND'. */
export type Query_Results_Bool_Exp = {
  _and?: Maybe<Array<Query_Results_Bool_Exp>>;
  _not?: Maybe<Query_Results_Bool_Exp>;
  _or?: Maybe<Array<Query_Results_Bool_Exp>>;
  api_keys?: Maybe<Api_Keys_Bool_Exp>;
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  columns?: Maybe<_Text_Comparison_Exp>;
  data?: Maybe<Json_Comparison_Exp>;
  error?: Maybe<Jsonb_Comparison_Exp>;
  generated_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  job_attempt_number?: Maybe<Int_Comparison_Exp>;
  job_category?: Maybe<Job_Categories_Comparison_Exp>;
  job_created_at?: Maybe<Timestamptz_Comparison_Exp>;
  job_id?: Maybe<Uuid_Comparison_Exp>;
  job_priority?: Maybe<Int_Comparison_Exp>;
  job_user_id?: Maybe<Int_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  query_parameters?: Maybe<Jsonb_Comparison_Exp>;
  query_version?: Maybe<Int_Comparison_Exp>;
  runtime?: Maybe<Float8_Comparison_Exp>;
  valid_until?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "query_results" */
export enum Query_Results_Constraint {
  /** unique or primary key constraint on columns "id" */
  QueryResultsPkey = 'query_results_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Query_Results_Delete_At_Path_Input = {
  error?: Maybe<Array<Scalars['String']>>;
  query_parameters?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Query_Results_Delete_Elem_Input = {
  error?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Query_Results_Delete_Key_Input = {
  error?: Maybe<Scalars['String']>;
  query_parameters?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "query_results" */
export type Query_Results_Inc_Input = {
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['float8']>;
};

/** input type for inserting data into table "query_results" */
export type Query_Results_Insert_Input = {
  api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  columns?: Maybe<Scalars['_text']>;
  data?: Maybe<Scalars['json']>;
  error?: Maybe<Scalars['jsonb']>;
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['float8']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Query_Results_Max_Fields = {
  __typename?: 'query_results_max_fields';
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['float8']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Query_Results_Min_Fields = {
  __typename?: 'query_results_min_fields';
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['float8']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "query_results" */
export type Query_Results_Mutation_Response = {
  __typename?: 'query_results_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Query_Results>;
};

/** on_conflict condition type for table "query_results" */
export type Query_Results_On_Conflict = {
  constraint: Query_Results_Constraint;
  update_columns: Array<Query_Results_Update_Column>;
  where?: Maybe<Query_Results_Bool_Exp>;
};

/** Ordering options when selecting data from "query_results". */
export type Query_Results_Order_By = {
  api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  columns?: Maybe<Order_By>;
  data?: Maybe<Order_By>;
  error?: Maybe<Order_By>;
  generated_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_attempt_number?: Maybe<Order_By>;
  job_category?: Maybe<Order_By>;
  job_created_at?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
  job_priority?: Maybe<Order_By>;
  job_user_id?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_id?: Maybe<Order_By>;
  query_parameters?: Maybe<Order_By>;
  query_version?: Maybe<Order_By>;
  runtime?: Maybe<Order_By>;
  valid_until?: Maybe<Order_By>;
};

/** primary key columns input for table: query_results */
export type Query_Results_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Query_Results_Prepend_Input = {
  error?: Maybe<Scalars['jsonb']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "query_results" */
export enum Query_Results_Select_Column {
  /** column name */
  Columns = 'columns',
  /** column name */
  Data = 'data',
  /** column name */
  Error = 'error',
  /** column name */
  GeneratedAt = 'generated_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobAttemptNumber = 'job_attempt_number',
  /** column name */
  JobCategory = 'job_category',
  /** column name */
  JobCreatedAt = 'job_created_at',
  /** column name */
  JobId = 'job_id',
  /** column name */
  JobPriority = 'job_priority',
  /** column name */
  JobUserId = 'job_user_id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryParameters = 'query_parameters',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  Runtime = 'runtime',
  /** column name */
  ValidUntil = 'valid_until'
}

/** input type for updating data in table "query_results" */
export type Query_Results_Set_Input = {
  columns?: Maybe<Scalars['_text']>;
  data?: Maybe<Scalars['json']>;
  error?: Maybe<Scalars['jsonb']>;
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['float8']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Query_Results_Stddev_Fields = {
  __typename?: 'query_results_stddev_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Query_Results_Stddev_Pop_Fields = {
  __typename?: 'query_results_stddev_pop_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Query_Results_Stddev_Samp_Fields = {
  __typename?: 'query_results_stddev_samp_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "query_results" */
export type Query_Results_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Query_Results_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Query_Results_Stream_Cursor_Value_Input = {
  columns?: Maybe<Scalars['_text']>;
  data?: Maybe<Scalars['json']>;
  error?: Maybe<Scalars['jsonb']>;
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_category?: Maybe<Scalars['job_categories']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_parameters?: Maybe<Scalars['jsonb']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['float8']>;
  valid_until?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Query_Results_Sum_Fields = {
  __typename?: 'query_results_sum_fields';
  job_attempt_number?: Maybe<Scalars['Int']>;
  job_priority?: Maybe<Scalars['Int']>;
  job_user_id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  runtime?: Maybe<Scalars['float8']>;
};

/** update columns of table "query_results" */
export enum Query_Results_Update_Column {
  /** column name */
  Columns = 'columns',
  /** column name */
  Data = 'data',
  /** column name */
  Error = 'error',
  /** column name */
  GeneratedAt = 'generated_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobAttemptNumber = 'job_attempt_number',
  /** column name */
  JobCategory = 'job_category',
  /** column name */
  JobCreatedAt = 'job_created_at',
  /** column name */
  JobId = 'job_id',
  /** column name */
  JobPriority = 'job_priority',
  /** column name */
  JobUserId = 'job_user_id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryParameters = 'query_parameters',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  Runtime = 'runtime',
  /** column name */
  ValidUntil = 'valid_until'
}

export type Query_Results_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Query_Results_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Query_Results_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Query_Results_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Query_Results_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Query_Results_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Query_Results_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Query_Results_Set_Input>;
  where: Query_Results_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Query_Results_Var_Pop_Fields = {
  __typename?: 'query_results_var_pop_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Query_Results_Var_Samp_Fields = {
  __typename?: 'query_results_var_samp_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Query_Results_Variance_Fields = {
  __typename?: 'query_results_variance_fields';
  job_attempt_number?: Maybe<Scalars['Float']>;
  job_priority?: Maybe<Scalars['Float']>;
  job_user_id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  runtime?: Maybe<Scalars['Float']>;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** An array relationship */
  api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  api_keys_aggregate: Api_Keys_Aggregate;
  /** fetch data from the table: "api_keys" using primary key columns */
  api_keys_by_pk?: Maybe<Api_Keys>;
  /** fetch data from the table: "api_user_service_tiers" */
  api_user_service_tiers: Array<Api_User_Service_Tiers>;
  /** fetch aggregated fields from the table: "api_user_service_tiers" */
  api_user_service_tiers_aggregate: Api_User_Service_Tiers_Aggregate;
  /** fetch data from the table: "api_user_service_tiers" using primary key columns */
  api_user_service_tiers_by_pk?: Maybe<Api_User_Service_Tiers>;
  /** fetch data from the table: "arrakis_schemas" */
  arrakis_schemas: Array<Arrakis_Schemas>;
  /** fetch aggregated fields from the table: "arrakis_schemas" */
  arrakis_schemas_aggregate: Arrakis_Schemas_Aggregate;
  /** fetch data from the table: "arrakis_schemas" using primary key columns */
  arrakis_schemas_by_pk?: Maybe<Arrakis_Schemas>;
  billable_usage?: Maybe<BillableUsageResponse>;
  /** fetch data from the table: "blockchain_schemas" */
  blockchain_schemas: Array<Blockchain_Schemas>;
  /** fetch aggregated fields from the table: "blockchain_schemas" */
  blockchain_schemas_aggregate: Blockchain_Schemas_Aggregate;
  /** fetch data from the table: "blockchain_schemas" using primary key columns */
  blockchain_schemas_by_pk?: Maybe<Blockchain_Schemas>;
  /** An array relationship */
  contract_submissions: Array<Contract_Submissions>;
  /** An aggregate relationship */
  contract_submissions_aggregate: Contract_Submissions_Aggregate;
  /** fetch data from the table: "contract_submissions" using primary key columns */
  contract_submissions_by_pk?: Maybe<Contract_Submissions>;
  /** fetch data from the table: "dashboard_favorite_count_all" */
  dashboard_favorite_count_all: Array<Dashboard_Favorite_Count_All>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_all" */
  dashboard_favorite_count_all_aggregate: Dashboard_Favorite_Count_All_Aggregate;
  /** fetch data from the table: "dashboard_favorite_count_last_24h" */
  dashboard_favorite_count_last_24h: Array<Dashboard_Favorite_Count_Last_24h>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_last_24h" */
  dashboard_favorite_count_last_24h_aggregate: Dashboard_Favorite_Count_Last_24h_Aggregate;
  /** fetch data from the table: "dashboard_favorite_count_last_30d" */
  dashboard_favorite_count_last_30d: Array<Dashboard_Favorite_Count_Last_30d>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_last_30d" */
  dashboard_favorite_count_last_30d_aggregate: Dashboard_Favorite_Count_Last_30d_Aggregate;
  /** fetch data from the table: "dashboard_favorite_count_last_7d" */
  dashboard_favorite_count_last_7d: Array<Dashboard_Favorite_Count_Last_7d>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_last_7d" */
  dashboard_favorite_count_last_7d_aggregate: Dashboard_Favorite_Count_Last_7d_Aggregate;
  dashboard_schedules: DashboardSchedulesResponse;
  /** fetch data from the table: "dashboard_trending_scores" */
  dashboard_trending_scores: Array<Dashboard_Trending_Scores>;
  /** fetch aggregated fields from the table: "dashboard_trending_scores" */
  dashboard_trending_scores_aggregate: Dashboard_Trending_Scores_Aggregate;
  /** fetch data from the table: "dashboard_trending_scores" using primary key columns */
  dashboard_trending_scores_by_pk?: Maybe<Dashboard_Trending_Scores>;
  /** An array relationship */
  dashboards: Array<Dashboards>;
  /** An aggregate relationship */
  dashboards_aggregate: Dashboards_Aggregate;
  /** fetch data from the table: "dashboards" using primary key columns */
  dashboards_by_pk?: Maybe<Dashboards>;
  /** fetch data from the table: "datasets" */
  datasets: Array<Datasets>;
  /** fetch aggregated fields from the table: "datasets" */
  datasets_aggregate: Datasets_Aggregate;
  /** fetch data from the table: "datasets" using primary key columns */
  datasets_by_pk?: Maybe<Datasets>;
  export_csv?: Maybe<ExportCsvResponse>;
  /** An array relationship */
  favorite_dashboards: Array<Favorite_Dashboards>;
  /** An aggregate relationship */
  favorite_dashboards_aggregate: Favorite_Dashboards_Aggregate;
  /** fetch data from the table: "favorite_dashboards" using primary key columns */
  favorite_dashboards_by_pk?: Maybe<Favorite_Dashboards>;
  /** An array relationship */
  favorite_queries: Array<Favorite_Queries>;
  /** An aggregate relationship */
  favorite_queries_aggregate: Favorite_Queries_Aggregate;
  /** fetch data from the table: "favorite_queries" using primary key columns */
  favorite_queries_by_pk?: Maybe<Favorite_Queries>;
  /** fetch data from the table: "favourited_schemas" */
  favourited_schemas: Array<Favourited_Schemas>;
  /** fetch aggregated fields from the table: "favourited_schemas" */
  favourited_schemas_aggregate: Favourited_Schemas_Aggregate;
  /** fetch data from the table: "favourited_schemas" using primary key columns */
  favourited_schemas_by_pk?: Maybe<Favourited_Schemas>;
  /** Get orb API subscription upcoming invoice */
  get_api_upcoming_invoice?: Maybe<GetApiUpcomingInvoiceResponse>;
  get_auth_provider_user?: Maybe<AuthProviderUser>;
  get_execution?: Maybe<GetExecutionResponse>;
  get_initial_query_event?: Maybe<QueryEvent>;
  /** Collect and merge invoices from stripe and orb */
  get_invoices?: Maybe<GetInvoiceResponse>;
  get_query_contributors: GetQueryContributorsResponse;
  get_query_event?: Maybe<QueryEvent>;
  get_query_events: GetQueryEventsResponse;
  /** execute function "get_result_by_job_id" which returns "get_result_template" */
  get_result_by_job_id: Array<Get_Result_Template>;
  /** execute function "get_result_by_job_id" and query aggregates on result of table type "get_result_template" */
  get_result_by_job_id_aggregate: Get_Result_Template_Aggregate;
  /** execute function "get_result_by_result_id" which returns "get_result_template" */
  get_result_by_result_id: Array<Get_Result_Template>;
  /** execute function "get_result_by_result_id" and query aggregates on result of table type "get_result_template" */
  get_result_by_result_id_aggregate: Get_Result_Template_Aggregate;
  /** fetch data from the table: "get_result_template" */
  get_result_template: Array<Get_Result_Template>;
  /** fetch aggregated fields from the table: "get_result_template" */
  get_result_template_aggregate: Get_Result_Template_Aggregate;
  get_result_v3?: Maybe<GetResultV3Response>;
  get_result_v4?: Maybe<GetResultV4Response>;
  /** Collect and merge team invoices from stripe and orb */
  get_team_invoices?: Maybe<GetTeamInvoiceResponse>;
  /** Get orb subscription upcoming invoice */
  get_team_upcoming_invoice: GetTeamUpcomingInvoiceResponse;
  /** Get orb subscription upcoming invoice */
  get_upcoming_invoice?: Maybe<GetUpcomingInvoiceResponse>;
  /** fetch data from the table: "handles" */
  handles: Array<Handles>;
  /** fetch aggregated fields from the table: "handles" */
  handles_aggregate: Handles_Aggregate;
  /** fetch data from the table: "jobs" */
  jobs: Array<Jobs>;
  /** fetch aggregated fields from the table: "jobs" */
  jobs_aggregate: Jobs_Aggregate;
  /** fetch data from the table: "jobs" using primary key columns */
  jobs_by_pk?: Maybe<Jobs>;
  /** An array relationship */
  memberships: Array<Memberships>;
  /** An aggregate relationship */
  memberships_aggregate: Memberships_Aggregate;
  /** fetch data from the table: "memberships" using primary key columns */
  memberships_by_pk?: Maybe<Memberships>;
  /** fetch data from the table: "memberships_private_details" */
  memberships_private_details: Array<Memberships_Private_Details>;
  /** fetch aggregated fields from the table: "memberships_private_details" */
  memberships_private_details_aggregate: Memberships_Private_Details_Aggregate;
  nlq_models: Scalars['String'];
  /** fetch data from the table: "onboarding_questions" */
  onboarding_questions: Array<Onboarding_Questions>;
  /** fetch aggregated fields from the table: "onboarding_questions" */
  onboarding_questions_aggregate: Onboarding_Questions_Aggregate;
  /** fetch data from the table: "onboarding_questions" using primary key columns */
  onboarding_questions_by_pk?: Maybe<Onboarding_Questions>;
  /** fetch data from the table: "operation_costs" */
  operation_costs: Array<Operation_Costs>;
  /** fetch aggregated fields from the table: "operation_costs" */
  operation_costs_aggregate: Operation_Costs_Aggregate;
  /** fetch data from the table: "operation_costs" using primary key columns */
  operation_costs_by_pk?: Maybe<Operation_Costs>;
  /** An array relationship */
  param_widgets: Array<Param_Widgets>;
  /** An aggregate relationship */
  param_widgets_aggregate: Param_Widgets_Aggregate;
  /** fetch data from the table: "param_widgets" using primary key columns */
  param_widgets_by_pk?: Maybe<Param_Widgets>;
  /** An array relationship */
  pending_api_user_subscription_updates: Array<Pending_Api_User_Subscription_Updates>;
  /** An aggregate relationship */
  pending_api_user_subscription_updates_aggregate: Pending_Api_User_Subscription_Updates_Aggregate;
  /** fetch data from the table: "pending_api_user_subscription_updates" using primary key columns */
  pending_api_user_subscription_updates_by_pk?: Maybe<Pending_Api_User_Subscription_Updates>;
  /** An array relationship */
  pending_team_subscription_updates: Array<Pending_Team_Subscription_Updates>;
  /** An aggregate relationship */
  pending_team_subscription_updates_aggregate: Pending_Team_Subscription_Updates_Aggregate;
  /** fetch data from the table: "pending_team_subscription_updates" using primary key columns */
  pending_team_subscription_updates_by_pk?: Maybe<Pending_Team_Subscription_Updates>;
  /** An array relationship */
  pending_user_subscription_updates: Array<Pending_User_Subscription_Updates>;
  /** An aggregate relationship */
  pending_user_subscription_updates_aggregate: Pending_User_Subscription_Updates_Aggregate;
  /** fetch data from the table: "pending_user_subscription_updates" using primary key columns */
  pending_user_subscription_updates_by_pk?: Maybe<Pending_User_Subscription_Updates>;
  /** fetch data from the table: "popular_dashboard_tags" */
  popular_dashboard_tags: Array<Popular_Dashboard_Tags>;
  /** fetch aggregated fields from the table: "popular_dashboard_tags" */
  popular_dashboard_tags_aggregate: Popular_Dashboard_Tags_Aggregate;
  /** fetch data from the table: "popular_query_tags" */
  popular_query_tags: Array<Popular_Query_Tags>;
  /** fetch aggregated fields from the table: "popular_query_tags" */
  popular_query_tags_aggregate: Popular_Query_Tags_Aggregate;
  /** fetch data from the table: "pro_badge" */
  pro_badge: Array<Pro_Badge>;
  /** fetch aggregated fields from the table: "pro_badge" */
  pro_badge_aggregate: Pro_Badge_Aggregate;
  /** An array relationship */
  queries: Array<Queries>;
  /** An aggregate relationship */
  queries_aggregate: Queries_Aggregate;
  /** fetch data from the table: "queries" using primary key columns */
  queries_by_pk?: Maybe<Queries>;
  /** fetch data from the table: "query_details" */
  query_details: Array<Query_Details>;
  /** fetch aggregated fields from the table: "query_details" */
  query_details_aggregate: Query_Details_Aggregate;
  /** fetch data from the table: "query_errors" */
  query_errors: Array<Query_Errors>;
  /** fetch aggregated fields from the table: "query_errors" */
  query_errors_aggregate: Query_Errors_Aggregate;
  /** fetch data from the table: "query_errors" using primary key columns */
  query_errors_by_pk?: Maybe<Query_Errors>;
  /** fetch data from the table: "query_event_metadata" */
  query_event_metadata: Array<Query_Event_Metadata>;
  /** fetch aggregated fields from the table: "query_event_metadata" */
  query_event_metadata_aggregate: Query_Event_Metadata_Aggregate;
  /** fetch data from the table: "query_event_metadata" using primary key columns */
  query_event_metadata_by_pk?: Maybe<Query_Event_Metadata>;
  /** fetch data from the table: "query_event_types" */
  query_event_types: Array<Query_Event_Types>;
  /** fetch aggregated fields from the table: "query_event_types" */
  query_event_types_aggregate: Query_Event_Types_Aggregate;
  /** fetch data from the table: "query_event_types" using primary key columns */
  query_event_types_by_pk?: Maybe<Query_Event_Types>;
  /** fetch data from the table: "query_events" */
  query_events: Array<Query_Events>;
  /** fetch aggregated fields from the table: "query_events" */
  query_events_aggregate: Query_Events_Aggregate;
  /** fetch data from the table: "query_events" using primary key columns */
  query_events_by_pk?: Maybe<Query_Events>;
  /** fetch data from the table: "query_favorite_count_all" */
  query_favorite_count_all: Array<Query_Favorite_Count_All>;
  /** fetch aggregated fields from the table: "query_favorite_count_all" */
  query_favorite_count_all_aggregate: Query_Favorite_Count_All_Aggregate;
  /** fetch data from the table: "query_favorite_count_last_24h" */
  query_favorite_count_last_24h: Array<Query_Favorite_Count_Last_24h>;
  /** fetch aggregated fields from the table: "query_favorite_count_last_24h" */
  query_favorite_count_last_24h_aggregate: Query_Favorite_Count_Last_24h_Aggregate;
  /** fetch data from the table: "query_favorite_count_last_30d" */
  query_favorite_count_last_30d: Array<Query_Favorite_Count_Last_30d>;
  /** fetch aggregated fields from the table: "query_favorite_count_last_30d" */
  query_favorite_count_last_30d_aggregate: Query_Favorite_Count_Last_30d_Aggregate;
  /** fetch data from the table: "query_favorite_count_last_7d" */
  query_favorite_count_last_7d: Array<Query_Favorite_Count_Last_7d>;
  /** fetch aggregated fields from the table: "query_favorite_count_last_7d" */
  query_favorite_count_last_7d_aggregate: Query_Favorite_Count_Last_7d_Aggregate;
  /** fetch data from the table: "query_results" */
  query_results: Array<Query_Results>;
  /** fetch aggregated fields from the table: "query_results" */
  query_results_aggregate: Query_Results_Aggregate;
  /** fetch data from the table: "query_results" using primary key columns */
  query_results_by_pk?: Maybe<Query_Results>;
  query_schedules: QuerySchedulesResponse;
  search_contracts: SearchContractsResponse;
  stripe_default_card: StripeDefaultCardResponse;
  team_api_keys: ListTeamApiKeysResponse;
  team_billable_usage: TeamBillableUsageResponse;
  /** fetch data from the table: "team_members_details" */
  team_members_details: Array<Team_Members_Details>;
  /** fetch aggregated fields from the table: "team_members_details" */
  team_members_details_aggregate: Team_Members_Details_Aggregate;
  team_operation_costs: OperationCosts;
  /** fetch data from the table: "team_public" */
  team_public: Array<Team_Public>;
  /** fetch aggregated fields from the table: "team_public" */
  team_public_aggregate: Team_Public_Aggregate;
  /** fetch data from the table: "team_received_stars" */
  team_received_stars: Array<Team_Received_Stars>;
  /** fetch aggregated fields from the table: "team_received_stars" */
  team_received_stars_aggregate: Team_Received_Stars_Aggregate;
  /** fetch data from the table: "team_service_tiers" */
  team_service_tiers: Array<Team_Service_Tiers>;
  /** fetch aggregated fields from the table: "team_service_tiers" */
  team_service_tiers_aggregate: Team_Service_Tiers_Aggregate;
  /** fetch data from the table: "team_service_tiers" using primary key columns */
  team_service_tiers_by_pk?: Maybe<Team_Service_Tiers>;
  team_stripe_default_card: TeamStripeDefaultCardResponse;
  /** An array relationship */
  teams: Array<Teams>;
  /** An aggregate relationship */
  teams_aggregate: Teams_Aggregate;
  /** fetch data from the table: "teams" using primary key columns */
  teams_by_pk?: Maybe<Teams>;
  /** An array relationship */
  text_widgets: Array<Text_Widgets>;
  /** An aggregate relationship */
  text_widgets_aggregate: Text_Widgets_Aggregate;
  /** fetch data from the table: "text_widgets" using primary key columns */
  text_widgets_by_pk?: Maybe<Text_Widgets>;
  uploaded_tables: Array<UploadedTable>;
  user_api_keys: ListUserApiKeysResponse;
  /** fetch data from the table: "user_nonce" */
  user_nonce: Array<User_Nonce>;
  /** fetch aggregated fields from the table: "user_nonce" */
  user_nonce_aggregate: User_Nonce_Aggregate;
  /** fetch data from the table: "user_nonce" using primary key columns */
  user_nonce_by_pk?: Maybe<User_Nonce>;
  user_operation_costs: OperationCosts;
  /** fetch data from the table: "user_private" */
  user_private: Array<User_Private>;
  /** fetch aggregated fields from the table: "user_private" */
  user_private_aggregate: User_Private_Aggregate;
  /** fetch data from the table: "user_public" */
  user_public: Array<User_Public>;
  /** fetch aggregated fields from the table: "user_public" */
  user_public_aggregate: User_Public_Aggregate;
  /** fetch data from the table: "user_received_stars" */
  user_received_stars: Array<User_Received_Stars>;
  /** fetch aggregated fields from the table: "user_received_stars" */
  user_received_stars_aggregate: User_Received_Stars_Aggregate;
  /** fetch data from the table: "user_service_tiers" */
  user_service_tiers: Array<User_Service_Tiers>;
  /** fetch aggregated fields from the table: "user_service_tiers" */
  user_service_tiers_aggregate: User_Service_Tiers_Aggregate;
  /** fetch data from the table: "user_service_tiers" using primary key columns */
  user_service_tiers_by_pk?: Maybe<User_Service_Tiers>;
  /** An array relationship */
  users: Array<Users>;
  /** An aggregate relationship */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table: "view_queue_positions" */
  view_queue_positions: Array<View_Queue_Positions>;
  /** fetch aggregated fields from the table: "view_queue_positions" */
  view_queue_positions_aggregate: View_Queue_Positions_Aggregate;
  /** An array relationship */
  visualization_widgets: Array<Visualization_Widgets>;
  /** An aggregate relationship */
  visualization_widgets_aggregate: Visualization_Widgets_Aggregate;
  /** fetch data from the table: "visualization_widgets" using primary key columns */
  visualization_widgets_by_pk?: Maybe<Visualization_Widgets>;
  /** An array relationship */
  visualizations: Array<Visualizations>;
  /** An aggregate relationship */
  visualizations_aggregate: Visualizations_Aggregate;
  /** fetch data from the table: "visualizations" using primary key columns */
  visualizations_by_pk?: Maybe<Visualizations>;
  /** fetch data from the table: "wand_completions" */
  wand_completions: Array<Wand_Completions>;
  /** fetch aggregated fields from the table: "wand_completions" */
  wand_completions_aggregate: Wand_Completions_Aggregate;
  /** fetch data from the table: "wand_completions" using primary key columns */
  wand_completions_by_pk?: Maybe<Wand_Completions>;
};


export type Query_RootApi_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


export type Query_RootApi_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


export type Query_RootApi_Keys_By_PkArgs = {
  id: Scalars['String'];
};


export type Query_RootApi_User_Service_TiersArgs = {
  distinct_on?: Maybe<Array<Api_User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_User_Service_Tiers_Order_By>>;
  where?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
};


export type Query_RootApi_User_Service_Tiers_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_User_Service_Tiers_Order_By>>;
  where?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
};


export type Query_RootApi_User_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootArrakis_SchemasArgs = {
  distinct_on?: Maybe<Array<Arrakis_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arrakis_Schemas_Order_By>>;
  where?: Maybe<Arrakis_Schemas_Bool_Exp>;
};


export type Query_RootArrakis_Schemas_AggregateArgs = {
  distinct_on?: Maybe<Array<Arrakis_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arrakis_Schemas_Order_By>>;
  where?: Maybe<Arrakis_Schemas_Bool_Exp>;
};


export type Query_RootArrakis_Schemas_By_PkArgs = {
  id: Scalars['String'];
};


export type Query_RootBlockchain_SchemasArgs = {
  distinct_on?: Maybe<Array<Blockchain_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Blockchain_Schemas_Order_By>>;
  where?: Maybe<Blockchain_Schemas_Bool_Exp>;
};


export type Query_RootBlockchain_Schemas_AggregateArgs = {
  distinct_on?: Maybe<Array<Blockchain_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Blockchain_Schemas_Order_By>>;
  where?: Maybe<Blockchain_Schemas_Bool_Exp>;
};


export type Query_RootBlockchain_Schemas_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContract_SubmissionsArgs = {
  distinct_on?: Maybe<Array<Contract_Submissions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contract_Submissions_Order_By>>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};


export type Query_RootContract_Submissions_AggregateArgs = {
  distinct_on?: Maybe<Array<Contract_Submissions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contract_Submissions_Order_By>>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};


export type Query_RootContract_Submissions_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootDashboard_Favorite_Count_AllArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_All_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_All_Bool_Exp>;
};


export type Query_RootDashboard_Favorite_Count_All_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_All_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_All_Bool_Exp>;
};


export type Query_RootDashboard_Favorite_Count_Last_24hArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Query_RootDashboard_Favorite_Count_Last_24h_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Query_RootDashboard_Favorite_Count_Last_30dArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Query_RootDashboard_Favorite_Count_Last_30d_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Query_RootDashboard_Favorite_Count_Last_7dArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Query_RootDashboard_Favorite_Count_Last_7d_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Query_RootDashboard_SchedulesArgs = {
  dashboard_id: Scalars['Int'];
};


export type Query_RootDashboard_Trending_ScoresArgs = {
  distinct_on?: Maybe<Array<Dashboard_Trending_Scores_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Trending_Scores_Order_By>>;
  where?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
};


export type Query_RootDashboard_Trending_Scores_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Trending_Scores_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Trending_Scores_Order_By>>;
  where?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
};


export type Query_RootDashboard_Trending_Scores_By_PkArgs = {
  dashboard_id: Scalars['Int'];
};


export type Query_RootDashboardsArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


export type Query_RootDashboards_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


export type Query_RootDashboards_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootDatasetsArgs = {
  distinct_on?: Maybe<Array<Datasets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datasets_Order_By>>;
  where?: Maybe<Datasets_Bool_Exp>;
};


export type Query_RootDatasets_AggregateArgs = {
  distinct_on?: Maybe<Array<Datasets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datasets_Order_By>>;
  where?: Maybe<Datasets_Bool_Exp>;
};


export type Query_RootDatasets_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootExport_CsvArgs = {
  downloadFor?: Maybe<ContextOwner>;
  execution_id: Scalars['String'];
  parameters?: Maybe<Array<Parameter>>;
  query_id: Scalars['Int'];
};


export type Query_RootFavorite_DashboardsArgs = {
  distinct_on?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Dashboards_Order_By>>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};


export type Query_RootFavorite_Dashboards_AggregateArgs = {
  distinct_on?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Dashboards_Order_By>>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};


export type Query_RootFavorite_Dashboards_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootFavorite_QueriesArgs = {
  distinct_on?: Maybe<Array<Favorite_Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Queries_Order_By>>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};


export type Query_RootFavorite_Queries_AggregateArgs = {
  distinct_on?: Maybe<Array<Favorite_Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Queries_Order_By>>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};


export type Query_RootFavorite_Queries_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootFavourited_SchemasArgs = {
  distinct_on?: Maybe<Array<Favourited_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favourited_Schemas_Order_By>>;
  where?: Maybe<Favourited_Schemas_Bool_Exp>;
};


export type Query_RootFavourited_Schemas_AggregateArgs = {
  distinct_on?: Maybe<Array<Favourited_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favourited_Schemas_Order_By>>;
  where?: Maybe<Favourited_Schemas_Bool_Exp>;
};


export type Query_RootFavourited_Schemas_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGet_ExecutionArgs = {
  execution_id: Scalars['String'];
  parameters?: Maybe<Array<Parameter>>;
  query_id: Scalars['Int'];
};


export type Query_RootGet_Initial_Query_EventArgs = {
  query_id: Scalars['Int'];
};


export type Query_RootGet_Query_ContributorsArgs = {
  query_id: Scalars['Int'];
};


export type Query_RootGet_Query_EventArgs = {
  query_event_id: Scalars['String'];
};


export type Query_RootGet_Query_EventsArgs = {
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  query_id: Scalars['Int'];
};


export type Query_RootGet_Result_By_Job_IdArgs = {
  args: Get_Result_By_Job_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Query_RootGet_Result_By_Job_Id_AggregateArgs = {
  args: Get_Result_By_Job_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Query_RootGet_Result_By_Result_IdArgs = {
  args: Get_Result_By_Result_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Query_RootGet_Result_By_Result_Id_AggregateArgs = {
  args: Get_Result_By_Result_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Query_RootGet_Result_TemplateArgs = {
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Query_RootGet_Result_Template_AggregateArgs = {
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Query_RootGet_Result_V3Args = {
  parameters?: Maybe<Array<Parameter>>;
  query_id: Scalars['Int'];
};


export type Query_RootGet_Result_V4Args = {
  can_refresh: Scalars['Boolean'];
  parameters?: Maybe<Array<Parameter>>;
  query_id: Scalars['Int'];
};


export type Query_RootGet_Team_InvoicesArgs = {
  team_id: Scalars['Int'];
};


export type Query_RootGet_Team_Upcoming_InvoiceArgs = {
  team_id: Scalars['Int'];
};


export type Query_RootHandlesArgs = {
  distinct_on?: Maybe<Array<Handles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Handles_Order_By>>;
  where?: Maybe<Handles_Bool_Exp>;
};


export type Query_RootHandles_AggregateArgs = {
  distinct_on?: Maybe<Array<Handles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Handles_Order_By>>;
  where?: Maybe<Handles_Bool_Exp>;
};


export type Query_RootJobsArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};


export type Query_RootJobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};


export type Query_RootJobs_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootMembershipsArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


export type Query_RootMemberships_AggregateArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


export type Query_RootMemberships_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootMemberships_Private_DetailsArgs = {
  distinct_on?: Maybe<Array<Memberships_Private_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Private_Details_Order_By>>;
  where?: Maybe<Memberships_Private_Details_Bool_Exp>;
};


export type Query_RootMemberships_Private_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Memberships_Private_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Private_Details_Order_By>>;
  where?: Maybe<Memberships_Private_Details_Bool_Exp>;
};


export type Query_RootOnboarding_QuestionsArgs = {
  distinct_on?: Maybe<Array<Onboarding_Questions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Questions_Order_By>>;
  where?: Maybe<Onboarding_Questions_Bool_Exp>;
};


export type Query_RootOnboarding_Questions_AggregateArgs = {
  distinct_on?: Maybe<Array<Onboarding_Questions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Questions_Order_By>>;
  where?: Maybe<Onboarding_Questions_Bool_Exp>;
};


export type Query_RootOnboarding_Questions_By_PkArgs = {
  user_id: Scalars['Int'];
};


export type Query_RootOperation_CostsArgs = {
  distinct_on?: Maybe<Array<Operation_Costs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operation_Costs_Order_By>>;
  where?: Maybe<Operation_Costs_Bool_Exp>;
};


export type Query_RootOperation_Costs_AggregateArgs = {
  distinct_on?: Maybe<Array<Operation_Costs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operation_Costs_Order_By>>;
  where?: Maybe<Operation_Costs_Bool_Exp>;
};


export type Query_RootOperation_Costs_By_PkArgs = {
  key: Scalars['String'];
};


export type Query_RootParam_WidgetsArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


export type Query_RootParam_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


export type Query_RootParam_Widgets_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPending_Api_User_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Api_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};


export type Query_RootPending_Api_User_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Api_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};


export type Query_RootPending_Api_User_Subscription_Updates_By_PkArgs = {
  user_id: Scalars['Int'];
};


export type Query_RootPending_Team_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Team_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};


export type Query_RootPending_Team_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Team_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};


export type Query_RootPending_Team_Subscription_Updates_By_PkArgs = {
  team_id: Scalars['Int'];
};


export type Query_RootPending_User_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};


export type Query_RootPending_User_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};


export type Query_RootPending_User_Subscription_Updates_By_PkArgs = {
  user_id: Scalars['Int'];
};


export type Query_RootPopular_Dashboard_TagsArgs = {
  distinct_on?: Maybe<Array<Popular_Dashboard_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Dashboard_Tags_Order_By>>;
  where?: Maybe<Popular_Dashboard_Tags_Bool_Exp>;
};


export type Query_RootPopular_Dashboard_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Popular_Dashboard_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Dashboard_Tags_Order_By>>;
  where?: Maybe<Popular_Dashboard_Tags_Bool_Exp>;
};


export type Query_RootPopular_Query_TagsArgs = {
  distinct_on?: Maybe<Array<Popular_Query_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Query_Tags_Order_By>>;
  where?: Maybe<Popular_Query_Tags_Bool_Exp>;
};


export type Query_RootPopular_Query_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Popular_Query_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Query_Tags_Order_By>>;
  where?: Maybe<Popular_Query_Tags_Bool_Exp>;
};


export type Query_RootPro_BadgeArgs = {
  distinct_on?: Maybe<Array<Pro_Badge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_Badge_Order_By>>;
  where?: Maybe<Pro_Badge_Bool_Exp>;
};


export type Query_RootPro_Badge_AggregateArgs = {
  distinct_on?: Maybe<Array<Pro_Badge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_Badge_Order_By>>;
  where?: Maybe<Pro_Badge_Bool_Exp>;
};


export type Query_RootQueriesArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};


export type Query_RootQueries_AggregateArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};


export type Query_RootQueries_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootQuery_DetailsArgs = {
  distinct_on?: Maybe<Array<Query_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Details_Order_By>>;
  where?: Maybe<Query_Details_Bool_Exp>;
};


export type Query_RootQuery_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Details_Order_By>>;
  where?: Maybe<Query_Details_Bool_Exp>;
};


export type Query_RootQuery_ErrorsArgs = {
  distinct_on?: Maybe<Array<Query_Errors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Errors_Order_By>>;
  where?: Maybe<Query_Errors_Bool_Exp>;
};


export type Query_RootQuery_Errors_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Errors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Errors_Order_By>>;
  where?: Maybe<Query_Errors_Bool_Exp>;
};


export type Query_RootQuery_Errors_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootQuery_Event_MetadataArgs = {
  distinct_on?: Maybe<Array<Query_Event_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Metadata_Order_By>>;
  where?: Maybe<Query_Event_Metadata_Bool_Exp>;
};


export type Query_RootQuery_Event_Metadata_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Event_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Metadata_Order_By>>;
  where?: Maybe<Query_Event_Metadata_Bool_Exp>;
};


export type Query_RootQuery_Event_Metadata_By_PkArgs = {
  query_event_id: Scalars['bpchar'];
};


export type Query_RootQuery_Event_TypesArgs = {
  distinct_on?: Maybe<Array<Query_Event_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Types_Order_By>>;
  where?: Maybe<Query_Event_Types_Bool_Exp>;
};


export type Query_RootQuery_Event_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Event_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Types_Order_By>>;
  where?: Maybe<Query_Event_Types_Bool_Exp>;
};


export type Query_RootQuery_Event_Types_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootQuery_EventsArgs = {
  distinct_on?: Maybe<Array<Query_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Events_Order_By>>;
  where?: Maybe<Query_Events_Bool_Exp>;
};


export type Query_RootQuery_Events_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Events_Order_By>>;
  where?: Maybe<Query_Events_Bool_Exp>;
};


export type Query_RootQuery_Events_By_PkArgs = {
  id: Scalars['bpchar'];
};


export type Query_RootQuery_Favorite_Count_AllArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_All_Order_By>>;
  where?: Maybe<Query_Favorite_Count_All_Bool_Exp>;
};


export type Query_RootQuery_Favorite_Count_All_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_All_Order_By>>;
  where?: Maybe<Query_Favorite_Count_All_Bool_Exp>;
};


export type Query_RootQuery_Favorite_Count_Last_24hArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Query_RootQuery_Favorite_Count_Last_24h_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Query_RootQuery_Favorite_Count_Last_30dArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Query_RootQuery_Favorite_Count_Last_30d_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Query_RootQuery_Favorite_Count_Last_7dArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Query_RootQuery_Favorite_Count_Last_7d_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Query_RootQuery_ResultsArgs = {
  distinct_on?: Maybe<Array<Query_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Results_Order_By>>;
  where?: Maybe<Query_Results_Bool_Exp>;
};


export type Query_RootQuery_Results_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Results_Order_By>>;
  where?: Maybe<Query_Results_Bool_Exp>;
};


export type Query_RootQuery_Results_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootQuery_SchedulesArgs = {
  query_id: Scalars['Int'];
};


export type Query_RootSearch_ContractsArgs = {
  contract_address: Scalars['String'];
};


export type Query_RootTeam_Api_KeysArgs = {
  team_id: Scalars['Int'];
};


export type Query_RootTeam_Billable_UsageArgs = {
  team_id: Scalars['Int'];
};


export type Query_RootTeam_Members_DetailsArgs = {
  distinct_on?: Maybe<Array<Team_Members_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Members_Details_Order_By>>;
  where?: Maybe<Team_Members_Details_Bool_Exp>;
};


export type Query_RootTeam_Members_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Members_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Members_Details_Order_By>>;
  where?: Maybe<Team_Members_Details_Bool_Exp>;
};


export type Query_RootTeam_Operation_CostsArgs = {
  team_id: Scalars['Int'];
};


export type Query_RootTeam_PublicArgs = {
  distinct_on?: Maybe<Array<Team_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Public_Order_By>>;
  where?: Maybe<Team_Public_Bool_Exp>;
};


export type Query_RootTeam_Public_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Public_Order_By>>;
  where?: Maybe<Team_Public_Bool_Exp>;
};


export type Query_RootTeam_Received_StarsArgs = {
  distinct_on?: Maybe<Array<Team_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Received_Stars_Order_By>>;
  where?: Maybe<Team_Received_Stars_Bool_Exp>;
};


export type Query_RootTeam_Received_Stars_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Received_Stars_Order_By>>;
  where?: Maybe<Team_Received_Stars_Bool_Exp>;
};


export type Query_RootTeam_Service_TiersArgs = {
  distinct_on?: Maybe<Array<Team_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Service_Tiers_Order_By>>;
  where?: Maybe<Team_Service_Tiers_Bool_Exp>;
};


export type Query_RootTeam_Service_Tiers_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Service_Tiers_Order_By>>;
  where?: Maybe<Team_Service_Tiers_Bool_Exp>;
};


export type Query_RootTeam_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootTeam_Stripe_Default_CardArgs = {
  team_id: Scalars['Int'];
};


export type Query_RootTeamsArgs = {
  distinct_on?: Maybe<Array<Teams_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Teams_Order_By>>;
  where?: Maybe<Teams_Bool_Exp>;
};


export type Query_RootTeams_AggregateArgs = {
  distinct_on?: Maybe<Array<Teams_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Teams_Order_By>>;
  where?: Maybe<Teams_Bool_Exp>;
};


export type Query_RootTeams_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootText_WidgetsArgs = {
  distinct_on?: Maybe<Array<Text_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Text_Widgets_Order_By>>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};


export type Query_RootText_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Text_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Text_Widgets_Order_By>>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};


export type Query_RootText_Widgets_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUser_NonceArgs = {
  distinct_on?: Maybe<Array<User_Nonce_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Nonce_Order_By>>;
  where?: Maybe<User_Nonce_Bool_Exp>;
};


export type Query_RootUser_Nonce_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Nonce_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Nonce_Order_By>>;
  where?: Maybe<User_Nonce_Bool_Exp>;
};


export type Query_RootUser_Nonce_By_PkArgs = {
  ethereum_address: Scalars['String'];
};


export type Query_RootUser_PrivateArgs = {
  distinct_on?: Maybe<Array<User_Private_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Private_Order_By>>;
  where?: Maybe<User_Private_Bool_Exp>;
};


export type Query_RootUser_Private_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Private_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Private_Order_By>>;
  where?: Maybe<User_Private_Bool_Exp>;
};


export type Query_RootUser_PublicArgs = {
  distinct_on?: Maybe<Array<User_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Public_Order_By>>;
  where?: Maybe<User_Public_Bool_Exp>;
};


export type Query_RootUser_Public_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Public_Order_By>>;
  where?: Maybe<User_Public_Bool_Exp>;
};


export type Query_RootUser_Received_StarsArgs = {
  distinct_on?: Maybe<Array<User_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Received_Stars_Order_By>>;
  where?: Maybe<User_Received_Stars_Bool_Exp>;
};


export type Query_RootUser_Received_Stars_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Received_Stars_Order_By>>;
  where?: Maybe<User_Received_Stars_Bool_Exp>;
};


export type Query_RootUser_Service_TiersArgs = {
  distinct_on?: Maybe<Array<User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Service_Tiers_Order_By>>;
  where?: Maybe<User_Service_Tiers_Bool_Exp>;
};


export type Query_RootUser_Service_Tiers_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Service_Tiers_Order_By>>;
  where?: Maybe<User_Service_Tiers_Bool_Exp>;
};


export type Query_RootUser_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Query_RootUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Query_RootUsers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootView_Queue_PositionsArgs = {
  distinct_on?: Maybe<Array<View_Queue_Positions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<View_Queue_Positions_Order_By>>;
  where?: Maybe<View_Queue_Positions_Bool_Exp>;
};


export type Query_RootView_Queue_Positions_AggregateArgs = {
  distinct_on?: Maybe<Array<View_Queue_Positions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<View_Queue_Positions_Order_By>>;
  where?: Maybe<View_Queue_Positions_Bool_Exp>;
};


export type Query_RootVisualization_WidgetsArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};


export type Query_RootVisualization_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};


export type Query_RootVisualization_Widgets_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootVisualizationsArgs = {
  distinct_on?: Maybe<Array<Visualizations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualizations_Order_By>>;
  where?: Maybe<Visualizations_Bool_Exp>;
};


export type Query_RootVisualizations_AggregateArgs = {
  distinct_on?: Maybe<Array<Visualizations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualizations_Order_By>>;
  where?: Maybe<Visualizations_Bool_Exp>;
};


export type Query_RootVisualizations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootWand_CompletionsArgs = {
  distinct_on?: Maybe<Array<Wand_Completions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Wand_Completions_Order_By>>;
  where?: Maybe<Wand_Completions_Bool_Exp>;
};


export type Query_RootWand_Completions_AggregateArgs = {
  distinct_on?: Maybe<Array<Wand_Completions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Wand_Completions_Order_By>>;
  where?: Maybe<Wand_Completions_Bool_Exp>;
};


export type Query_RootWand_Completions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type Smallint_Comparison_Exp = {
  _eq?: Maybe<Scalars['smallint']>;
  _gt?: Maybe<Scalars['smallint']>;
  _gte?: Maybe<Scalars['smallint']>;
  _in?: Maybe<Array<Scalars['smallint']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['smallint']>;
  _lte?: Maybe<Scalars['smallint']>;
  _neq?: Maybe<Scalars['smallint']>;
  _nin?: Maybe<Array<Scalars['smallint']>>;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** An array relationship */
  api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  api_keys_aggregate: Api_Keys_Aggregate;
  /** fetch data from the table: "api_keys" using primary key columns */
  api_keys_by_pk?: Maybe<Api_Keys>;
  /** fetch data from the table in a streaming manner: "api_keys" */
  api_keys_stream: Array<Api_Keys>;
  /** fetch data from the table: "api_user_service_tiers" */
  api_user_service_tiers: Array<Api_User_Service_Tiers>;
  /** fetch aggregated fields from the table: "api_user_service_tiers" */
  api_user_service_tiers_aggregate: Api_User_Service_Tiers_Aggregate;
  /** fetch data from the table: "api_user_service_tiers" using primary key columns */
  api_user_service_tiers_by_pk?: Maybe<Api_User_Service_Tiers>;
  /** fetch data from the table in a streaming manner: "api_user_service_tiers" */
  api_user_service_tiers_stream: Array<Api_User_Service_Tiers>;
  /** fetch data from the table: "arrakis_schemas" */
  arrakis_schemas: Array<Arrakis_Schemas>;
  /** fetch aggregated fields from the table: "arrakis_schemas" */
  arrakis_schemas_aggregate: Arrakis_Schemas_Aggregate;
  /** fetch data from the table: "arrakis_schemas" using primary key columns */
  arrakis_schemas_by_pk?: Maybe<Arrakis_Schemas>;
  /** fetch data from the table in a streaming manner: "arrakis_schemas" */
  arrakis_schemas_stream: Array<Arrakis_Schemas>;
  /** fetch data from the table: "blockchain_schemas" */
  blockchain_schemas: Array<Blockchain_Schemas>;
  /** fetch aggregated fields from the table: "blockchain_schemas" */
  blockchain_schemas_aggregate: Blockchain_Schemas_Aggregate;
  /** fetch data from the table: "blockchain_schemas" using primary key columns */
  blockchain_schemas_by_pk?: Maybe<Blockchain_Schemas>;
  /** fetch data from the table in a streaming manner: "blockchain_schemas" */
  blockchain_schemas_stream: Array<Blockchain_Schemas>;
  /** An array relationship */
  contract_submissions: Array<Contract_Submissions>;
  /** An aggregate relationship */
  contract_submissions_aggregate: Contract_Submissions_Aggregate;
  /** fetch data from the table: "contract_submissions" using primary key columns */
  contract_submissions_by_pk?: Maybe<Contract_Submissions>;
  /** fetch data from the table in a streaming manner: "contract_submissions" */
  contract_submissions_stream: Array<Contract_Submissions>;
  /** fetch data from the table: "dashboard_favorite_count_all" */
  dashboard_favorite_count_all: Array<Dashboard_Favorite_Count_All>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_all" */
  dashboard_favorite_count_all_aggregate: Dashboard_Favorite_Count_All_Aggregate;
  /** fetch data from the table in a streaming manner: "dashboard_favorite_count_all" */
  dashboard_favorite_count_all_stream: Array<Dashboard_Favorite_Count_All>;
  /** fetch data from the table: "dashboard_favorite_count_last_24h" */
  dashboard_favorite_count_last_24h: Array<Dashboard_Favorite_Count_Last_24h>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_last_24h" */
  dashboard_favorite_count_last_24h_aggregate: Dashboard_Favorite_Count_Last_24h_Aggregate;
  /** fetch data from the table in a streaming manner: "dashboard_favorite_count_last_24h" */
  dashboard_favorite_count_last_24h_stream: Array<Dashboard_Favorite_Count_Last_24h>;
  /** fetch data from the table: "dashboard_favorite_count_last_30d" */
  dashboard_favorite_count_last_30d: Array<Dashboard_Favorite_Count_Last_30d>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_last_30d" */
  dashboard_favorite_count_last_30d_aggregate: Dashboard_Favorite_Count_Last_30d_Aggregate;
  /** fetch data from the table in a streaming manner: "dashboard_favorite_count_last_30d" */
  dashboard_favorite_count_last_30d_stream: Array<Dashboard_Favorite_Count_Last_30d>;
  /** fetch data from the table: "dashboard_favorite_count_last_7d" */
  dashboard_favorite_count_last_7d: Array<Dashboard_Favorite_Count_Last_7d>;
  /** fetch aggregated fields from the table: "dashboard_favorite_count_last_7d" */
  dashboard_favorite_count_last_7d_aggregate: Dashboard_Favorite_Count_Last_7d_Aggregate;
  /** fetch data from the table in a streaming manner: "dashboard_favorite_count_last_7d" */
  dashboard_favorite_count_last_7d_stream: Array<Dashboard_Favorite_Count_Last_7d>;
  /** fetch data from the table: "dashboard_trending_scores" */
  dashboard_trending_scores: Array<Dashboard_Trending_Scores>;
  /** fetch aggregated fields from the table: "dashboard_trending_scores" */
  dashboard_trending_scores_aggregate: Dashboard_Trending_Scores_Aggregate;
  /** fetch data from the table: "dashboard_trending_scores" using primary key columns */
  dashboard_trending_scores_by_pk?: Maybe<Dashboard_Trending_Scores>;
  /** fetch data from the table in a streaming manner: "dashboard_trending_scores" */
  dashboard_trending_scores_stream: Array<Dashboard_Trending_Scores>;
  /** An array relationship */
  dashboards: Array<Dashboards>;
  /** An aggregate relationship */
  dashboards_aggregate: Dashboards_Aggregate;
  /** fetch data from the table: "dashboards" using primary key columns */
  dashboards_by_pk?: Maybe<Dashboards>;
  /** fetch data from the table in a streaming manner: "dashboards" */
  dashboards_stream: Array<Dashboards>;
  /** fetch data from the table: "datasets" */
  datasets: Array<Datasets>;
  /** fetch aggregated fields from the table: "datasets" */
  datasets_aggregate: Datasets_Aggregate;
  /** fetch data from the table: "datasets" using primary key columns */
  datasets_by_pk?: Maybe<Datasets>;
  /** fetch data from the table in a streaming manner: "datasets" */
  datasets_stream: Array<Datasets>;
  /** An array relationship */
  favorite_dashboards: Array<Favorite_Dashboards>;
  /** An aggregate relationship */
  favorite_dashboards_aggregate: Favorite_Dashboards_Aggregate;
  /** fetch data from the table: "favorite_dashboards" using primary key columns */
  favorite_dashboards_by_pk?: Maybe<Favorite_Dashboards>;
  /** fetch data from the table in a streaming manner: "favorite_dashboards" */
  favorite_dashboards_stream: Array<Favorite_Dashboards>;
  /** An array relationship */
  favorite_queries: Array<Favorite_Queries>;
  /** An aggregate relationship */
  favorite_queries_aggregate: Favorite_Queries_Aggregate;
  /** fetch data from the table: "favorite_queries" using primary key columns */
  favorite_queries_by_pk?: Maybe<Favorite_Queries>;
  /** fetch data from the table in a streaming manner: "favorite_queries" */
  favorite_queries_stream: Array<Favorite_Queries>;
  /** fetch data from the table: "favourited_schemas" */
  favourited_schemas: Array<Favourited_Schemas>;
  /** fetch aggregated fields from the table: "favourited_schemas" */
  favourited_schemas_aggregate: Favourited_Schemas_Aggregate;
  /** fetch data from the table: "favourited_schemas" using primary key columns */
  favourited_schemas_by_pk?: Maybe<Favourited_Schemas>;
  /** fetch data from the table in a streaming manner: "favourited_schemas" */
  favourited_schemas_stream: Array<Favourited_Schemas>;
  /** execute function "get_result_by_job_id" which returns "get_result_template" */
  get_result_by_job_id: Array<Get_Result_Template>;
  /** execute function "get_result_by_job_id" and query aggregates on result of table type "get_result_template" */
  get_result_by_job_id_aggregate: Get_Result_Template_Aggregate;
  /** execute function "get_result_by_result_id" which returns "get_result_template" */
  get_result_by_result_id: Array<Get_Result_Template>;
  /** execute function "get_result_by_result_id" and query aggregates on result of table type "get_result_template" */
  get_result_by_result_id_aggregate: Get_Result_Template_Aggregate;
  /** fetch data from the table: "get_result_template" */
  get_result_template: Array<Get_Result_Template>;
  /** fetch aggregated fields from the table: "get_result_template" */
  get_result_template_aggregate: Get_Result_Template_Aggregate;
  /** fetch data from the table in a streaming manner: "get_result_template" */
  get_result_template_stream: Array<Get_Result_Template>;
  /** fetch data from the table: "handles" */
  handles: Array<Handles>;
  /** fetch aggregated fields from the table: "handles" */
  handles_aggregate: Handles_Aggregate;
  /** fetch data from the table in a streaming manner: "handles" */
  handles_stream: Array<Handles>;
  /** fetch data from the table: "jobs" */
  jobs: Array<Jobs>;
  /** fetch aggregated fields from the table: "jobs" */
  jobs_aggregate: Jobs_Aggregate;
  /** fetch data from the table: "jobs" using primary key columns */
  jobs_by_pk?: Maybe<Jobs>;
  /** fetch data from the table in a streaming manner: "jobs" */
  jobs_stream: Array<Jobs>;
  /** An array relationship */
  memberships: Array<Memberships>;
  /** An aggregate relationship */
  memberships_aggregate: Memberships_Aggregate;
  /** fetch data from the table: "memberships" using primary key columns */
  memberships_by_pk?: Maybe<Memberships>;
  /** fetch data from the table: "memberships_private_details" */
  memberships_private_details: Array<Memberships_Private_Details>;
  /** fetch aggregated fields from the table: "memberships_private_details" */
  memberships_private_details_aggregate: Memberships_Private_Details_Aggregate;
  /** fetch data from the table in a streaming manner: "memberships_private_details" */
  memberships_private_details_stream: Array<Memberships_Private_Details>;
  /** fetch data from the table in a streaming manner: "memberships" */
  memberships_stream: Array<Memberships>;
  /** fetch data from the table: "onboarding_questions" */
  onboarding_questions: Array<Onboarding_Questions>;
  /** fetch aggregated fields from the table: "onboarding_questions" */
  onboarding_questions_aggregate: Onboarding_Questions_Aggregate;
  /** fetch data from the table: "onboarding_questions" using primary key columns */
  onboarding_questions_by_pk?: Maybe<Onboarding_Questions>;
  /** fetch data from the table in a streaming manner: "onboarding_questions" */
  onboarding_questions_stream: Array<Onboarding_Questions>;
  /** fetch data from the table: "operation_costs" */
  operation_costs: Array<Operation_Costs>;
  /** fetch aggregated fields from the table: "operation_costs" */
  operation_costs_aggregate: Operation_Costs_Aggregate;
  /** fetch data from the table: "operation_costs" using primary key columns */
  operation_costs_by_pk?: Maybe<Operation_Costs>;
  /** fetch data from the table in a streaming manner: "operation_costs" */
  operation_costs_stream: Array<Operation_Costs>;
  /** An array relationship */
  param_widgets: Array<Param_Widgets>;
  /** An aggregate relationship */
  param_widgets_aggregate: Param_Widgets_Aggregate;
  /** fetch data from the table: "param_widgets" using primary key columns */
  param_widgets_by_pk?: Maybe<Param_Widgets>;
  /** fetch data from the table in a streaming manner: "param_widgets" */
  param_widgets_stream: Array<Param_Widgets>;
  /** An array relationship */
  pending_api_user_subscription_updates: Array<Pending_Api_User_Subscription_Updates>;
  /** An aggregate relationship */
  pending_api_user_subscription_updates_aggregate: Pending_Api_User_Subscription_Updates_Aggregate;
  /** fetch data from the table: "pending_api_user_subscription_updates" using primary key columns */
  pending_api_user_subscription_updates_by_pk?: Maybe<Pending_Api_User_Subscription_Updates>;
  /** fetch data from the table in a streaming manner: "pending_api_user_subscription_updates" */
  pending_api_user_subscription_updates_stream: Array<Pending_Api_User_Subscription_Updates>;
  /** An array relationship */
  pending_team_subscription_updates: Array<Pending_Team_Subscription_Updates>;
  /** An aggregate relationship */
  pending_team_subscription_updates_aggregate: Pending_Team_Subscription_Updates_Aggregate;
  /** fetch data from the table: "pending_team_subscription_updates" using primary key columns */
  pending_team_subscription_updates_by_pk?: Maybe<Pending_Team_Subscription_Updates>;
  /** fetch data from the table in a streaming manner: "pending_team_subscription_updates" */
  pending_team_subscription_updates_stream: Array<Pending_Team_Subscription_Updates>;
  /** An array relationship */
  pending_user_subscription_updates: Array<Pending_User_Subscription_Updates>;
  /** An aggregate relationship */
  pending_user_subscription_updates_aggregate: Pending_User_Subscription_Updates_Aggregate;
  /** fetch data from the table: "pending_user_subscription_updates" using primary key columns */
  pending_user_subscription_updates_by_pk?: Maybe<Pending_User_Subscription_Updates>;
  /** fetch data from the table in a streaming manner: "pending_user_subscription_updates" */
  pending_user_subscription_updates_stream: Array<Pending_User_Subscription_Updates>;
  /** fetch data from the table: "popular_dashboard_tags" */
  popular_dashboard_tags: Array<Popular_Dashboard_Tags>;
  /** fetch aggregated fields from the table: "popular_dashboard_tags" */
  popular_dashboard_tags_aggregate: Popular_Dashboard_Tags_Aggregate;
  /** fetch data from the table in a streaming manner: "popular_dashboard_tags" */
  popular_dashboard_tags_stream: Array<Popular_Dashboard_Tags>;
  /** fetch data from the table: "popular_query_tags" */
  popular_query_tags: Array<Popular_Query_Tags>;
  /** fetch aggregated fields from the table: "popular_query_tags" */
  popular_query_tags_aggregate: Popular_Query_Tags_Aggregate;
  /** fetch data from the table in a streaming manner: "popular_query_tags" */
  popular_query_tags_stream: Array<Popular_Query_Tags>;
  /** fetch data from the table: "pro_badge" */
  pro_badge: Array<Pro_Badge>;
  /** fetch aggregated fields from the table: "pro_badge" */
  pro_badge_aggregate: Pro_Badge_Aggregate;
  /** fetch data from the table in a streaming manner: "pro_badge" */
  pro_badge_stream: Array<Pro_Badge>;
  /** An array relationship */
  queries: Array<Queries>;
  /** An aggregate relationship */
  queries_aggregate: Queries_Aggregate;
  /** fetch data from the table: "queries" using primary key columns */
  queries_by_pk?: Maybe<Queries>;
  /** fetch data from the table in a streaming manner: "queries" */
  queries_stream: Array<Queries>;
  /** fetch data from the table: "query_details" */
  query_details: Array<Query_Details>;
  /** fetch aggregated fields from the table: "query_details" */
  query_details_aggregate: Query_Details_Aggregate;
  /** fetch data from the table in a streaming manner: "query_details" */
  query_details_stream: Array<Query_Details>;
  /** fetch data from the table: "query_errors" */
  query_errors: Array<Query_Errors>;
  /** fetch aggregated fields from the table: "query_errors" */
  query_errors_aggregate: Query_Errors_Aggregate;
  /** fetch data from the table: "query_errors" using primary key columns */
  query_errors_by_pk?: Maybe<Query_Errors>;
  /** fetch data from the table in a streaming manner: "query_errors" */
  query_errors_stream: Array<Query_Errors>;
  /** fetch data from the table: "query_event_metadata" */
  query_event_metadata: Array<Query_Event_Metadata>;
  /** fetch aggregated fields from the table: "query_event_metadata" */
  query_event_metadata_aggregate: Query_Event_Metadata_Aggregate;
  /** fetch data from the table: "query_event_metadata" using primary key columns */
  query_event_metadata_by_pk?: Maybe<Query_Event_Metadata>;
  /** fetch data from the table in a streaming manner: "query_event_metadata" */
  query_event_metadata_stream: Array<Query_Event_Metadata>;
  /** fetch data from the table: "query_event_types" */
  query_event_types: Array<Query_Event_Types>;
  /** fetch aggregated fields from the table: "query_event_types" */
  query_event_types_aggregate: Query_Event_Types_Aggregate;
  /** fetch data from the table: "query_event_types" using primary key columns */
  query_event_types_by_pk?: Maybe<Query_Event_Types>;
  /** fetch data from the table in a streaming manner: "query_event_types" */
  query_event_types_stream: Array<Query_Event_Types>;
  /** fetch data from the table: "query_events" */
  query_events: Array<Query_Events>;
  /** fetch aggregated fields from the table: "query_events" */
  query_events_aggregate: Query_Events_Aggregate;
  /** fetch data from the table: "query_events" using primary key columns */
  query_events_by_pk?: Maybe<Query_Events>;
  /** fetch data from the table in a streaming manner: "query_events" */
  query_events_stream: Array<Query_Events>;
  /** fetch data from the table: "query_favorite_count_all" */
  query_favorite_count_all: Array<Query_Favorite_Count_All>;
  /** fetch aggregated fields from the table: "query_favorite_count_all" */
  query_favorite_count_all_aggregate: Query_Favorite_Count_All_Aggregate;
  /** fetch data from the table in a streaming manner: "query_favorite_count_all" */
  query_favorite_count_all_stream: Array<Query_Favorite_Count_All>;
  /** fetch data from the table: "query_favorite_count_last_24h" */
  query_favorite_count_last_24h: Array<Query_Favorite_Count_Last_24h>;
  /** fetch aggregated fields from the table: "query_favorite_count_last_24h" */
  query_favorite_count_last_24h_aggregate: Query_Favorite_Count_Last_24h_Aggregate;
  /** fetch data from the table in a streaming manner: "query_favorite_count_last_24h" */
  query_favorite_count_last_24h_stream: Array<Query_Favorite_Count_Last_24h>;
  /** fetch data from the table: "query_favorite_count_last_30d" */
  query_favorite_count_last_30d: Array<Query_Favorite_Count_Last_30d>;
  /** fetch aggregated fields from the table: "query_favorite_count_last_30d" */
  query_favorite_count_last_30d_aggregate: Query_Favorite_Count_Last_30d_Aggregate;
  /** fetch data from the table in a streaming manner: "query_favorite_count_last_30d" */
  query_favorite_count_last_30d_stream: Array<Query_Favorite_Count_Last_30d>;
  /** fetch data from the table: "query_favorite_count_last_7d" */
  query_favorite_count_last_7d: Array<Query_Favorite_Count_Last_7d>;
  /** fetch aggregated fields from the table: "query_favorite_count_last_7d" */
  query_favorite_count_last_7d_aggregate: Query_Favorite_Count_Last_7d_Aggregate;
  /** fetch data from the table in a streaming manner: "query_favorite_count_last_7d" */
  query_favorite_count_last_7d_stream: Array<Query_Favorite_Count_Last_7d>;
  /** fetch data from the table: "query_results" */
  query_results: Array<Query_Results>;
  /** fetch aggregated fields from the table: "query_results" */
  query_results_aggregate: Query_Results_Aggregate;
  /** fetch data from the table: "query_results" using primary key columns */
  query_results_by_pk?: Maybe<Query_Results>;
  /** fetch data from the table in a streaming manner: "query_results" */
  query_results_stream: Array<Query_Results>;
  /** fetch data from the table: "team_members_details" */
  team_members_details: Array<Team_Members_Details>;
  /** fetch aggregated fields from the table: "team_members_details" */
  team_members_details_aggregate: Team_Members_Details_Aggregate;
  /** fetch data from the table in a streaming manner: "team_members_details" */
  team_members_details_stream: Array<Team_Members_Details>;
  /** fetch data from the table: "team_public" */
  team_public: Array<Team_Public>;
  /** fetch aggregated fields from the table: "team_public" */
  team_public_aggregate: Team_Public_Aggregate;
  /** fetch data from the table in a streaming manner: "team_public" */
  team_public_stream: Array<Team_Public>;
  /** fetch data from the table: "team_received_stars" */
  team_received_stars: Array<Team_Received_Stars>;
  /** fetch aggregated fields from the table: "team_received_stars" */
  team_received_stars_aggregate: Team_Received_Stars_Aggregate;
  /** fetch data from the table in a streaming manner: "team_received_stars" */
  team_received_stars_stream: Array<Team_Received_Stars>;
  /** fetch data from the table: "team_service_tiers" */
  team_service_tiers: Array<Team_Service_Tiers>;
  /** fetch aggregated fields from the table: "team_service_tiers" */
  team_service_tiers_aggregate: Team_Service_Tiers_Aggregate;
  /** fetch data from the table: "team_service_tiers" using primary key columns */
  team_service_tiers_by_pk?: Maybe<Team_Service_Tiers>;
  /** fetch data from the table in a streaming manner: "team_service_tiers" */
  team_service_tiers_stream: Array<Team_Service_Tiers>;
  /** An array relationship */
  teams: Array<Teams>;
  /** An aggregate relationship */
  teams_aggregate: Teams_Aggregate;
  /** fetch data from the table: "teams" using primary key columns */
  teams_by_pk?: Maybe<Teams>;
  /** fetch data from the table in a streaming manner: "teams" */
  teams_stream: Array<Teams>;
  /** An array relationship */
  text_widgets: Array<Text_Widgets>;
  /** An aggregate relationship */
  text_widgets_aggregate: Text_Widgets_Aggregate;
  /** fetch data from the table: "text_widgets" using primary key columns */
  text_widgets_by_pk?: Maybe<Text_Widgets>;
  /** fetch data from the table in a streaming manner: "text_widgets" */
  text_widgets_stream: Array<Text_Widgets>;
  /** fetch data from the table: "user_nonce" */
  user_nonce: Array<User_Nonce>;
  /** fetch aggregated fields from the table: "user_nonce" */
  user_nonce_aggregate: User_Nonce_Aggregate;
  /** fetch data from the table: "user_nonce" using primary key columns */
  user_nonce_by_pk?: Maybe<User_Nonce>;
  /** fetch data from the table in a streaming manner: "user_nonce" */
  user_nonce_stream: Array<User_Nonce>;
  /** fetch data from the table: "user_private" */
  user_private: Array<User_Private>;
  /** fetch aggregated fields from the table: "user_private" */
  user_private_aggregate: User_Private_Aggregate;
  /** fetch data from the table in a streaming manner: "user_private" */
  user_private_stream: Array<User_Private>;
  /** fetch data from the table: "user_public" */
  user_public: Array<User_Public>;
  /** fetch aggregated fields from the table: "user_public" */
  user_public_aggregate: User_Public_Aggregate;
  /** fetch data from the table in a streaming manner: "user_public" */
  user_public_stream: Array<User_Public>;
  /** fetch data from the table: "user_received_stars" */
  user_received_stars: Array<User_Received_Stars>;
  /** fetch aggregated fields from the table: "user_received_stars" */
  user_received_stars_aggregate: User_Received_Stars_Aggregate;
  /** fetch data from the table in a streaming manner: "user_received_stars" */
  user_received_stars_stream: Array<User_Received_Stars>;
  /** fetch data from the table: "user_service_tiers" */
  user_service_tiers: Array<User_Service_Tiers>;
  /** fetch aggregated fields from the table: "user_service_tiers" */
  user_service_tiers_aggregate: User_Service_Tiers_Aggregate;
  /** fetch data from the table: "user_service_tiers" using primary key columns */
  user_service_tiers_by_pk?: Maybe<User_Service_Tiers>;
  /** fetch data from the table in a streaming manner: "user_service_tiers" */
  user_service_tiers_stream: Array<User_Service_Tiers>;
  /** An array relationship */
  users: Array<Users>;
  /** An aggregate relationship */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
  /** fetch data from the table: "view_queue_positions" */
  view_queue_positions: Array<View_Queue_Positions>;
  /** fetch aggregated fields from the table: "view_queue_positions" */
  view_queue_positions_aggregate: View_Queue_Positions_Aggregate;
  /** fetch data from the table in a streaming manner: "view_queue_positions" */
  view_queue_positions_stream: Array<View_Queue_Positions>;
  /** An array relationship */
  visualization_widgets: Array<Visualization_Widgets>;
  /** An aggregate relationship */
  visualization_widgets_aggregate: Visualization_Widgets_Aggregate;
  /** fetch data from the table: "visualization_widgets" using primary key columns */
  visualization_widgets_by_pk?: Maybe<Visualization_Widgets>;
  /** fetch data from the table in a streaming manner: "visualization_widgets" */
  visualization_widgets_stream: Array<Visualization_Widgets>;
  /** An array relationship */
  visualizations: Array<Visualizations>;
  /** An aggregate relationship */
  visualizations_aggregate: Visualizations_Aggregate;
  /** fetch data from the table: "visualizations" using primary key columns */
  visualizations_by_pk?: Maybe<Visualizations>;
  /** fetch data from the table in a streaming manner: "visualizations" */
  visualizations_stream: Array<Visualizations>;
  /** fetch data from the table: "wand_completions" */
  wand_completions: Array<Wand_Completions>;
  /** fetch aggregated fields from the table: "wand_completions" */
  wand_completions_aggregate: Wand_Completions_Aggregate;
  /** fetch data from the table: "wand_completions" using primary key columns */
  wand_completions_by_pk?: Maybe<Wand_Completions>;
  /** fetch data from the table in a streaming manner: "wand_completions" */
  wand_completions_stream: Array<Wand_Completions>;
};


export type Subscription_RootApi_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


export type Subscription_RootApi_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


export type Subscription_RootApi_Keys_By_PkArgs = {
  id: Scalars['String'];
};


export type Subscription_RootApi_Keys_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Api_Keys_Stream_Cursor_Input>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


export type Subscription_RootApi_User_Service_TiersArgs = {
  distinct_on?: Maybe<Array<Api_User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_User_Service_Tiers_Order_By>>;
  where?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootApi_User_Service_Tiers_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_User_Service_Tiers_Order_By>>;
  where?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootApi_User_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootApi_User_Service_Tiers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Api_User_Service_Tiers_Stream_Cursor_Input>>;
  where?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootArrakis_SchemasArgs = {
  distinct_on?: Maybe<Array<Arrakis_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arrakis_Schemas_Order_By>>;
  where?: Maybe<Arrakis_Schemas_Bool_Exp>;
};


export type Subscription_RootArrakis_Schemas_AggregateArgs = {
  distinct_on?: Maybe<Array<Arrakis_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arrakis_Schemas_Order_By>>;
  where?: Maybe<Arrakis_Schemas_Bool_Exp>;
};


export type Subscription_RootArrakis_Schemas_By_PkArgs = {
  id: Scalars['String'];
};


export type Subscription_RootArrakis_Schemas_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Arrakis_Schemas_Stream_Cursor_Input>>;
  where?: Maybe<Arrakis_Schemas_Bool_Exp>;
};


export type Subscription_RootBlockchain_SchemasArgs = {
  distinct_on?: Maybe<Array<Blockchain_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Blockchain_Schemas_Order_By>>;
  where?: Maybe<Blockchain_Schemas_Bool_Exp>;
};


export type Subscription_RootBlockchain_Schemas_AggregateArgs = {
  distinct_on?: Maybe<Array<Blockchain_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Blockchain_Schemas_Order_By>>;
  where?: Maybe<Blockchain_Schemas_Bool_Exp>;
};


export type Subscription_RootBlockchain_Schemas_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBlockchain_Schemas_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Blockchain_Schemas_Stream_Cursor_Input>>;
  where?: Maybe<Blockchain_Schemas_Bool_Exp>;
};


export type Subscription_RootContract_SubmissionsArgs = {
  distinct_on?: Maybe<Array<Contract_Submissions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contract_Submissions_Order_By>>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};


export type Subscription_RootContract_Submissions_AggregateArgs = {
  distinct_on?: Maybe<Array<Contract_Submissions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contract_Submissions_Order_By>>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};


export type Subscription_RootContract_Submissions_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContract_Submissions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Contract_Submissions_Stream_Cursor_Input>>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_AllArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_All_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_All_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_All_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_All_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_All_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_All_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dashboard_Favorite_Count_All_Stream_Cursor_Input>>;
  where?: Maybe<Dashboard_Favorite_Count_All_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_24hArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_24h_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_24h_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dashboard_Favorite_Count_Last_24h_Stream_Cursor_Input>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_30dArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_30d_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_30d_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dashboard_Favorite_Count_Last_30d_Stream_Cursor_Input>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_7dArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_7d_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Subscription_RootDashboard_Favorite_Count_Last_7d_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dashboard_Favorite_Count_Last_7d_Stream_Cursor_Input>>;
  where?: Maybe<Dashboard_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Subscription_RootDashboard_Trending_ScoresArgs = {
  distinct_on?: Maybe<Array<Dashboard_Trending_Scores_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Trending_Scores_Order_By>>;
  where?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
};


export type Subscription_RootDashboard_Trending_Scores_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboard_Trending_Scores_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboard_Trending_Scores_Order_By>>;
  where?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
};


export type Subscription_RootDashboard_Trending_Scores_By_PkArgs = {
  dashboard_id: Scalars['Int'];
};


export type Subscription_RootDashboard_Trending_Scores_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dashboard_Trending_Scores_Stream_Cursor_Input>>;
  where?: Maybe<Dashboard_Trending_Scores_Bool_Exp>;
};


export type Subscription_RootDashboardsArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


export type Subscription_RootDashboards_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


export type Subscription_RootDashboards_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootDashboards_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dashboards_Stream_Cursor_Input>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


export type Subscription_RootDatasetsArgs = {
  distinct_on?: Maybe<Array<Datasets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datasets_Order_By>>;
  where?: Maybe<Datasets_Bool_Exp>;
};


export type Subscription_RootDatasets_AggregateArgs = {
  distinct_on?: Maybe<Array<Datasets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datasets_Order_By>>;
  where?: Maybe<Datasets_Bool_Exp>;
};


export type Subscription_RootDatasets_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootDatasets_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Datasets_Stream_Cursor_Input>>;
  where?: Maybe<Datasets_Bool_Exp>;
};


export type Subscription_RootFavorite_DashboardsArgs = {
  distinct_on?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Dashboards_Order_By>>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};


export type Subscription_RootFavorite_Dashboards_AggregateArgs = {
  distinct_on?: Maybe<Array<Favorite_Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Dashboards_Order_By>>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};


export type Subscription_RootFavorite_Dashboards_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootFavorite_Dashboards_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Favorite_Dashboards_Stream_Cursor_Input>>;
  where?: Maybe<Favorite_Dashboards_Bool_Exp>;
};


export type Subscription_RootFavorite_QueriesArgs = {
  distinct_on?: Maybe<Array<Favorite_Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Queries_Order_By>>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};


export type Subscription_RootFavorite_Queries_AggregateArgs = {
  distinct_on?: Maybe<Array<Favorite_Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favorite_Queries_Order_By>>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};


export type Subscription_RootFavorite_Queries_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootFavorite_Queries_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Favorite_Queries_Stream_Cursor_Input>>;
  where?: Maybe<Favorite_Queries_Bool_Exp>;
};


export type Subscription_RootFavourited_SchemasArgs = {
  distinct_on?: Maybe<Array<Favourited_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favourited_Schemas_Order_By>>;
  where?: Maybe<Favourited_Schemas_Bool_Exp>;
};


export type Subscription_RootFavourited_Schemas_AggregateArgs = {
  distinct_on?: Maybe<Array<Favourited_Schemas_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Favourited_Schemas_Order_By>>;
  where?: Maybe<Favourited_Schemas_Bool_Exp>;
};


export type Subscription_RootFavourited_Schemas_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootFavourited_Schemas_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Favourited_Schemas_Stream_Cursor_Input>>;
  where?: Maybe<Favourited_Schemas_Bool_Exp>;
};


export type Subscription_RootGet_Result_By_Job_IdArgs = {
  args: Get_Result_By_Job_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Subscription_RootGet_Result_By_Job_Id_AggregateArgs = {
  args: Get_Result_By_Job_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Subscription_RootGet_Result_By_Result_IdArgs = {
  args: Get_Result_By_Result_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Subscription_RootGet_Result_By_Result_Id_AggregateArgs = {
  args: Get_Result_By_Result_Id_Args;
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Subscription_RootGet_Result_TemplateArgs = {
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Subscription_RootGet_Result_Template_AggregateArgs = {
  distinct_on?: Maybe<Array<Get_Result_Template_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Get_Result_Template_Order_By>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Subscription_RootGet_Result_Template_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Get_Result_Template_Stream_Cursor_Input>>;
  where?: Maybe<Get_Result_Template_Bool_Exp>;
};


export type Subscription_RootHandlesArgs = {
  distinct_on?: Maybe<Array<Handles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Handles_Order_By>>;
  where?: Maybe<Handles_Bool_Exp>;
};


export type Subscription_RootHandles_AggregateArgs = {
  distinct_on?: Maybe<Array<Handles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Handles_Order_By>>;
  where?: Maybe<Handles_Bool_Exp>;
};


export type Subscription_RootHandles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Handles_Stream_Cursor_Input>>;
  where?: Maybe<Handles_Bool_Exp>;
};


export type Subscription_RootJobsArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};


export type Subscription_RootJobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};


export type Subscription_RootJobs_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJobs_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Jobs_Stream_Cursor_Input>>;
  where?: Maybe<Jobs_Bool_Exp>;
};


export type Subscription_RootMembershipsArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


export type Subscription_RootMemberships_AggregateArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


export type Subscription_RootMemberships_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootMemberships_Private_DetailsArgs = {
  distinct_on?: Maybe<Array<Memberships_Private_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Private_Details_Order_By>>;
  where?: Maybe<Memberships_Private_Details_Bool_Exp>;
};


export type Subscription_RootMemberships_Private_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Memberships_Private_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Private_Details_Order_By>>;
  where?: Maybe<Memberships_Private_Details_Bool_Exp>;
};


export type Subscription_RootMemberships_Private_Details_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Memberships_Private_Details_Stream_Cursor_Input>>;
  where?: Maybe<Memberships_Private_Details_Bool_Exp>;
};


export type Subscription_RootMemberships_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Memberships_Stream_Cursor_Input>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


export type Subscription_RootOnboarding_QuestionsArgs = {
  distinct_on?: Maybe<Array<Onboarding_Questions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Questions_Order_By>>;
  where?: Maybe<Onboarding_Questions_Bool_Exp>;
};


export type Subscription_RootOnboarding_Questions_AggregateArgs = {
  distinct_on?: Maybe<Array<Onboarding_Questions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Questions_Order_By>>;
  where?: Maybe<Onboarding_Questions_Bool_Exp>;
};


export type Subscription_RootOnboarding_Questions_By_PkArgs = {
  user_id: Scalars['Int'];
};


export type Subscription_RootOnboarding_Questions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Onboarding_Questions_Stream_Cursor_Input>>;
  where?: Maybe<Onboarding_Questions_Bool_Exp>;
};


export type Subscription_RootOperation_CostsArgs = {
  distinct_on?: Maybe<Array<Operation_Costs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operation_Costs_Order_By>>;
  where?: Maybe<Operation_Costs_Bool_Exp>;
};


export type Subscription_RootOperation_Costs_AggregateArgs = {
  distinct_on?: Maybe<Array<Operation_Costs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operation_Costs_Order_By>>;
  where?: Maybe<Operation_Costs_Bool_Exp>;
};


export type Subscription_RootOperation_Costs_By_PkArgs = {
  key: Scalars['String'];
};


export type Subscription_RootOperation_Costs_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Operation_Costs_Stream_Cursor_Input>>;
  where?: Maybe<Operation_Costs_Bool_Exp>;
};


export type Subscription_RootParam_WidgetsArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


export type Subscription_RootParam_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


export type Subscription_RootParam_Widgets_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootParam_Widgets_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Param_Widgets_Stream_Cursor_Input>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


export type Subscription_RootPending_Api_User_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Api_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_Api_User_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_Api_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Api_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_Api_User_Subscription_Updates_By_PkArgs = {
  user_id: Scalars['Int'];
};


export type Subscription_RootPending_Api_User_Subscription_Updates_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Pending_Api_User_Subscription_Updates_Stream_Cursor_Input>>;
  where?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_Team_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Team_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_Team_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Team_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_Team_Subscription_Updates_By_PkArgs = {
  team_id: Scalars['Int'];
};


export type Subscription_RootPending_Team_Subscription_Updates_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Pending_Team_Subscription_Updates_Stream_Cursor_Input>>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_User_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_User_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPending_User_Subscription_Updates_By_PkArgs = {
  user_id: Scalars['Int'];
};


export type Subscription_RootPending_User_Subscription_Updates_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Pending_User_Subscription_Updates_Stream_Cursor_Input>>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};


export type Subscription_RootPopular_Dashboard_TagsArgs = {
  distinct_on?: Maybe<Array<Popular_Dashboard_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Dashboard_Tags_Order_By>>;
  where?: Maybe<Popular_Dashboard_Tags_Bool_Exp>;
};


export type Subscription_RootPopular_Dashboard_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Popular_Dashboard_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Dashboard_Tags_Order_By>>;
  where?: Maybe<Popular_Dashboard_Tags_Bool_Exp>;
};


export type Subscription_RootPopular_Dashboard_Tags_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Popular_Dashboard_Tags_Stream_Cursor_Input>>;
  where?: Maybe<Popular_Dashboard_Tags_Bool_Exp>;
};


export type Subscription_RootPopular_Query_TagsArgs = {
  distinct_on?: Maybe<Array<Popular_Query_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Query_Tags_Order_By>>;
  where?: Maybe<Popular_Query_Tags_Bool_Exp>;
};


export type Subscription_RootPopular_Query_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Popular_Query_Tags_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Popular_Query_Tags_Order_By>>;
  where?: Maybe<Popular_Query_Tags_Bool_Exp>;
};


export type Subscription_RootPopular_Query_Tags_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Popular_Query_Tags_Stream_Cursor_Input>>;
  where?: Maybe<Popular_Query_Tags_Bool_Exp>;
};


export type Subscription_RootPro_BadgeArgs = {
  distinct_on?: Maybe<Array<Pro_Badge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_Badge_Order_By>>;
  where?: Maybe<Pro_Badge_Bool_Exp>;
};


export type Subscription_RootPro_Badge_AggregateArgs = {
  distinct_on?: Maybe<Array<Pro_Badge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_Badge_Order_By>>;
  where?: Maybe<Pro_Badge_Bool_Exp>;
};


export type Subscription_RootPro_Badge_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Pro_Badge_Stream_Cursor_Input>>;
  where?: Maybe<Pro_Badge_Bool_Exp>;
};


export type Subscription_RootQueriesArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};


export type Subscription_RootQueries_AggregateArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};


export type Subscription_RootQueries_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootQueries_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Queries_Stream_Cursor_Input>>;
  where?: Maybe<Queries_Bool_Exp>;
};


export type Subscription_RootQuery_DetailsArgs = {
  distinct_on?: Maybe<Array<Query_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Details_Order_By>>;
  where?: Maybe<Query_Details_Bool_Exp>;
};


export type Subscription_RootQuery_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Details_Order_By>>;
  where?: Maybe<Query_Details_Bool_Exp>;
};


export type Subscription_RootQuery_Details_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Details_Stream_Cursor_Input>>;
  where?: Maybe<Query_Details_Bool_Exp>;
};


export type Subscription_RootQuery_ErrorsArgs = {
  distinct_on?: Maybe<Array<Query_Errors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Errors_Order_By>>;
  where?: Maybe<Query_Errors_Bool_Exp>;
};


export type Subscription_RootQuery_Errors_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Errors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Errors_Order_By>>;
  where?: Maybe<Query_Errors_Bool_Exp>;
};


export type Subscription_RootQuery_Errors_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootQuery_Errors_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Errors_Stream_Cursor_Input>>;
  where?: Maybe<Query_Errors_Bool_Exp>;
};


export type Subscription_RootQuery_Event_MetadataArgs = {
  distinct_on?: Maybe<Array<Query_Event_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Metadata_Order_By>>;
  where?: Maybe<Query_Event_Metadata_Bool_Exp>;
};


export type Subscription_RootQuery_Event_Metadata_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Event_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Metadata_Order_By>>;
  where?: Maybe<Query_Event_Metadata_Bool_Exp>;
};


export type Subscription_RootQuery_Event_Metadata_By_PkArgs = {
  query_event_id: Scalars['bpchar'];
};


export type Subscription_RootQuery_Event_Metadata_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Event_Metadata_Stream_Cursor_Input>>;
  where?: Maybe<Query_Event_Metadata_Bool_Exp>;
};


export type Subscription_RootQuery_Event_TypesArgs = {
  distinct_on?: Maybe<Array<Query_Event_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Types_Order_By>>;
  where?: Maybe<Query_Event_Types_Bool_Exp>;
};


export type Subscription_RootQuery_Event_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Event_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Event_Types_Order_By>>;
  where?: Maybe<Query_Event_Types_Bool_Exp>;
};


export type Subscription_RootQuery_Event_Types_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootQuery_Event_Types_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Event_Types_Stream_Cursor_Input>>;
  where?: Maybe<Query_Event_Types_Bool_Exp>;
};


export type Subscription_RootQuery_EventsArgs = {
  distinct_on?: Maybe<Array<Query_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Events_Order_By>>;
  where?: Maybe<Query_Events_Bool_Exp>;
};


export type Subscription_RootQuery_Events_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Events_Order_By>>;
  where?: Maybe<Query_Events_Bool_Exp>;
};


export type Subscription_RootQuery_Events_By_PkArgs = {
  id: Scalars['bpchar'];
};


export type Subscription_RootQuery_Events_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Events_Stream_Cursor_Input>>;
  where?: Maybe<Query_Events_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_AllArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_All_Order_By>>;
  where?: Maybe<Query_Favorite_Count_All_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_All_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_All_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_All_Order_By>>;
  where?: Maybe<Query_Favorite_Count_All_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_All_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Favorite_Count_All_Stream_Cursor_Input>>;
  where?: Maybe<Query_Favorite_Count_All_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_24hArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_24h_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_24h_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_24h_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_24h_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Favorite_Count_Last_24h_Stream_Cursor_Input>>;
  where?: Maybe<Query_Favorite_Count_Last_24h_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_30dArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_30d_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_30d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_30d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_30d_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Favorite_Count_Last_30d_Stream_Cursor_Input>>;
  where?: Maybe<Query_Favorite_Count_Last_30d_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_7dArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_7d_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Favorite_Count_Last_7d_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Favorite_Count_Last_7d_Order_By>>;
  where?: Maybe<Query_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Subscription_RootQuery_Favorite_Count_Last_7d_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Favorite_Count_Last_7d_Stream_Cursor_Input>>;
  where?: Maybe<Query_Favorite_Count_Last_7d_Bool_Exp>;
};


export type Subscription_RootQuery_ResultsArgs = {
  distinct_on?: Maybe<Array<Query_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Results_Order_By>>;
  where?: Maybe<Query_Results_Bool_Exp>;
};


export type Subscription_RootQuery_Results_AggregateArgs = {
  distinct_on?: Maybe<Array<Query_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Query_Results_Order_By>>;
  where?: Maybe<Query_Results_Bool_Exp>;
};


export type Subscription_RootQuery_Results_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootQuery_Results_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Query_Results_Stream_Cursor_Input>>;
  where?: Maybe<Query_Results_Bool_Exp>;
};


export type Subscription_RootTeam_Members_DetailsArgs = {
  distinct_on?: Maybe<Array<Team_Members_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Members_Details_Order_By>>;
  where?: Maybe<Team_Members_Details_Bool_Exp>;
};


export type Subscription_RootTeam_Members_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Members_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Members_Details_Order_By>>;
  where?: Maybe<Team_Members_Details_Bool_Exp>;
};


export type Subscription_RootTeam_Members_Details_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Team_Members_Details_Stream_Cursor_Input>>;
  where?: Maybe<Team_Members_Details_Bool_Exp>;
};


export type Subscription_RootTeam_PublicArgs = {
  distinct_on?: Maybe<Array<Team_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Public_Order_By>>;
  where?: Maybe<Team_Public_Bool_Exp>;
};


export type Subscription_RootTeam_Public_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Public_Order_By>>;
  where?: Maybe<Team_Public_Bool_Exp>;
};


export type Subscription_RootTeam_Public_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Team_Public_Stream_Cursor_Input>>;
  where?: Maybe<Team_Public_Bool_Exp>;
};


export type Subscription_RootTeam_Received_StarsArgs = {
  distinct_on?: Maybe<Array<Team_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Received_Stars_Order_By>>;
  where?: Maybe<Team_Received_Stars_Bool_Exp>;
};


export type Subscription_RootTeam_Received_Stars_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Received_Stars_Order_By>>;
  where?: Maybe<Team_Received_Stars_Bool_Exp>;
};


export type Subscription_RootTeam_Received_Stars_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Team_Received_Stars_Stream_Cursor_Input>>;
  where?: Maybe<Team_Received_Stars_Bool_Exp>;
};


export type Subscription_RootTeam_Service_TiersArgs = {
  distinct_on?: Maybe<Array<Team_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Service_Tiers_Order_By>>;
  where?: Maybe<Team_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootTeam_Service_Tiers_AggregateArgs = {
  distinct_on?: Maybe<Array<Team_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Team_Service_Tiers_Order_By>>;
  where?: Maybe<Team_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootTeam_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootTeam_Service_Tiers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Team_Service_Tiers_Stream_Cursor_Input>>;
  where?: Maybe<Team_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootTeamsArgs = {
  distinct_on?: Maybe<Array<Teams_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Teams_Order_By>>;
  where?: Maybe<Teams_Bool_Exp>;
};


export type Subscription_RootTeams_AggregateArgs = {
  distinct_on?: Maybe<Array<Teams_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Teams_Order_By>>;
  where?: Maybe<Teams_Bool_Exp>;
};


export type Subscription_RootTeams_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootTeams_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Teams_Stream_Cursor_Input>>;
  where?: Maybe<Teams_Bool_Exp>;
};


export type Subscription_RootText_WidgetsArgs = {
  distinct_on?: Maybe<Array<Text_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Text_Widgets_Order_By>>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};


export type Subscription_RootText_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Text_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Text_Widgets_Order_By>>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};


export type Subscription_RootText_Widgets_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootText_Widgets_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Text_Widgets_Stream_Cursor_Input>>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};


export type Subscription_RootUser_NonceArgs = {
  distinct_on?: Maybe<Array<User_Nonce_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Nonce_Order_By>>;
  where?: Maybe<User_Nonce_Bool_Exp>;
};


export type Subscription_RootUser_Nonce_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Nonce_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Nonce_Order_By>>;
  where?: Maybe<User_Nonce_Bool_Exp>;
};


export type Subscription_RootUser_Nonce_By_PkArgs = {
  ethereum_address: Scalars['String'];
};


export type Subscription_RootUser_Nonce_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Nonce_Stream_Cursor_Input>>;
  where?: Maybe<User_Nonce_Bool_Exp>;
};


export type Subscription_RootUser_PrivateArgs = {
  distinct_on?: Maybe<Array<User_Private_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Private_Order_By>>;
  where?: Maybe<User_Private_Bool_Exp>;
};


export type Subscription_RootUser_Private_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Private_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Private_Order_By>>;
  where?: Maybe<User_Private_Bool_Exp>;
};


export type Subscription_RootUser_Private_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Private_Stream_Cursor_Input>>;
  where?: Maybe<User_Private_Bool_Exp>;
};


export type Subscription_RootUser_PublicArgs = {
  distinct_on?: Maybe<Array<User_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Public_Order_By>>;
  where?: Maybe<User_Public_Bool_Exp>;
};


export type Subscription_RootUser_Public_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Public_Order_By>>;
  where?: Maybe<User_Public_Bool_Exp>;
};


export type Subscription_RootUser_Public_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Public_Stream_Cursor_Input>>;
  where?: Maybe<User_Public_Bool_Exp>;
};


export type Subscription_RootUser_Received_StarsArgs = {
  distinct_on?: Maybe<Array<User_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Received_Stars_Order_By>>;
  where?: Maybe<User_Received_Stars_Bool_Exp>;
};


export type Subscription_RootUser_Received_Stars_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Received_Stars_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Received_Stars_Order_By>>;
  where?: Maybe<User_Received_Stars_Bool_Exp>;
};


export type Subscription_RootUser_Received_Stars_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Received_Stars_Stream_Cursor_Input>>;
  where?: Maybe<User_Received_Stars_Bool_Exp>;
};


export type Subscription_RootUser_Service_TiersArgs = {
  distinct_on?: Maybe<Array<User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Service_Tiers_Order_By>>;
  where?: Maybe<User_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootUser_Service_Tiers_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Service_Tiers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Service_Tiers_Order_By>>;
  where?: Maybe<User_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootUser_Service_Tiers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUser_Service_Tiers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Service_Tiers_Stream_Cursor_Input>>;
  where?: Maybe<User_Service_Tiers_Bool_Exp>;
};


export type Subscription_RootUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Users_Stream_Cursor_Input>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Subscription_RootView_Queue_PositionsArgs = {
  distinct_on?: Maybe<Array<View_Queue_Positions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<View_Queue_Positions_Order_By>>;
  where?: Maybe<View_Queue_Positions_Bool_Exp>;
};


export type Subscription_RootView_Queue_Positions_AggregateArgs = {
  distinct_on?: Maybe<Array<View_Queue_Positions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<View_Queue_Positions_Order_By>>;
  where?: Maybe<View_Queue_Positions_Bool_Exp>;
};


export type Subscription_RootView_Queue_Positions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<View_Queue_Positions_Stream_Cursor_Input>>;
  where?: Maybe<View_Queue_Positions_Bool_Exp>;
};


export type Subscription_RootVisualization_WidgetsArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};


export type Subscription_RootVisualization_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};


export type Subscription_RootVisualization_Widgets_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootVisualization_Widgets_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Visualization_Widgets_Stream_Cursor_Input>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};


export type Subscription_RootVisualizationsArgs = {
  distinct_on?: Maybe<Array<Visualizations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualizations_Order_By>>;
  where?: Maybe<Visualizations_Bool_Exp>;
};


export type Subscription_RootVisualizations_AggregateArgs = {
  distinct_on?: Maybe<Array<Visualizations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualizations_Order_By>>;
  where?: Maybe<Visualizations_Bool_Exp>;
};


export type Subscription_RootVisualizations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootVisualizations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Visualizations_Stream_Cursor_Input>>;
  where?: Maybe<Visualizations_Bool_Exp>;
};


export type Subscription_RootWand_CompletionsArgs = {
  distinct_on?: Maybe<Array<Wand_Completions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Wand_Completions_Order_By>>;
  where?: Maybe<Wand_Completions_Bool_Exp>;
};


export type Subscription_RootWand_Completions_AggregateArgs = {
  distinct_on?: Maybe<Array<Wand_Completions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Wand_Completions_Order_By>>;
  where?: Maybe<Wand_Completions_Bool_Exp>;
};


export type Subscription_RootWand_Completions_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootWand_Completions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Wand_Completions_Stream_Cursor_Input>>;
  where?: Maybe<Wand_Completions_Bool_Exp>;
};

/** columns and relationships of "team_members_details" */
export type Team_Members_Details = {
  __typename?: 'team_members_details';
  created_at?: Maybe<Scalars['timestamptz']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  /** An object relationship */
  service_tier?: Maybe<Team_Service_Tiers>;
  service_tier_id?: Maybe<Scalars['Int']>;
  show_members?: Maybe<Scalars['Boolean']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  team?: Maybe<Teams>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "team_members_details" */
export type Team_Members_DetailsPermissionsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "team_members_details" */
export type Team_Members_Details_Aggregate = {
  __typename?: 'team_members_details_aggregate';
  aggregate?: Maybe<Team_Members_Details_Aggregate_Fields>;
  nodes: Array<Team_Members_Details>;
};

/** aggregate fields of "team_members_details" */
export type Team_Members_Details_Aggregate_Fields = {
  __typename?: 'team_members_details_aggregate_fields';
  avg?: Maybe<Team_Members_Details_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Team_Members_Details_Max_Fields>;
  min?: Maybe<Team_Members_Details_Min_Fields>;
  stddev?: Maybe<Team_Members_Details_Stddev_Fields>;
  stddev_pop?: Maybe<Team_Members_Details_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Team_Members_Details_Stddev_Samp_Fields>;
  sum?: Maybe<Team_Members_Details_Sum_Fields>;
  var_pop?: Maybe<Team_Members_Details_Var_Pop_Fields>;
  var_samp?: Maybe<Team_Members_Details_Var_Samp_Fields>;
  variance?: Maybe<Team_Members_Details_Variance_Fields>;
};


/** aggregate fields of "team_members_details" */
export type Team_Members_Details_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Team_Members_Details_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Team_Members_Details_Append_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Team_Members_Details_Avg_Fields = {
  __typename?: 'team_members_details_avg_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "team_members_details". All fields are combined with a logical 'AND'. */
export type Team_Members_Details_Bool_Exp = {
  _and?: Maybe<Array<Team_Members_Details_Bool_Exp>>;
  _not?: Maybe<Team_Members_Details_Bool_Exp>;
  _or?: Maybe<Array<Team_Members_Details_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  enable_pro_badge?: Maybe<Boolean_Comparison_Exp>;
  enable_service_tier_badge?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  is_pro?: Maybe<Boolean_Comparison_Exp>;
  max_datapoints_per_request?: Maybe<Int_Comparison_Exp>;
  max_executions_overage_cost_cents?: Maybe<Int_Comparison_Exp>;
  max_overage_cents?: Maybe<Numeric_Comparison_Exp>;
  num_parallel_queries?: Maybe<Smallint_Comparison_Exp>;
  permissions?: Maybe<Jsonb_Comparison_Exp>;
  query_priority?: Maybe<Smallint_Comparison_Exp>;
  service_tier?: Maybe<Team_Service_Tiers_Bool_Exp>;
  service_tier_id?: Maybe<Int_Comparison_Exp>;
  show_members?: Maybe<Boolean_Comparison_Exp>;
  stripe_customer_id?: Maybe<String_Comparison_Exp>;
  team?: Maybe<Teams_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Team_Members_Details_Delete_At_Path_Input = {
  permissions?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Team_Members_Details_Delete_Elem_Input = {
  permissions?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Team_Members_Details_Delete_Key_Input = {
  permissions?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "team_members_details" */
export type Team_Members_Details_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "team_members_details" */
export type Team_Members_Details_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Team_Service_Tiers_Obj_Rel_Insert_Input>;
  service_tier_id?: Maybe<Scalars['Int']>;
  show_members?: Maybe<Scalars['Boolean']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  team?: Maybe<Teams_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Team_Members_Details_Max_Fields = {
  __typename?: 'team_members_details_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Team_Members_Details_Min_Fields = {
  __typename?: 'team_members_details_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "team_members_details" */
export type Team_Members_Details_Mutation_Response = {
  __typename?: 'team_members_details_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Team_Members_Details>;
};

/** input type for inserting object relation for remote table "team_members_details" */
export type Team_Members_Details_Obj_Rel_Insert_Input = {
  data: Team_Members_Details_Insert_Input;
};

/** Ordering options when selecting data from "team_members_details". */
export type Team_Members_Details_Order_By = {
  created_at?: Maybe<Order_By>;
  enable_pro_badge?: Maybe<Order_By>;
  enable_service_tier_badge?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_pro?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  permissions?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  service_tier?: Maybe<Team_Service_Tiers_Order_By>;
  service_tier_id?: Maybe<Order_By>;
  show_members?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  team?: Maybe<Teams_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Team_Members_Details_Prepend_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "team_members_details" */
export enum Team_Members_Details_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  Id = 'id',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  MaxDatapointsPerRequest = 'max_datapoints_per_request',
  /** column name */
  MaxExecutionsOverageCostCents = 'max_executions_overage_cost_cents',
  /** column name */
  MaxOverageCents = 'max_overage_cents',
  /** column name */
  NumParallelQueries = 'num_parallel_queries',
  /** column name */
  Permissions = 'permissions',
  /** column name */
  QueryPriority = 'query_priority',
  /** column name */
  ServiceTierId = 'service_tier_id',
  /** column name */
  ShowMembers = 'show_members',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "team_members_details" */
export type Team_Members_Details_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  show_members?: Maybe<Scalars['Boolean']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Team_Members_Details_Stddev_Fields = {
  __typename?: 'team_members_details_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Team_Members_Details_Stddev_Pop_Fields = {
  __typename?: 'team_members_details_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Team_Members_Details_Stddev_Samp_Fields = {
  __typename?: 'team_members_details_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "team_members_details" */
export type Team_Members_Details_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Team_Members_Details_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Team_Members_Details_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  show_members?: Maybe<Scalars['Boolean']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Team_Members_Details_Sum_Fields = {
  __typename?: 'team_members_details_sum_fields';
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

export type Team_Members_Details_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Team_Members_Details_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Team_Members_Details_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Team_Members_Details_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Team_Members_Details_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Team_Members_Details_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Team_Members_Details_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Team_Members_Details_Set_Input>;
  where: Team_Members_Details_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Team_Members_Details_Var_Pop_Fields = {
  __typename?: 'team_members_details_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Team_Members_Details_Var_Samp_Fields = {
  __typename?: 'team_members_details_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Team_Members_Details_Variance_Fields = {
  __typename?: 'team_members_details_variance_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "team_public" */
export type Team_Public = {
  __typename?: 'team_public';
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  service_tier?: Maybe<Team_Service_Tiers>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "team_public" */
export type Team_Public_Aggregate = {
  __typename?: 'team_public_aggregate';
  aggregate?: Maybe<Team_Public_Aggregate_Fields>;
  nodes: Array<Team_Public>;
};

/** aggregate fields of "team_public" */
export type Team_Public_Aggregate_Fields = {
  __typename?: 'team_public_aggregate_fields';
  avg?: Maybe<Team_Public_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Team_Public_Max_Fields>;
  min?: Maybe<Team_Public_Min_Fields>;
  stddev?: Maybe<Team_Public_Stddev_Fields>;
  stddev_pop?: Maybe<Team_Public_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Team_Public_Stddev_Samp_Fields>;
  sum?: Maybe<Team_Public_Sum_Fields>;
  var_pop?: Maybe<Team_Public_Var_Pop_Fields>;
  var_samp?: Maybe<Team_Public_Var_Samp_Fields>;
  variance?: Maybe<Team_Public_Variance_Fields>;
};


/** aggregate fields of "team_public" */
export type Team_Public_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Team_Public_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Team_Public_Avg_Fields = {
  __typename?: 'team_public_avg_fields';
  id?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "team_public". All fields are combined with a logical 'AND'. */
export type Team_Public_Bool_Exp = {
  _and?: Maybe<Array<Team_Public_Bool_Exp>>;
  _not?: Maybe<Team_Public_Bool_Exp>;
  _or?: Maybe<Array<Team_Public_Bool_Exp>>;
  id?: Maybe<Int_Comparison_Exp>;
  is_pro?: Maybe<Boolean_Comparison_Exp>;
  service_tier?: Maybe<Team_Service_Tiers_Bool_Exp>;
  service_tier_id?: Maybe<Int_Comparison_Exp>;
};

/** input type for inserting data into table "team_public" */
export type Team_Public_Insert_Input = {
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  service_tier?: Maybe<Team_Service_Tiers_Obj_Rel_Insert_Input>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Team_Public_Max_Fields = {
  __typename?: 'team_public_max_fields';
  id?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Team_Public_Min_Fields = {
  __typename?: 'team_public_min_fields';
  id?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting object relation for remote table "team_public" */
export type Team_Public_Obj_Rel_Insert_Input = {
  data: Team_Public_Insert_Input;
};

/** Ordering options when selecting data from "team_public". */
export type Team_Public_Order_By = {
  id?: Maybe<Order_By>;
  is_pro?: Maybe<Order_By>;
  service_tier?: Maybe<Team_Service_Tiers_Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** select columns of table "team_public" */
export enum Team_Public_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  ServiceTierId = 'service_tier_id'
}

/** aggregate stddev on columns */
export type Team_Public_Stddev_Fields = {
  __typename?: 'team_public_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Team_Public_Stddev_Pop_Fields = {
  __typename?: 'team_public_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Team_Public_Stddev_Samp_Fields = {
  __typename?: 'team_public_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "team_public" */
export type Team_Public_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Team_Public_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Team_Public_Stream_Cursor_Value_Input = {
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Team_Public_Sum_Fields = {
  __typename?: 'team_public_sum_fields';
  id?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Team_Public_Var_Pop_Fields = {
  __typename?: 'team_public_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Team_Public_Var_Samp_Fields = {
  __typename?: 'team_public_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Team_Public_Variance_Fields = {
  __typename?: 'team_public_variance_fields';
  id?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "team_received_stars" */
export type Team_Received_Stars = {
  __typename?: 'team_received_stars';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "team_received_stars" */
export type Team_Received_Stars_Aggregate = {
  __typename?: 'team_received_stars_aggregate';
  aggregate?: Maybe<Team_Received_Stars_Aggregate_Fields>;
  nodes: Array<Team_Received_Stars>;
};

/** aggregate fields of "team_received_stars" */
export type Team_Received_Stars_Aggregate_Fields = {
  __typename?: 'team_received_stars_aggregate_fields';
  avg?: Maybe<Team_Received_Stars_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Team_Received_Stars_Max_Fields>;
  min?: Maybe<Team_Received_Stars_Min_Fields>;
  stddev?: Maybe<Team_Received_Stars_Stddev_Fields>;
  stddev_pop?: Maybe<Team_Received_Stars_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Team_Received_Stars_Stddev_Samp_Fields>;
  sum?: Maybe<Team_Received_Stars_Sum_Fields>;
  var_pop?: Maybe<Team_Received_Stars_Var_Pop_Fields>;
  var_samp?: Maybe<Team_Received_Stars_Var_Samp_Fields>;
  variance?: Maybe<Team_Received_Stars_Variance_Fields>;
};


/** aggregate fields of "team_received_stars" */
export type Team_Received_Stars_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Team_Received_Stars_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Team_Received_Stars_Avg_Fields = {
  __typename?: 'team_received_stars_avg_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "team_received_stars". All fields are combined with a logical 'AND'. */
export type Team_Received_Stars_Bool_Exp = {
  _and?: Maybe<Array<Team_Received_Stars_Bool_Exp>>;
  _not?: Maybe<Team_Received_Stars_Bool_Exp>;
  _or?: Maybe<Array<Team_Received_Stars_Bool_Exp>>;
  id?: Maybe<Int_Comparison_Exp>;
  sum?: Maybe<Numeric_Comparison_Exp>;
};

/** input type for inserting data into table "team_received_stars" */
export type Team_Received_Stars_Insert_Input = {
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type Team_Received_Stars_Max_Fields = {
  __typename?: 'team_received_stars_max_fields';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Team_Received_Stars_Min_Fields = {
  __typename?: 'team_received_stars_min_fields';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** input type for inserting object relation for remote table "team_received_stars" */
export type Team_Received_Stars_Obj_Rel_Insert_Input = {
  data: Team_Received_Stars_Insert_Input;
};

/** Ordering options when selecting data from "team_received_stars". */
export type Team_Received_Stars_Order_By = {
  id?: Maybe<Order_By>;
  sum?: Maybe<Order_By>;
};

/** select columns of table "team_received_stars" */
export enum Team_Received_Stars_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Sum = 'sum'
}

/** aggregate stddev on columns */
export type Team_Received_Stars_Stddev_Fields = {
  __typename?: 'team_received_stars_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Team_Received_Stars_Stddev_Pop_Fields = {
  __typename?: 'team_received_stars_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Team_Received_Stars_Stddev_Samp_Fields = {
  __typename?: 'team_received_stars_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "team_received_stars" */
export type Team_Received_Stars_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Team_Received_Stars_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Team_Received_Stars_Stream_Cursor_Value_Input = {
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type Team_Received_Stars_Sum_Fields = {
  __typename?: 'team_received_stars_sum_fields';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Team_Received_Stars_Var_Pop_Fields = {
  __typename?: 'team_received_stars_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Team_Received_Stars_Var_Samp_Fields = {
  __typename?: 'team_received_stars_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Team_Received_Stars_Variance_Fields = {
  __typename?: 'team_received_stars_variance_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "team_service_tiers" */
export type Team_Service_Tiers = {
  __typename?: 'team_service_tiers';
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents: Scalars['Int'];
  can_hide_members: Scalars['Boolean'];
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at: Scalars['timestamptz'];
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  included_datapoints: Scalars['Int'];
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name: Scalars['String'];
  is_public: Scalars['Boolean'];
  max_folders: Scalars['Int'];
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days: Scalars['Int'];
  name: Scalars['String'];
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key: Scalars['String'];
  orb_base_plan_id?: Maybe<Scalars['String']>;
  /** An array relationship */
  pending_team_subscription_updates: Array<Pending_Team_Subscription_Updates>;
  /** An aggregate relationship */
  pending_team_subscription_updates_aggregate: Pending_Team_Subscription_Updates_Aggregate;
  performance: Scalars['String'];
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version: Scalars['String'];
  remove_watermark: Scalars['Boolean'];
  /** An array relationship */
  teams: Array<Teams>;
  /** An aggregate relationship */
  teams_aggregate: Teams_Aggregate;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "team_service_tiers" */
export type Team_Service_TiersPending_Team_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Team_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};


/** columns and relationships of "team_service_tiers" */
export type Team_Service_TiersPending_Team_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_Team_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_Team_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
};


/** columns and relationships of "team_service_tiers" */
export type Team_Service_TiersTeamsArgs = {
  distinct_on?: Maybe<Array<Teams_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Teams_Order_By>>;
  where?: Maybe<Teams_Bool_Exp>;
};


/** columns and relationships of "team_service_tiers" */
export type Team_Service_TiersTeams_AggregateArgs = {
  distinct_on?: Maybe<Array<Teams_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Teams_Order_By>>;
  where?: Maybe<Teams_Bool_Exp>;
};

/** aggregated selection of "team_service_tiers" */
export type Team_Service_Tiers_Aggregate = {
  __typename?: 'team_service_tiers_aggregate';
  aggregate?: Maybe<Team_Service_Tiers_Aggregate_Fields>;
  nodes: Array<Team_Service_Tiers>;
};

/** aggregate fields of "team_service_tiers" */
export type Team_Service_Tiers_Aggregate_Fields = {
  __typename?: 'team_service_tiers_aggregate_fields';
  avg?: Maybe<Team_Service_Tiers_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Team_Service_Tiers_Max_Fields>;
  min?: Maybe<Team_Service_Tiers_Min_Fields>;
  stddev?: Maybe<Team_Service_Tiers_Stddev_Fields>;
  stddev_pop?: Maybe<Team_Service_Tiers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Team_Service_Tiers_Stddev_Samp_Fields>;
  sum?: Maybe<Team_Service_Tiers_Sum_Fields>;
  var_pop?: Maybe<Team_Service_Tiers_Var_Pop_Fields>;
  var_samp?: Maybe<Team_Service_Tiers_Var_Samp_Fields>;
  variance?: Maybe<Team_Service_Tiers_Variance_Fields>;
};


/** aggregate fields of "team_service_tiers" */
export type Team_Service_Tiers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Team_Service_Tiers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Team_Service_Tiers_Avg_Fields = {
  __typename?: 'team_service_tiers_avg_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "team_service_tiers". All fields are combined with a logical 'AND'. */
export type Team_Service_Tiers_Bool_Exp = {
  _and?: Maybe<Array<Team_Service_Tiers_Bool_Exp>>;
  _not?: Maybe<Team_Service_Tiers_Bool_Exp>;
  _or?: Maybe<Array<Team_Service_Tiers_Bool_Exp>>;
  allow_private_queries_as_views?: Maybe<Boolean_Comparison_Exp>;
  base_monthly_price_dollars_cents?: Maybe<Int_Comparison_Exp>;
  can_hide_members?: Maybe<Boolean_Comparison_Exp>;
  can_use_crud_endpoints?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  csv_downloads_per_month?: Maybe<Int_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  included_datapoints?: Maybe<Int_Comparison_Exp>;
  included_nanocredits?: Maybe<Bigint_Comparison_Exp>;
  included_query_executions?: Maybe<Int_Comparison_Exp>;
  internal_tier_name?: Maybe<String_Comparison_Exp>;
  is_public?: Maybe<Boolean_Comparison_Exp>;
  max_folders?: Maybe<Int_Comparison_Exp>;
  max_private_dashboards?: Maybe<Int_Comparison_Exp>;
  max_private_queries?: Maybe<Int_Comparison_Exp>;
  max_query_event_retention_days?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  nanocredits_cost_cents?: Maybe<Numeric_Comparison_Exp>;
  operation_costs_key?: Maybe<String_Comparison_Exp>;
  orb_base_plan_id?: Maybe<String_Comparison_Exp>;
  pending_team_subscription_updates?: Maybe<Pending_Team_Subscription_Updates_Bool_Exp>;
  pending_team_subscription_updates_aggregate?: Maybe<Pending_Team_Subscription_Updates_Aggregate_Bool_Exp>;
  performance?: Maybe<String_Comparison_Exp>;
  query_exec_overage_dollars_cents?: Maybe<Int_Comparison_Exp>;
  query_timeout_sec?: Maybe<Int_Comparison_Exp>;
  release_version?: Maybe<String_Comparison_Exp>;
  remove_watermark?: Maybe<Boolean_Comparison_Exp>;
  teams?: Maybe<Teams_Bool_Exp>;
  teams_aggregate?: Maybe<Teams_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "team_service_tiers" */
export enum Team_Service_Tiers_Constraint {
  /** unique or primary key constraint on columns "name" */
  TeamServiceTiersNameKey = 'team_service_tiers_name_key',
  /** unique or primary key constraint on columns "id" */
  TeamServiceTiersPkey = 'team_service_tiers_pkey'
}

/** input type for incrementing numeric columns in table "team_service_tiers" */
export type Team_Service_Tiers_Inc_Input = {
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "team_service_tiers" */
export type Team_Service_Tiers_Insert_Input = {
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  can_hide_members?: Maybe<Scalars['Boolean']>;
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  is_public?: Maybe<Scalars['Boolean']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  pending_team_subscription_updates?: Maybe<Pending_Team_Subscription_Updates_Arr_Rel_Insert_Input>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  remove_watermark?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<Teams_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Team_Service_Tiers_Max_Fields = {
  __typename?: 'team_service_tiers_max_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Team_Service_Tiers_Min_Fields = {
  __typename?: 'team_service_tiers_min_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "team_service_tiers" */
export type Team_Service_Tiers_Mutation_Response = {
  __typename?: 'team_service_tiers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Team_Service_Tiers>;
};

/** input type for inserting object relation for remote table "team_service_tiers" */
export type Team_Service_Tiers_Obj_Rel_Insert_Input = {
  data: Team_Service_Tiers_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Team_Service_Tiers_On_Conflict>;
};

/** on_conflict condition type for table "team_service_tiers" */
export type Team_Service_Tiers_On_Conflict = {
  constraint: Team_Service_Tiers_Constraint;
  update_columns: Array<Team_Service_Tiers_Update_Column>;
  where?: Maybe<Team_Service_Tiers_Bool_Exp>;
};

/** Ordering options when selecting data from "team_service_tiers". */
export type Team_Service_Tiers_Order_By = {
  allow_private_queries_as_views?: Maybe<Order_By>;
  base_monthly_price_dollars_cents?: Maybe<Order_By>;
  can_hide_members?: Maybe<Order_By>;
  can_use_crud_endpoints?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  csv_downloads_per_month?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  included_datapoints?: Maybe<Order_By>;
  included_nanocredits?: Maybe<Order_By>;
  included_query_executions?: Maybe<Order_By>;
  internal_tier_name?: Maybe<Order_By>;
  is_public?: Maybe<Order_By>;
  max_folders?: Maybe<Order_By>;
  max_private_dashboards?: Maybe<Order_By>;
  max_private_queries?: Maybe<Order_By>;
  max_query_event_retention_days?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  nanocredits_cost_cents?: Maybe<Order_By>;
  operation_costs_key?: Maybe<Order_By>;
  orb_base_plan_id?: Maybe<Order_By>;
  pending_team_subscription_updates_aggregate?: Maybe<Pending_Team_Subscription_Updates_Aggregate_Order_By>;
  performance?: Maybe<Order_By>;
  query_exec_overage_dollars_cents?: Maybe<Order_By>;
  query_timeout_sec?: Maybe<Order_By>;
  release_version?: Maybe<Order_By>;
  remove_watermark?: Maybe<Order_By>;
  teams_aggregate?: Maybe<Teams_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: team_service_tiers */
export type Team_Service_Tiers_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "team_service_tiers" */
export enum Team_Service_Tiers_Select_Column {
  /** column name */
  AllowPrivateQueriesAsViews = 'allow_private_queries_as_views',
  /** column name */
  BaseMonthlyPriceDollarsCents = 'base_monthly_price_dollars_cents',
  /** column name */
  CanHideMembers = 'can_hide_members',
  /** column name */
  CanUseCrudEndpoints = 'can_use_crud_endpoints',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadsPerMonth = 'csv_downloads_per_month',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IncludedDatapoints = 'included_datapoints',
  /** column name */
  IncludedNanocredits = 'included_nanocredits',
  /** column name */
  IncludedQueryExecutions = 'included_query_executions',
  /** column name */
  InternalTierName = 'internal_tier_name',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  MaxFolders = 'max_folders',
  /** column name */
  MaxPrivateDashboards = 'max_private_dashboards',
  /** column name */
  MaxPrivateQueries = 'max_private_queries',
  /** column name */
  MaxQueryEventRetentionDays = 'max_query_event_retention_days',
  /** column name */
  Name = 'name',
  /** column name */
  NanocreditsCostCents = 'nanocredits_cost_cents',
  /** column name */
  OperationCostsKey = 'operation_costs_key',
  /** column name */
  OrbBasePlanId = 'orb_base_plan_id',
  /** column name */
  Performance = 'performance',
  /** column name */
  QueryExecOverageDollarsCents = 'query_exec_overage_dollars_cents',
  /** column name */
  QueryTimeoutSec = 'query_timeout_sec',
  /** column name */
  ReleaseVersion = 'release_version',
  /** column name */
  RemoveWatermark = 'remove_watermark',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "team_service_tiers" */
export type Team_Service_Tiers_Set_Input = {
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  can_hide_members?: Maybe<Scalars['Boolean']>;
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  is_public?: Maybe<Scalars['Boolean']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  remove_watermark?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Team_Service_Tiers_Stddev_Fields = {
  __typename?: 'team_service_tiers_stddev_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Team_Service_Tiers_Stddev_Pop_Fields = {
  __typename?: 'team_service_tiers_stddev_pop_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Team_Service_Tiers_Stddev_Samp_Fields = {
  __typename?: 'team_service_tiers_stddev_samp_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "team_service_tiers" */
export type Team_Service_Tiers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Team_Service_Tiers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Team_Service_Tiers_Stream_Cursor_Value_Input = {
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  can_hide_members?: Maybe<Scalars['Boolean']>;
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  is_public?: Maybe<Scalars['Boolean']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  remove_watermark?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Team_Service_Tiers_Sum_Fields = {
  __typename?: 'team_service_tiers_sum_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  included_datapoints?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
};

/** update columns of table "team_service_tiers" */
export enum Team_Service_Tiers_Update_Column {
  /** column name */
  AllowPrivateQueriesAsViews = 'allow_private_queries_as_views',
  /** column name */
  BaseMonthlyPriceDollarsCents = 'base_monthly_price_dollars_cents',
  /** column name */
  CanHideMembers = 'can_hide_members',
  /** column name */
  CanUseCrudEndpoints = 'can_use_crud_endpoints',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadsPerMonth = 'csv_downloads_per_month',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IncludedDatapoints = 'included_datapoints',
  /** column name */
  IncludedNanocredits = 'included_nanocredits',
  /** column name */
  IncludedQueryExecutions = 'included_query_executions',
  /** column name */
  InternalTierName = 'internal_tier_name',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  MaxFolders = 'max_folders',
  /** column name */
  MaxPrivateDashboards = 'max_private_dashboards',
  /** column name */
  MaxPrivateQueries = 'max_private_queries',
  /** column name */
  MaxQueryEventRetentionDays = 'max_query_event_retention_days',
  /** column name */
  Name = 'name',
  /** column name */
  NanocreditsCostCents = 'nanocredits_cost_cents',
  /** column name */
  OperationCostsKey = 'operation_costs_key',
  /** column name */
  OrbBasePlanId = 'orb_base_plan_id',
  /** column name */
  Performance = 'performance',
  /** column name */
  QueryExecOverageDollarsCents = 'query_exec_overage_dollars_cents',
  /** column name */
  QueryTimeoutSec = 'query_timeout_sec',
  /** column name */
  ReleaseVersion = 'release_version',
  /** column name */
  RemoveWatermark = 'remove_watermark',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Team_Service_Tiers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Team_Service_Tiers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Team_Service_Tiers_Set_Input>;
  where: Team_Service_Tiers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Team_Service_Tiers_Var_Pop_Fields = {
  __typename?: 'team_service_tiers_var_pop_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Team_Service_Tiers_Var_Samp_Fields = {
  __typename?: 'team_service_tiers_var_samp_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Team_Service_Tiers_Variance_Fields = {
  __typename?: 'team_service_tiers_variance_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_datapoints?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "teams" */
export type Teams = {
  __typename?: 'teams';
  bio?: Maybe<Scalars['String']>;
  /** An object relationship */
  conditional_public_attributes?: Maybe<Team_Public>;
  created_at: Scalars['timestamptz'];
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  dashboards: Array<Dashboards>;
  /** An aggregate relationship */
  dashboards_aggregate: Dashboards_Aggregate;
  discord_url?: Maybe<Scalars['String']>;
  enable_pro_badge: Scalars['Boolean'];
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  handle: Scalars['String'];
  id: Scalars['Int'];
  is_pro: Scalars['Boolean'];
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  members_details?: Maybe<Team_Members_Details>;
  /** An array relationship */
  memberships: Array<Memberships>;
  /** An aggregate relationship */
  memberships_aggregate: Memberships_Aggregate;
  name: Scalars['String'];
  num_parallel_queries: Scalars['smallint'];
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions: Scalars['jsonb'];
  profile_image_url?: Maybe<Scalars['String']>;
  /** An array relationship */
  queries: Array<Queries>;
  /** An aggregate relationship */
  queries_aggregate: Queries_Aggregate;
  query_priority: Scalars['smallint'];
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  /** An object relationship */
  received_stars?: Maybe<Team_Received_Stars>;
  /** An object relationship */
  service_tier: Team_Service_Tiers;
  service_tier_id: Scalars['Int'];
  show_members: Scalars['Boolean'];
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "teams" */
export type TeamsDashboardsArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


/** columns and relationships of "teams" */
export type TeamsDashboards_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


/** columns and relationships of "teams" */
export type TeamsMembershipsArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


/** columns and relationships of "teams" */
export type TeamsMemberships_AggregateArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


/** columns and relationships of "teams" */
export type TeamsPermissionsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "teams" */
export type TeamsQueriesArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};


/** columns and relationships of "teams" */
export type TeamsQueries_AggregateArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};

/** aggregated selection of "teams" */
export type Teams_Aggregate = {
  __typename?: 'teams_aggregate';
  aggregate?: Maybe<Teams_Aggregate_Fields>;
  nodes: Array<Teams>;
};

export type Teams_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Teams_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Teams_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Teams_Aggregate_Bool_Exp_Count>;
};

export type Teams_Aggregate_Bool_Exp_Bool_And = {
  arguments: Teams_Select_Column_Teams_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Teams_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Teams_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Teams_Select_Column_Teams_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Teams_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Teams_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Teams_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Teams_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "teams" */
export type Teams_Aggregate_Fields = {
  __typename?: 'teams_aggregate_fields';
  avg?: Maybe<Teams_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Teams_Max_Fields>;
  min?: Maybe<Teams_Min_Fields>;
  stddev?: Maybe<Teams_Stddev_Fields>;
  stddev_pop?: Maybe<Teams_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Teams_Stddev_Samp_Fields>;
  sum?: Maybe<Teams_Sum_Fields>;
  var_pop?: Maybe<Teams_Var_Pop_Fields>;
  var_samp?: Maybe<Teams_Var_Samp_Fields>;
  variance?: Maybe<Teams_Variance_Fields>;
};


/** aggregate fields of "teams" */
export type Teams_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Teams_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "teams" */
export type Teams_Aggregate_Order_By = {
  avg?: Maybe<Teams_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Teams_Max_Order_By>;
  min?: Maybe<Teams_Min_Order_By>;
  stddev?: Maybe<Teams_Stddev_Order_By>;
  stddev_pop?: Maybe<Teams_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Teams_Stddev_Samp_Order_By>;
  sum?: Maybe<Teams_Sum_Order_By>;
  var_pop?: Maybe<Teams_Var_Pop_Order_By>;
  var_samp?: Maybe<Teams_Var_Samp_Order_By>;
  variance?: Maybe<Teams_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Teams_Append_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "teams" */
export type Teams_Arr_Rel_Insert_Input = {
  data: Array<Teams_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Teams_On_Conflict>;
};

/** aggregate avg on columns */
export type Teams_Avg_Fields = {
  __typename?: 'teams_avg_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "teams" */
export type Teams_Avg_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "teams". All fields are combined with a logical 'AND'. */
export type Teams_Bool_Exp = {
  _and?: Maybe<Array<Teams_Bool_Exp>>;
  _not?: Maybe<Teams_Bool_Exp>;
  _or?: Maybe<Array<Teams_Bool_Exp>>;
  bio?: Maybe<String_Comparison_Exp>;
  conditional_public_attributes?: Maybe<Team_Public_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  csv_download_quota_exceeded_until?: Maybe<Timestamptz_Comparison_Exp>;
  dashboards?: Maybe<Dashboards_Bool_Exp>;
  dashboards_aggregate?: Maybe<Dashboards_Aggregate_Bool_Exp>;
  discord_url?: Maybe<String_Comparison_Exp>;
  enable_pro_badge?: Maybe<Boolean_Comparison_Exp>;
  enable_service_tier_badge?: Maybe<Boolean_Comparison_Exp>;
  execution_quota_exceeded_until?: Maybe<Timestamptz_Comparison_Exp>;
  handle?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  is_pro?: Maybe<Boolean_Comparison_Exp>;
  max_datapoints_per_request?: Maybe<Int_Comparison_Exp>;
  max_executions_overage_cost_cents?: Maybe<Int_Comparison_Exp>;
  max_overage_cents?: Maybe<Numeric_Comparison_Exp>;
  members_details?: Maybe<Team_Members_Details_Bool_Exp>;
  memberships?: Maybe<Memberships_Bool_Exp>;
  memberships_aggregate?: Maybe<Memberships_Aggregate_Bool_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  num_parallel_queries?: Maybe<Smallint_Comparison_Exp>;
  orb_customer_id?: Maybe<String_Comparison_Exp>;
  orb_subscription_anchor_day?: Maybe<Int_Comparison_Exp>;
  orb_subscription_id?: Maybe<String_Comparison_Exp>;
  permissions?: Maybe<Jsonb_Comparison_Exp>;
  profile_image_url?: Maybe<String_Comparison_Exp>;
  queries?: Maybe<Queries_Bool_Exp>;
  queries_aggregate?: Maybe<Queries_Aggregate_Bool_Exp>;
  query_priority?: Maybe<Smallint_Comparison_Exp>;
  query_timeout_seconds?: Maybe<Int_Comparison_Exp>;
  received_stars?: Maybe<Team_Received_Stars_Bool_Exp>;
  service_tier?: Maybe<Team_Service_Tiers_Bool_Exp>;
  service_tier_id?: Maybe<Int_Comparison_Exp>;
  show_members?: Maybe<Boolean_Comparison_Exp>;
  stripe_customer_id?: Maybe<String_Comparison_Exp>;
  telegram_handle?: Maybe<String_Comparison_Exp>;
  twitter_handle?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "teams" */
export enum Teams_Constraint {
  /** unique or primary key constraint on columns "handle" */
  TeamsHandleKey = 'teams_handle_key',
  /** unique or primary key constraint on columns "orb_customer_id" */
  TeamsOrbCustomerIdIx = 'teams_orb_customer_id_ix',
  /** unique or primary key constraint on columns "id" */
  TeamsPkey = 'teams_pkey',
  /** unique or primary key constraint on columns "stripe_customer_id" */
  TeamsStripeCustomerIdIx = 'teams_stripe_customer_id_ix'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Teams_Delete_At_Path_Input = {
  permissions?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Teams_Delete_Elem_Input = {
  permissions?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Teams_Delete_Key_Input = {
  permissions?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "teams" */
export type Teams_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "teams" */
export type Teams_Insert_Input = {
  bio?: Maybe<Scalars['String']>;
  conditional_public_attributes?: Maybe<Team_Public_Obj_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  dashboards?: Maybe<Dashboards_Arr_Rel_Insert_Input>;
  discord_url?: Maybe<Scalars['String']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  members_details?: Maybe<Team_Members_Details_Obj_Rel_Insert_Input>;
  memberships?: Maybe<Memberships_Arr_Rel_Insert_Input>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  profile_image_url?: Maybe<Scalars['String']>;
  queries?: Maybe<Queries_Arr_Rel_Insert_Input>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  received_stars?: Maybe<Team_Received_Stars_Obj_Rel_Insert_Input>;
  service_tier?: Maybe<Team_Service_Tiers_Obj_Rel_Insert_Input>;
  service_tier_id?: Maybe<Scalars['Int']>;
  show_members?: Maybe<Scalars['Boolean']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Teams_Max_Fields = {
  __typename?: 'teams_max_fields';
  bio?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  discord_url?: Maybe<Scalars['String']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "teams" */
export type Teams_Max_Order_By = {
  bio?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  csv_download_quota_exceeded_until?: Maybe<Order_By>;
  discord_url?: Maybe<Order_By>;
  execution_quota_exceeded_until?: Maybe<Order_By>;
  handle?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_customer_id?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  profile_image_url?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  telegram_handle?: Maybe<Order_By>;
  twitter_handle?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Teams_Min_Fields = {
  __typename?: 'teams_min_fields';
  bio?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  discord_url?: Maybe<Scalars['String']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "teams" */
export type Teams_Min_Order_By = {
  bio?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  csv_download_quota_exceeded_until?: Maybe<Order_By>;
  discord_url?: Maybe<Order_By>;
  execution_quota_exceeded_until?: Maybe<Order_By>;
  handle?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_customer_id?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  profile_image_url?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  telegram_handle?: Maybe<Order_By>;
  twitter_handle?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "teams" */
export type Teams_Mutation_Response = {
  __typename?: 'teams_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Teams>;
};

/** input type for inserting object relation for remote table "teams" */
export type Teams_Obj_Rel_Insert_Input = {
  data: Teams_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Teams_On_Conflict>;
};

/** on_conflict condition type for table "teams" */
export type Teams_On_Conflict = {
  constraint: Teams_Constraint;
  update_columns: Array<Teams_Update_Column>;
  where?: Maybe<Teams_Bool_Exp>;
};

/** Ordering options when selecting data from "teams". */
export type Teams_Order_By = {
  bio?: Maybe<Order_By>;
  conditional_public_attributes?: Maybe<Team_Public_Order_By>;
  created_at?: Maybe<Order_By>;
  csv_download_quota_exceeded_until?: Maybe<Order_By>;
  dashboards_aggregate?: Maybe<Dashboards_Aggregate_Order_By>;
  discord_url?: Maybe<Order_By>;
  enable_pro_badge?: Maybe<Order_By>;
  enable_service_tier_badge?: Maybe<Order_By>;
  execution_quota_exceeded_until?: Maybe<Order_By>;
  handle?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_pro?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  members_details?: Maybe<Team_Members_Details_Order_By>;
  memberships_aggregate?: Maybe<Memberships_Aggregate_Order_By>;
  name?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_customer_id?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  permissions?: Maybe<Order_By>;
  profile_image_url?: Maybe<Order_By>;
  queries_aggregate?: Maybe<Queries_Aggregate_Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  received_stars?: Maybe<Team_Received_Stars_Order_By>;
  service_tier?: Maybe<Team_Service_Tiers_Order_By>;
  service_tier_id?: Maybe<Order_By>;
  show_members?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  telegram_handle?: Maybe<Order_By>;
  twitter_handle?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: teams */
export type Teams_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Teams_Prepend_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "teams" */
export enum Teams_Select_Column {
  /** column name */
  Bio = 'bio',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadQuotaExceededUntil = 'csv_download_quota_exceeded_until',
  /** column name */
  DiscordUrl = 'discord_url',
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  ExecutionQuotaExceededUntil = 'execution_quota_exceeded_until',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  MaxDatapointsPerRequest = 'max_datapoints_per_request',
  /** column name */
  MaxExecutionsOverageCostCents = 'max_executions_overage_cost_cents',
  /** column name */
  MaxOverageCents = 'max_overage_cents',
  /** column name */
  Name = 'name',
  /** column name */
  NumParallelQueries = 'num_parallel_queries',
  /** column name */
  OrbCustomerId = 'orb_customer_id',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  Permissions = 'permissions',
  /** column name */
  ProfileImageUrl = 'profile_image_url',
  /** column name */
  QueryPriority = 'query_priority',
  /** column name */
  QueryTimeoutSeconds = 'query_timeout_seconds',
  /** column name */
  ServiceTierId = 'service_tier_id',
  /** column name */
  ShowMembers = 'show_members',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  TelegramHandle = 'telegram_handle',
  /** column name */
  TwitterHandle = 'twitter_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "teams_aggregate_bool_exp_bool_and_arguments_columns" columns of table "teams" */
export enum Teams_Select_Column_Teams_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  ShowMembers = 'show_members'
}

/** select "teams_aggregate_bool_exp_bool_or_arguments_columns" columns of table "teams" */
export enum Teams_Select_Column_Teams_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  ShowMembers = 'show_members'
}

/** input type for updating data in table "teams" */
export type Teams_Set_Input = {
  bio?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  discord_url?: Maybe<Scalars['String']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  show_members?: Maybe<Scalars['Boolean']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Teams_Stddev_Fields = {
  __typename?: 'teams_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "teams" */
export type Teams_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Teams_Stddev_Pop_Fields = {
  __typename?: 'teams_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "teams" */
export type Teams_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Teams_Stddev_Samp_Fields = {
  __typename?: 'teams_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "teams" */
export type Teams_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "teams" */
export type Teams_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Teams_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Teams_Stream_Cursor_Value_Input = {
  bio?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  discord_url?: Maybe<Scalars['String']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
  show_members?: Maybe<Scalars['Boolean']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Teams_Sum_Fields = {
  __typename?: 'teams_sum_fields';
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "teams" */
export type Teams_Sum_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** update columns of table "teams" */
export enum Teams_Update_Column {
  /** column name */
  Bio = 'bio',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadQuotaExceededUntil = 'csv_download_quota_exceeded_until',
  /** column name */
  DiscordUrl = 'discord_url',
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  ExecutionQuotaExceededUntil = 'execution_quota_exceeded_until',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  MaxDatapointsPerRequest = 'max_datapoints_per_request',
  /** column name */
  MaxExecutionsOverageCostCents = 'max_executions_overage_cost_cents',
  /** column name */
  MaxOverageCents = 'max_overage_cents',
  /** column name */
  Name = 'name',
  /** column name */
  NumParallelQueries = 'num_parallel_queries',
  /** column name */
  OrbCustomerId = 'orb_customer_id',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  Permissions = 'permissions',
  /** column name */
  ProfileImageUrl = 'profile_image_url',
  /** column name */
  QueryPriority = 'query_priority',
  /** column name */
  QueryTimeoutSeconds = 'query_timeout_seconds',
  /** column name */
  ServiceTierId = 'service_tier_id',
  /** column name */
  ShowMembers = 'show_members',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  TelegramHandle = 'telegram_handle',
  /** column name */
  TwitterHandle = 'twitter_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Teams_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Teams_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Teams_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Teams_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Teams_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Teams_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Teams_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Teams_Set_Input>;
  where: Teams_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Teams_Var_Pop_Fields = {
  __typename?: 'teams_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "teams" */
export type Teams_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Teams_Var_Samp_Fields = {
  __typename?: 'teams_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "teams" */
export type Teams_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Teams_Variance_Fields = {
  __typename?: 'teams_variance_fields';
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "teams" */
export type Teams_Variance_Order_By = {
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier_id?: Maybe<Order_By>;
};

/** columns and relationships of "text_widgets" */
export type Text_Widgets = {
  __typename?: 'text_widgets';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dashboard?: Maybe<Dashboards>;
  /** An array relationship */
  dashboard_api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  dashboard_api_keys_aggregate: Api_Keys_Aggregate;
  dashboard_id?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  options?: Maybe<Scalars['jsonb']>;
  text: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "text_widgets" */
export type Text_WidgetsDashboard_Api_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "text_widgets" */
export type Text_WidgetsDashboard_Api_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "text_widgets" */
export type Text_WidgetsOptionsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "text_widgets" */
export type Text_Widgets_Aggregate = {
  __typename?: 'text_widgets_aggregate';
  aggregate?: Maybe<Text_Widgets_Aggregate_Fields>;
  nodes: Array<Text_Widgets>;
};

export type Text_Widgets_Aggregate_Bool_Exp = {
  count?: Maybe<Text_Widgets_Aggregate_Bool_Exp_Count>;
};

export type Text_Widgets_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Text_Widgets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Text_Widgets_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "text_widgets" */
export type Text_Widgets_Aggregate_Fields = {
  __typename?: 'text_widgets_aggregate_fields';
  avg?: Maybe<Text_Widgets_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Text_Widgets_Max_Fields>;
  min?: Maybe<Text_Widgets_Min_Fields>;
  stddev?: Maybe<Text_Widgets_Stddev_Fields>;
  stddev_pop?: Maybe<Text_Widgets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Text_Widgets_Stddev_Samp_Fields>;
  sum?: Maybe<Text_Widgets_Sum_Fields>;
  var_pop?: Maybe<Text_Widgets_Var_Pop_Fields>;
  var_samp?: Maybe<Text_Widgets_Var_Samp_Fields>;
  variance?: Maybe<Text_Widgets_Variance_Fields>;
};


/** aggregate fields of "text_widgets" */
export type Text_Widgets_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Text_Widgets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "text_widgets" */
export type Text_Widgets_Aggregate_Order_By = {
  avg?: Maybe<Text_Widgets_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Text_Widgets_Max_Order_By>;
  min?: Maybe<Text_Widgets_Min_Order_By>;
  stddev?: Maybe<Text_Widgets_Stddev_Order_By>;
  stddev_pop?: Maybe<Text_Widgets_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Text_Widgets_Stddev_Samp_Order_By>;
  sum?: Maybe<Text_Widgets_Sum_Order_By>;
  var_pop?: Maybe<Text_Widgets_Var_Pop_Order_By>;
  var_samp?: Maybe<Text_Widgets_Var_Samp_Order_By>;
  variance?: Maybe<Text_Widgets_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Text_Widgets_Append_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "text_widgets" */
export type Text_Widgets_Arr_Rel_Insert_Input = {
  data: Array<Text_Widgets_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Text_Widgets_On_Conflict>;
};

/** aggregate avg on columns */
export type Text_Widgets_Avg_Fields = {
  __typename?: 'text_widgets_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "text_widgets" */
export type Text_Widgets_Avg_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "text_widgets". All fields are combined with a logical 'AND'. */
export type Text_Widgets_Bool_Exp = {
  _and?: Maybe<Array<Text_Widgets_Bool_Exp>>;
  _not?: Maybe<Text_Widgets_Bool_Exp>;
  _or?: Maybe<Array<Text_Widgets_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dashboard?: Maybe<Dashboards_Bool_Exp>;
  dashboard_api_keys?: Maybe<Api_Keys_Bool_Exp>;
  dashboard_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  options?: Maybe<Jsonb_Comparison_Exp>;
  text?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "text_widgets" */
export enum Text_Widgets_Constraint {
  /** unique or primary key constraint on columns "id" */
  TextWidgetsPkey = 'text_widgets_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Text_Widgets_Delete_At_Path_Input = {
  options?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Text_Widgets_Delete_Elem_Input = {
  options?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Text_Widgets_Delete_Key_Input = {
  options?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "text_widgets" */
export type Text_Widgets_Inc_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "text_widgets" */
export type Text_Widgets_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  dashboard_api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  options?: Maybe<Scalars['jsonb']>;
  text?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Text_Widgets_Max_Fields = {
  __typename?: 'text_widgets_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "text_widgets" */
export type Text_Widgets_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  text?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Text_Widgets_Min_Fields = {
  __typename?: 'text_widgets_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "text_widgets" */
export type Text_Widgets_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  text?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "text_widgets" */
export type Text_Widgets_Mutation_Response = {
  __typename?: 'text_widgets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Text_Widgets>;
};

/** on_conflict condition type for table "text_widgets" */
export type Text_Widgets_On_Conflict = {
  constraint: Text_Widgets_Constraint;
  update_columns: Array<Text_Widgets_Update_Column>;
  where?: Maybe<Text_Widgets_Bool_Exp>;
};

/** Ordering options when selecting data from "text_widgets". */
export type Text_Widgets_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard?: Maybe<Dashboards_Order_By>;
  dashboard_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  options?: Maybe<Order_By>;
  text?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: text_widgets */
export type Text_Widgets_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Text_Widgets_Prepend_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "text_widgets" */
export enum Text_Widgets_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "text_widgets" */
export type Text_Widgets_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  options?: Maybe<Scalars['jsonb']>;
  text?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Text_Widgets_Stddev_Fields = {
  __typename?: 'text_widgets_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "text_widgets" */
export type Text_Widgets_Stddev_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Text_Widgets_Stddev_Pop_Fields = {
  __typename?: 'text_widgets_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "text_widgets" */
export type Text_Widgets_Stddev_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Text_Widgets_Stddev_Samp_Fields = {
  __typename?: 'text_widgets_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "text_widgets" */
export type Text_Widgets_Stddev_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "text_widgets" */
export type Text_Widgets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Text_Widgets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Text_Widgets_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  options?: Maybe<Scalars['jsonb']>;
  text?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Text_Widgets_Sum_Fields = {
  __typename?: 'text_widgets_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "text_widgets" */
export type Text_Widgets_Sum_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** update columns of table "text_widgets" */
export enum Text_Widgets_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Text_Widgets_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Text_Widgets_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Text_Widgets_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Text_Widgets_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Text_Widgets_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Text_Widgets_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Text_Widgets_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Text_Widgets_Set_Input>;
  where: Text_Widgets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Text_Widgets_Var_Pop_Fields = {
  __typename?: 'text_widgets_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "text_widgets" */
export type Text_Widgets_Var_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Text_Widgets_Var_Samp_Fields = {
  __typename?: 'text_widgets_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "text_widgets" */
export type Text_Widgets_Var_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Text_Widgets_Variance_Fields = {
  __typename?: 'text_widgets_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "text_widgets" */
export type Text_Widgets_Variance_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};


/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: Maybe<Scalars['timestamp']>;
  _gt?: Maybe<Scalars['timestamp']>;
  _gte?: Maybe<Scalars['timestamp']>;
  _in?: Maybe<Array<Scalars['timestamp']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timestamp']>;
  _lte?: Maybe<Scalars['timestamp']>;
  _neq?: Maybe<Scalars['timestamp']>;
  _nin?: Maybe<Array<Scalars['timestamp']>>;
};


/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: Maybe<Scalars['timestamptz']>;
  _gt?: Maybe<Scalars['timestamptz']>;
  _gte?: Maybe<Scalars['timestamptz']>;
  _in?: Maybe<Array<Scalars['timestamptz']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timestamptz']>;
  _lte?: Maybe<Scalars['timestamptz']>;
  _neq?: Maybe<Scalars['timestamptz']>;
  _nin?: Maybe<Array<Scalars['timestamptz']>>;
};


/** Boolean expression to compare columns of type "tsvector". All fields are combined with logical 'AND'. */
export type Tsvector_Comparison_Exp = {
  _eq?: Maybe<Scalars['tsvector']>;
  _gt?: Maybe<Scalars['tsvector']>;
  _gte?: Maybe<Scalars['tsvector']>;
  _in?: Maybe<Array<Scalars['tsvector']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['tsvector']>;
  _lte?: Maybe<Scalars['tsvector']>;
  _neq?: Maybe<Scalars['tsvector']>;
  _nin?: Maybe<Array<Scalars['tsvector']>>;
};

/** columns and relationships of "user_nonce" */
export type User_Nonce = {
  __typename?: 'user_nonce';
  ethereum_address: Scalars['String'];
  nonce: Scalars['String'];
};

/** aggregated selection of "user_nonce" */
export type User_Nonce_Aggregate = {
  __typename?: 'user_nonce_aggregate';
  aggregate?: Maybe<User_Nonce_Aggregate_Fields>;
  nodes: Array<User_Nonce>;
};

/** aggregate fields of "user_nonce" */
export type User_Nonce_Aggregate_Fields = {
  __typename?: 'user_nonce_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Nonce_Max_Fields>;
  min?: Maybe<User_Nonce_Min_Fields>;
};


/** aggregate fields of "user_nonce" */
export type User_Nonce_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Nonce_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_nonce". All fields are combined with a logical 'AND'. */
export type User_Nonce_Bool_Exp = {
  _and?: Maybe<Array<User_Nonce_Bool_Exp>>;
  _not?: Maybe<User_Nonce_Bool_Exp>;
  _or?: Maybe<Array<User_Nonce_Bool_Exp>>;
  ethereum_address?: Maybe<String_Comparison_Exp>;
  nonce?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_nonce" */
export enum User_Nonce_Constraint {
  /** unique or primary key constraint on columns "ethereum_address" */
  UserNoncePkey = 'user_nonce_pkey'
}

/** input type for inserting data into table "user_nonce" */
export type User_Nonce_Insert_Input = {
  ethereum_address?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type User_Nonce_Max_Fields = {
  __typename?: 'user_nonce_max_fields';
  ethereum_address?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type User_Nonce_Min_Fields = {
  __typename?: 'user_nonce_min_fields';
  ethereum_address?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "user_nonce" */
export type User_Nonce_Mutation_Response = {
  __typename?: 'user_nonce_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Nonce>;
};

/** on_conflict condition type for table "user_nonce" */
export type User_Nonce_On_Conflict = {
  constraint: User_Nonce_Constraint;
  update_columns: Array<User_Nonce_Update_Column>;
  where?: Maybe<User_Nonce_Bool_Exp>;
};

/** Ordering options when selecting data from "user_nonce". */
export type User_Nonce_Order_By = {
  ethereum_address?: Maybe<Order_By>;
  nonce?: Maybe<Order_By>;
};

/** primary key columns input for table: user_nonce */
export type User_Nonce_Pk_Columns_Input = {
  ethereum_address: Scalars['String'];
};

/** select columns of table "user_nonce" */
export enum User_Nonce_Select_Column {
  /** column name */
  EthereumAddress = 'ethereum_address',
  /** column name */
  Nonce = 'nonce'
}

/** input type for updating data in table "user_nonce" */
export type User_Nonce_Set_Input = {
  ethereum_address?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "user_nonce" */
export type User_Nonce_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Nonce_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Nonce_Stream_Cursor_Value_Input = {
  ethereum_address?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['String']>;
};

/** update columns of table "user_nonce" */
export enum User_Nonce_Update_Column {
  /** column name */
  EthereumAddress = 'ethereum_address',
  /** column name */
  Nonce = 'nonce'
}

export type User_Nonce_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Nonce_Set_Input>;
  where: User_Nonce_Bool_Exp;
};

/** columns and relationships of "user_private" */
export type User_Private = {
  __typename?: 'user_private';
  api_service_tier_id?: Maybe<Scalars['Int']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "user_private" */
export type User_PrivatePermissionsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "user_private" */
export type User_Private_Aggregate = {
  __typename?: 'user_private_aggregate';
  aggregate?: Maybe<User_Private_Aggregate_Fields>;
  nodes: Array<User_Private>;
};

/** aggregate fields of "user_private" */
export type User_Private_Aggregate_Fields = {
  __typename?: 'user_private_aggregate_fields';
  avg?: Maybe<User_Private_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<User_Private_Max_Fields>;
  min?: Maybe<User_Private_Min_Fields>;
  stddev?: Maybe<User_Private_Stddev_Fields>;
  stddev_pop?: Maybe<User_Private_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Private_Stddev_Samp_Fields>;
  sum?: Maybe<User_Private_Sum_Fields>;
  var_pop?: Maybe<User_Private_Var_Pop_Fields>;
  var_samp?: Maybe<User_Private_Var_Samp_Fields>;
  variance?: Maybe<User_Private_Variance_Fields>;
};


/** aggregate fields of "user_private" */
export type User_Private_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Private_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type User_Private_Append_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type User_Private_Avg_Fields = {
  __typename?: 'user_private_avg_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_private". All fields are combined with a logical 'AND'. */
export type User_Private_Bool_Exp = {
  _and?: Maybe<Array<User_Private_Bool_Exp>>;
  _not?: Maybe<User_Private_Bool_Exp>;
  _or?: Maybe<Array<User_Private_Bool_Exp>>;
  api_service_tier_id?: Maybe<Int_Comparison_Exp>;
  cognito_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  csv_download_quota_exceeded_until?: Maybe<Timestamptz_Comparison_Exp>;
  disabled_at?: Maybe<Timestamptz_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  enable_service_tier_badge?: Maybe<Boolean_Comparison_Exp>;
  ethereum_address_is_public?: Maybe<Boolean_Comparison_Exp>;
  execution_quota_exceeded_until?: Maybe<Timestamptz_Comparison_Exp>;
  from_service_tier?: Maybe<Int_Comparison_Exp>;
  is_pro?: Maybe<Boolean_Comparison_Exp>;
  max_datapoints_per_request?: Maybe<Int_Comparison_Exp>;
  max_executions_overage_cost_cents?: Maybe<Int_Comparison_Exp>;
  max_overage_cents?: Maybe<Numeric_Comparison_Exp>;
  num_parallel_queries?: Maybe<Smallint_Comparison_Exp>;
  onboarding_qs_skipped_until?: Maybe<Timestamptz_Comparison_Exp>;
  orb_api_subscription_id?: Maybe<String_Comparison_Exp>;
  orb_customer_id?: Maybe<String_Comparison_Exp>;
  orb_subscription_id?: Maybe<String_Comparison_Exp>;
  permissions?: Maybe<Jsonb_Comparison_Exp>;
  query_priority?: Maybe<Smallint_Comparison_Exp>;
  service_tier?: Maybe<Int_Comparison_Exp>;
  stripe_customer_id?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type User_Private_Delete_At_Path_Input = {
  permissions?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type User_Private_Delete_Elem_Input = {
  permissions?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type User_Private_Delete_Key_Input = {
  permissions?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "user_private" */
export type User_Private_Inc_Input = {
  api_service_tier_id?: Maybe<Scalars['Int']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_private" */
export type User_Private_Insert_Input = {
  api_service_tier_id?: Maybe<Scalars['Int']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type User_Private_Max_Fields = {
  __typename?: 'user_private_max_fields';
  api_service_tier_id?: Maybe<Scalars['Int']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type User_Private_Min_Fields = {
  __typename?: 'user_private_min_fields';
  api_service_tier_id?: Maybe<Scalars['Int']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "user_private" */
export type User_Private_Mutation_Response = {
  __typename?: 'user_private_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Private>;
};

/** input type for inserting object relation for remote table "user_private" */
export type User_Private_Obj_Rel_Insert_Input = {
  data: User_Private_Insert_Input;
};

/** Ordering options when selecting data from "user_private". */
export type User_Private_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  cognito_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  csv_download_quota_exceeded_until?: Maybe<Order_By>;
  disabled_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  enable_service_tier_badge?: Maybe<Order_By>;
  ethereum_address_is_public?: Maybe<Order_By>;
  execution_quota_exceeded_until?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  is_pro?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  onboarding_qs_skipped_until?: Maybe<Order_By>;
  orb_api_subscription_id?: Maybe<Order_By>;
  orb_customer_id?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  permissions?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type User_Private_Prepend_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "user_private" */
export enum User_Private_Select_Column {
  /** column name */
  ApiServiceTierId = 'api_service_tier_id',
  /** column name */
  CognitoId = 'cognito_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadQuotaExceededUntil = 'csv_download_quota_exceeded_until',
  /** column name */
  DisabledAt = 'disabled_at',
  /** column name */
  Email = 'email',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  EthereumAddressIsPublic = 'ethereum_address_is_public',
  /** column name */
  ExecutionQuotaExceededUntil = 'execution_quota_exceeded_until',
  /** column name */
  FromServiceTier = 'from_service_tier',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  MaxDatapointsPerRequest = 'max_datapoints_per_request',
  /** column name */
  MaxExecutionsOverageCostCents = 'max_executions_overage_cost_cents',
  /** column name */
  MaxOverageCents = 'max_overage_cents',
  /** column name */
  NumParallelQueries = 'num_parallel_queries',
  /** column name */
  OnboardingQsSkippedUntil = 'onboarding_qs_skipped_until',
  /** column name */
  OrbApiSubscriptionId = 'orb_api_subscription_id',
  /** column name */
  OrbCustomerId = 'orb_customer_id',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  Permissions = 'permissions',
  /** column name */
  QueryPriority = 'query_priority',
  /** column name */
  ServiceTier = 'service_tier',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "user_private" */
export type User_Private_Set_Input = {
  api_service_tier_id?: Maybe<Scalars['Int']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type User_Private_Stddev_Fields = {
  __typename?: 'user_private_stddev_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Private_Stddev_Pop_Fields = {
  __typename?: 'user_private_stddev_pop_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Private_Stddev_Samp_Fields = {
  __typename?: 'user_private_stddev_samp_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_private" */
export type User_Private_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Private_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Private_Stream_Cursor_Value_Input = {
  api_service_tier_id?: Maybe<Scalars['Int']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type User_Private_Sum_Fields = {
  __typename?: 'user_private_sum_fields';
  api_service_tier_id?: Maybe<Scalars['Int']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  query_priority?: Maybe<Scalars['smallint']>;
  service_tier?: Maybe<Scalars['Int']>;
};

export type User_Private_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<User_Private_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<User_Private_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<User_Private_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<User_Private_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<User_Private_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<User_Private_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Private_Set_Input>;
  where: User_Private_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Private_Var_Pop_Fields = {
  __typename?: 'user_private_var_pop_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Private_Var_Samp_Fields = {
  __typename?: 'user_private_var_samp_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Private_Variance_Fields = {
  __typename?: 'user_private_variance_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "user_public" */
export type User_Public = {
  __typename?: 'user_public';
  ethereum_address?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  service_tier_name?: Maybe<Scalars['String']>;
};

/** aggregated selection of "user_public" */
export type User_Public_Aggregate = {
  __typename?: 'user_public_aggregate';
  aggregate?: Maybe<User_Public_Aggregate_Fields>;
  nodes: Array<User_Public>;
};

/** aggregate fields of "user_public" */
export type User_Public_Aggregate_Fields = {
  __typename?: 'user_public_aggregate_fields';
  avg?: Maybe<User_Public_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<User_Public_Max_Fields>;
  min?: Maybe<User_Public_Min_Fields>;
  stddev?: Maybe<User_Public_Stddev_Fields>;
  stddev_pop?: Maybe<User_Public_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Public_Stddev_Samp_Fields>;
  sum?: Maybe<User_Public_Sum_Fields>;
  var_pop?: Maybe<User_Public_Var_Pop_Fields>;
  var_samp?: Maybe<User_Public_Var_Samp_Fields>;
  variance?: Maybe<User_Public_Variance_Fields>;
};


/** aggregate fields of "user_public" */
export type User_Public_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Public_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Public_Avg_Fields = {
  __typename?: 'user_public_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_public". All fields are combined with a logical 'AND'. */
export type User_Public_Bool_Exp = {
  _and?: Maybe<Array<User_Public_Bool_Exp>>;
  _not?: Maybe<User_Public_Bool_Exp>;
  _or?: Maybe<Array<User_Public_Bool_Exp>>;
  ethereum_address?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  service_tier_name?: Maybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "user_public" */
export type User_Public_Insert_Input = {
  ethereum_address?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  service_tier_name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type User_Public_Max_Fields = {
  __typename?: 'user_public_max_fields';
  ethereum_address?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  service_tier_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type User_Public_Min_Fields = {
  __typename?: 'user_public_min_fields';
  ethereum_address?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  service_tier_name?: Maybe<Scalars['String']>;
};

/** input type for inserting object relation for remote table "user_public" */
export type User_Public_Obj_Rel_Insert_Input = {
  data: User_Public_Insert_Input;
};

/** Ordering options when selecting data from "user_public". */
export type User_Public_Order_By = {
  ethereum_address?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  service_tier_name?: Maybe<Order_By>;
};

/** select columns of table "user_public" */
export enum User_Public_Select_Column {
  /** column name */
  EthereumAddress = 'ethereum_address',
  /** column name */
  Id = 'id',
  /** column name */
  ServiceTierName = 'service_tier_name'
}

/** aggregate stddev on columns */
export type User_Public_Stddev_Fields = {
  __typename?: 'user_public_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Public_Stddev_Pop_Fields = {
  __typename?: 'user_public_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Public_Stddev_Samp_Fields = {
  __typename?: 'user_public_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_public" */
export type User_Public_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Public_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Public_Stream_Cursor_Value_Input = {
  ethereum_address?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  service_tier_name?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type User_Public_Sum_Fields = {
  __typename?: 'user_public_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type User_Public_Var_Pop_Fields = {
  __typename?: 'user_public_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Public_Var_Samp_Fields = {
  __typename?: 'user_public_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Public_Variance_Fields = {
  __typename?: 'user_public_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "user_received_stars" */
export type User_Received_Stars = {
  __typename?: 'user_received_stars';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  user?: Maybe<Users>;
};

/** aggregated selection of "user_received_stars" */
export type User_Received_Stars_Aggregate = {
  __typename?: 'user_received_stars_aggregate';
  aggregate?: Maybe<User_Received_Stars_Aggregate_Fields>;
  nodes: Array<User_Received_Stars>;
};

/** aggregate fields of "user_received_stars" */
export type User_Received_Stars_Aggregate_Fields = {
  __typename?: 'user_received_stars_aggregate_fields';
  avg?: Maybe<User_Received_Stars_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<User_Received_Stars_Max_Fields>;
  min?: Maybe<User_Received_Stars_Min_Fields>;
  stddev?: Maybe<User_Received_Stars_Stddev_Fields>;
  stddev_pop?: Maybe<User_Received_Stars_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Received_Stars_Stddev_Samp_Fields>;
  sum?: Maybe<User_Received_Stars_Sum_Fields>;
  var_pop?: Maybe<User_Received_Stars_Var_Pop_Fields>;
  var_samp?: Maybe<User_Received_Stars_Var_Samp_Fields>;
  variance?: Maybe<User_Received_Stars_Variance_Fields>;
};


/** aggregate fields of "user_received_stars" */
export type User_Received_Stars_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Received_Stars_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Received_Stars_Avg_Fields = {
  __typename?: 'user_received_stars_avg_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_received_stars". All fields are combined with a logical 'AND'. */
export type User_Received_Stars_Bool_Exp = {
  _and?: Maybe<Array<User_Received_Stars_Bool_Exp>>;
  _not?: Maybe<User_Received_Stars_Bool_Exp>;
  _or?: Maybe<Array<User_Received_Stars_Bool_Exp>>;
  id?: Maybe<Int_Comparison_Exp>;
  sum?: Maybe<Numeric_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** input type for inserting data into table "user_received_stars" */
export type User_Received_Stars_Insert_Input = {
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type User_Received_Stars_Max_Fields = {
  __typename?: 'user_received_stars_max_fields';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type User_Received_Stars_Min_Fields = {
  __typename?: 'user_received_stars_min_fields';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** input type for inserting object relation for remote table "user_received_stars" */
export type User_Received_Stars_Obj_Rel_Insert_Input = {
  data: User_Received_Stars_Insert_Input;
};

/** Ordering options when selecting data from "user_received_stars". */
export type User_Received_Stars_Order_By = {
  id?: Maybe<Order_By>;
  sum?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** select columns of table "user_received_stars" */
export enum User_Received_Stars_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Sum = 'sum'
}

/** aggregate stddev on columns */
export type User_Received_Stars_Stddev_Fields = {
  __typename?: 'user_received_stars_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Received_Stars_Stddev_Pop_Fields = {
  __typename?: 'user_received_stars_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Received_Stars_Stddev_Samp_Fields = {
  __typename?: 'user_received_stars_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_received_stars" */
export type User_Received_Stars_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Received_Stars_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Received_Stars_Stream_Cursor_Value_Input = {
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type User_Received_Stars_Sum_Fields = {
  __typename?: 'user_received_stars_sum_fields';
  id?: Maybe<Scalars['Int']>;
  sum?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type User_Received_Stars_Var_Pop_Fields = {
  __typename?: 'user_received_stars_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Received_Stars_Var_Samp_Fields = {
  __typename?: 'user_received_stars_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Received_Stars_Variance_Fields = {
  __typename?: 'user_received_stars_variance_fields';
  id?: Maybe<Scalars['Float']>;
  sum?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "user_service_tiers" */
export type User_Service_Tiers = {
  __typename?: 'user_service_tiers';
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents: Scalars['Int'];
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at: Scalars['timestamptz'];
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name: Scalars['String'];
  is_public?: Maybe<Scalars['Boolean']>;
  max_folders: Scalars['Int'];
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days: Scalars['Int'];
  name: Scalars['String'];
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key: Scalars['String'];
  orb_base_plan_id?: Maybe<Scalars['String']>;
  /** An array relationship */
  pending_user_subscription_updates: Array<Pending_User_Subscription_Updates>;
  /** An aggregate relationship */
  pending_user_subscription_updates_aggregate: Pending_User_Subscription_Updates_Aggregate;
  performance: Scalars['String'];
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version: Scalars['String'];
  remove_watermark?: Maybe<Scalars['Boolean']>;
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  users: Array<Users>;
  /** An aggregate relationship */
  users_aggregate: Users_Aggregate;
};


/** columns and relationships of "user_service_tiers" */
export type User_Service_TiersPending_User_Subscription_UpdatesArgs = {
  distinct_on?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};


/** columns and relationships of "user_service_tiers" */
export type User_Service_TiersPending_User_Subscription_Updates_AggregateArgs = {
  distinct_on?: Maybe<Array<Pending_User_Subscription_Updates_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pending_User_Subscription_Updates_Order_By>>;
  where?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
};


/** columns and relationships of "user_service_tiers" */
export type User_Service_TiersUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


/** columns and relationships of "user_service_tiers" */
export type User_Service_TiersUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};

/** aggregated selection of "user_service_tiers" */
export type User_Service_Tiers_Aggregate = {
  __typename?: 'user_service_tiers_aggregate';
  aggregate?: Maybe<User_Service_Tiers_Aggregate_Fields>;
  nodes: Array<User_Service_Tiers>;
};

/** aggregate fields of "user_service_tiers" */
export type User_Service_Tiers_Aggregate_Fields = {
  __typename?: 'user_service_tiers_aggregate_fields';
  avg?: Maybe<User_Service_Tiers_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<User_Service_Tiers_Max_Fields>;
  min?: Maybe<User_Service_Tiers_Min_Fields>;
  stddev?: Maybe<User_Service_Tiers_Stddev_Fields>;
  stddev_pop?: Maybe<User_Service_Tiers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Service_Tiers_Stddev_Samp_Fields>;
  sum?: Maybe<User_Service_Tiers_Sum_Fields>;
  var_pop?: Maybe<User_Service_Tiers_Var_Pop_Fields>;
  var_samp?: Maybe<User_Service_Tiers_Var_Samp_Fields>;
  variance?: Maybe<User_Service_Tiers_Variance_Fields>;
};


/** aggregate fields of "user_service_tiers" */
export type User_Service_Tiers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Service_Tiers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Service_Tiers_Avg_Fields = {
  __typename?: 'user_service_tiers_avg_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_service_tiers". All fields are combined with a logical 'AND'. */
export type User_Service_Tiers_Bool_Exp = {
  _and?: Maybe<Array<User_Service_Tiers_Bool_Exp>>;
  _not?: Maybe<User_Service_Tiers_Bool_Exp>;
  _or?: Maybe<Array<User_Service_Tiers_Bool_Exp>>;
  allow_private_queries_as_views?: Maybe<Boolean_Comparison_Exp>;
  base_monthly_price_dollars_cents?: Maybe<Int_Comparison_Exp>;
  can_use_crud_endpoints?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  csv_downloads_per_month?: Maybe<Int_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  included_nanocredits?: Maybe<Bigint_Comparison_Exp>;
  included_query_executions?: Maybe<Int_Comparison_Exp>;
  internal_tier_name?: Maybe<String_Comparison_Exp>;
  is_public?: Maybe<Boolean_Comparison_Exp>;
  max_folders?: Maybe<Int_Comparison_Exp>;
  max_private_dashboards?: Maybe<Int_Comparison_Exp>;
  max_private_queries?: Maybe<Int_Comparison_Exp>;
  max_query_event_retention_days?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  nanocredits_cost_cents?: Maybe<Numeric_Comparison_Exp>;
  operation_costs_key?: Maybe<String_Comparison_Exp>;
  orb_base_plan_id?: Maybe<String_Comparison_Exp>;
  pending_user_subscription_updates?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
  pending_user_subscription_updates_aggregate?: Maybe<Pending_User_Subscription_Updates_Aggregate_Bool_Exp>;
  performance?: Maybe<String_Comparison_Exp>;
  query_exec_overage_dollars_cents?: Maybe<Int_Comparison_Exp>;
  query_timeout_sec?: Maybe<Int_Comparison_Exp>;
  release_version?: Maybe<String_Comparison_Exp>;
  remove_watermark?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  users?: Maybe<Users_Bool_Exp>;
  users_aggregate?: Maybe<Users_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "user_service_tiers" */
export enum User_Service_Tiers_Constraint {
  /** unique or primary key constraint on columns "name" */
  UserServiceTiersNameKey = 'user_service_tiers_name_key',
  /** unique or primary key constraint on columns "id" */
  UserServiceTiersPkey = 'user_service_tiers_pkey'
}

/** input type for incrementing numeric columns in table "user_service_tiers" */
export type User_Service_Tiers_Inc_Input = {
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_service_tiers" */
export type User_Service_Tiers_Insert_Input = {
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  is_public?: Maybe<Scalars['Boolean']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  pending_user_subscription_updates?: Maybe<Pending_User_Subscription_Updates_Arr_Rel_Insert_Input>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  remove_watermark?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  users?: Maybe<Users_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type User_Service_Tiers_Max_Fields = {
  __typename?: 'user_service_tiers_max_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type User_Service_Tiers_Min_Fields = {
  __typename?: 'user_service_tiers_min_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "user_service_tiers" */
export type User_Service_Tiers_Mutation_Response = {
  __typename?: 'user_service_tiers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Service_Tiers>;
};

/** input type for inserting object relation for remote table "user_service_tiers" */
export type User_Service_Tiers_Obj_Rel_Insert_Input = {
  data: User_Service_Tiers_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<User_Service_Tiers_On_Conflict>;
};

/** on_conflict condition type for table "user_service_tiers" */
export type User_Service_Tiers_On_Conflict = {
  constraint: User_Service_Tiers_Constraint;
  update_columns: Array<User_Service_Tiers_Update_Column>;
  where?: Maybe<User_Service_Tiers_Bool_Exp>;
};

/** Ordering options when selecting data from "user_service_tiers". */
export type User_Service_Tiers_Order_By = {
  allow_private_queries_as_views?: Maybe<Order_By>;
  base_monthly_price_dollars_cents?: Maybe<Order_By>;
  can_use_crud_endpoints?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  csv_downloads_per_month?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  included_nanocredits?: Maybe<Order_By>;
  included_query_executions?: Maybe<Order_By>;
  internal_tier_name?: Maybe<Order_By>;
  is_public?: Maybe<Order_By>;
  max_folders?: Maybe<Order_By>;
  max_private_dashboards?: Maybe<Order_By>;
  max_private_queries?: Maybe<Order_By>;
  max_query_event_retention_days?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  nanocredits_cost_cents?: Maybe<Order_By>;
  operation_costs_key?: Maybe<Order_By>;
  orb_base_plan_id?: Maybe<Order_By>;
  pending_user_subscription_updates_aggregate?: Maybe<Pending_User_Subscription_Updates_Aggregate_Order_By>;
  performance?: Maybe<Order_By>;
  query_exec_overage_dollars_cents?: Maybe<Order_By>;
  query_timeout_sec?: Maybe<Order_By>;
  release_version?: Maybe<Order_By>;
  remove_watermark?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  users_aggregate?: Maybe<Users_Aggregate_Order_By>;
};

/** primary key columns input for table: user_service_tiers */
export type User_Service_Tiers_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "user_service_tiers" */
export enum User_Service_Tiers_Select_Column {
  /** column name */
  AllowPrivateQueriesAsViews = 'allow_private_queries_as_views',
  /** column name */
  BaseMonthlyPriceDollarsCents = 'base_monthly_price_dollars_cents',
  /** column name */
  CanUseCrudEndpoints = 'can_use_crud_endpoints',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadsPerMonth = 'csv_downloads_per_month',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IncludedNanocredits = 'included_nanocredits',
  /** column name */
  IncludedQueryExecutions = 'included_query_executions',
  /** column name */
  InternalTierName = 'internal_tier_name',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  MaxFolders = 'max_folders',
  /** column name */
  MaxPrivateDashboards = 'max_private_dashboards',
  /** column name */
  MaxPrivateQueries = 'max_private_queries',
  /** column name */
  MaxQueryEventRetentionDays = 'max_query_event_retention_days',
  /** column name */
  Name = 'name',
  /** column name */
  NanocreditsCostCents = 'nanocredits_cost_cents',
  /** column name */
  OperationCostsKey = 'operation_costs_key',
  /** column name */
  OrbBasePlanId = 'orb_base_plan_id',
  /** column name */
  Performance = 'performance',
  /** column name */
  QueryExecOverageDollarsCents = 'query_exec_overage_dollars_cents',
  /** column name */
  QueryTimeoutSec = 'query_timeout_sec',
  /** column name */
  ReleaseVersion = 'release_version',
  /** column name */
  RemoveWatermark = 'remove_watermark',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "user_service_tiers" */
export type User_Service_Tiers_Set_Input = {
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  is_public?: Maybe<Scalars['Boolean']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  remove_watermark?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type User_Service_Tiers_Stddev_Fields = {
  __typename?: 'user_service_tiers_stddev_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Service_Tiers_Stddev_Pop_Fields = {
  __typename?: 'user_service_tiers_stddev_pop_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Service_Tiers_Stddev_Samp_Fields = {
  __typename?: 'user_service_tiers_stddev_samp_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_service_tiers" */
export type User_Service_Tiers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Service_Tiers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Service_Tiers_Stream_Cursor_Value_Input = {
  allow_private_queries_as_views?: Maybe<Scalars['Boolean']>;
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  can_use_crud_endpoints?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  internal_tier_name?: Maybe<Scalars['String']>;
  is_public?: Maybe<Scalars['Boolean']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  operation_costs_key?: Maybe<Scalars['String']>;
  orb_base_plan_id?: Maybe<Scalars['String']>;
  performance?: Maybe<Scalars['String']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
  release_version?: Maybe<Scalars['String']>;
  remove_watermark?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type User_Service_Tiers_Sum_Fields = {
  __typename?: 'user_service_tiers_sum_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Int']>;
  csv_downloads_per_month?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  included_nanocredits?: Maybe<Scalars['bigint']>;
  included_query_executions?: Maybe<Scalars['Int']>;
  max_folders?: Maybe<Scalars['Int']>;
  max_private_dashboards?: Maybe<Scalars['Int']>;
  max_private_queries?: Maybe<Scalars['Int']>;
  max_query_event_retention_days?: Maybe<Scalars['Int']>;
  nanocredits_cost_cents?: Maybe<Scalars['numeric']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Int']>;
  query_timeout_sec?: Maybe<Scalars['Int']>;
};

/** update columns of table "user_service_tiers" */
export enum User_Service_Tiers_Update_Column {
  /** column name */
  AllowPrivateQueriesAsViews = 'allow_private_queries_as_views',
  /** column name */
  BaseMonthlyPriceDollarsCents = 'base_monthly_price_dollars_cents',
  /** column name */
  CanUseCrudEndpoints = 'can_use_crud_endpoints',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadsPerMonth = 'csv_downloads_per_month',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IncludedNanocredits = 'included_nanocredits',
  /** column name */
  IncludedQueryExecutions = 'included_query_executions',
  /** column name */
  InternalTierName = 'internal_tier_name',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  MaxFolders = 'max_folders',
  /** column name */
  MaxPrivateDashboards = 'max_private_dashboards',
  /** column name */
  MaxPrivateQueries = 'max_private_queries',
  /** column name */
  MaxQueryEventRetentionDays = 'max_query_event_retention_days',
  /** column name */
  Name = 'name',
  /** column name */
  NanocreditsCostCents = 'nanocredits_cost_cents',
  /** column name */
  OperationCostsKey = 'operation_costs_key',
  /** column name */
  OrbBasePlanId = 'orb_base_plan_id',
  /** column name */
  Performance = 'performance',
  /** column name */
  QueryExecOverageDollarsCents = 'query_exec_overage_dollars_cents',
  /** column name */
  QueryTimeoutSec = 'query_timeout_sec',
  /** column name */
  ReleaseVersion = 'release_version',
  /** column name */
  RemoveWatermark = 'remove_watermark',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type User_Service_Tiers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<User_Service_Tiers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Service_Tiers_Set_Input>;
  where: User_Service_Tiers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Service_Tiers_Var_Pop_Fields = {
  __typename?: 'user_service_tiers_var_pop_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Service_Tiers_Var_Samp_Fields = {
  __typename?: 'user_service_tiers_var_samp_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Service_Tiers_Variance_Fields = {
  __typename?: 'user_service_tiers_variance_fields';
  base_monthly_price_dollars_cents?: Maybe<Scalars['Float']>;
  csv_downloads_per_month?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  included_nanocredits?: Maybe<Scalars['Float']>;
  included_query_executions?: Maybe<Scalars['Float']>;
  max_folders?: Maybe<Scalars['Float']>;
  max_private_dashboards?: Maybe<Scalars['Float']>;
  max_private_queries?: Maybe<Scalars['Float']>;
  max_query_event_retention_days?: Maybe<Scalars['Float']>;
  nanocredits_cost_cents?: Maybe<Scalars['Float']>;
  query_exec_overage_dollars_cents?: Maybe<Scalars['Float']>;
  query_timeout_sec?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'users';
  /** An object relationship */
  api_pending_subscription_update?: Maybe<Pending_Api_User_Subscription_Updates>;
  api_service_tier_id?: Maybe<Scalars['Int']>;
  /** An object relationship */
  api_user_service_tier?: Maybe<Api_User_Service_Tiers>;
  bio?: Maybe<Scalars['String']>;
  cognito_id: Scalars['uuid'];
  /** An object relationship */
  conditional_public_attributes?: Maybe<User_Public>;
  /** An array relationship */
  contract_submissions: Array<Contract_Submissions>;
  /** An aggregate relationship */
  contract_submissions_aggregate: Contract_Submissions_Aggregate;
  created_at: Scalars['timestamptz'];
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  dashboards: Array<Dashboards>;
  /** An aggregate relationship */
  dashboards_aggregate: Dashboards_Aggregate;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  discord_username?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  enable_pro_badge: Scalars['Boolean'];
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address?: Maybe<Scalars['String']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  handle?: Maybe<Scalars['String']>;
  /** An object relationship */
  has_pro_badge?: Maybe<Pro_Badge>;
  id: Scalars['Int'];
  is_available_for_gigs: Scalars['Boolean'];
  is_pro: Scalars['Boolean'];
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  memberships: Array<Memberships>;
  /** An aggregate relationship */
  memberships_aggregate: Memberships_Aggregate;
  name: Scalars['String'];
  num_parallel_queries: Scalars['smallint'];
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_api_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  pending_subscription_update?: Maybe<Pending_User_Subscription_Updates>;
  permissions: Scalars['jsonb'];
  /** An object relationship */
  private_info?: Maybe<User_Private>;
  profile_image_url?: Maybe<Scalars['String']>;
  /** An array relationship */
  queries: Array<Queries>;
  /** An aggregate relationship */
  queries_aggregate: Queries_Aggregate;
  query_priority: Scalars['smallint'];
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  /** An object relationship */
  received_stars?: Maybe<User_Received_Stars>;
  service_tier: Scalars['Int'];
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user_service_tier: User_Service_Tiers;
};


/** columns and relationships of "users" */
export type UsersContract_SubmissionsArgs = {
  distinct_on?: Maybe<Array<Contract_Submissions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contract_Submissions_Order_By>>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersContract_Submissions_AggregateArgs = {
  distinct_on?: Maybe<Array<Contract_Submissions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contract_Submissions_Order_By>>;
  where?: Maybe<Contract_Submissions_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersDashboardsArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersDashboards_AggregateArgs = {
  distinct_on?: Maybe<Array<Dashboards_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dashboards_Order_By>>;
  where?: Maybe<Dashboards_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersMembershipsArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersMemberships_AggregateArgs = {
  distinct_on?: Maybe<Array<Memberships_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Memberships_Order_By>>;
  where?: Maybe<Memberships_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersPermissionsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersQueriesArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersQueries_AggregateArgs = {
  distinct_on?: Maybe<Array<Queries_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Queries_Order_By>>;
  where?: Maybe<Queries_Bool_Exp>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

export type Users_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Users_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Users_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Users_Aggregate_Bool_Exp_Count>;
};

export type Users_Aggregate_Bool_Exp_Bool_And = {
  arguments: Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Users_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Users_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Users_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Users_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Users_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Users_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  avg?: Maybe<Users_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
  stddev?: Maybe<Users_Stddev_Fields>;
  stddev_pop?: Maybe<Users_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Users_Stddev_Samp_Fields>;
  sum?: Maybe<Users_Sum_Fields>;
  var_pop?: Maybe<Users_Var_Pop_Fields>;
  var_samp?: Maybe<Users_Var_Samp_Fields>;
  variance?: Maybe<Users_Variance_Fields>;
};


/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Users_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "users" */
export type Users_Aggregate_Order_By = {
  avg?: Maybe<Users_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Users_Max_Order_By>;
  min?: Maybe<Users_Min_Order_By>;
  stddev?: Maybe<Users_Stddev_Order_By>;
  stddev_pop?: Maybe<Users_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Users_Stddev_Samp_Order_By>;
  sum?: Maybe<Users_Sum_Order_By>;
  var_pop?: Maybe<Users_Var_Pop_Order_By>;
  var_samp?: Maybe<Users_Var_Samp_Order_By>;
  variance?: Maybe<Users_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Users_Append_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "users" */
export type Users_Arr_Rel_Insert_Input = {
  data: Array<Users_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Users_On_Conflict>;
};

/** aggregate avg on columns */
export type Users_Avg_Fields = {
  __typename?: 'users_avg_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "users" */
export type Users_Avg_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: Maybe<Array<Users_Bool_Exp>>;
  _not?: Maybe<Users_Bool_Exp>;
  _or?: Maybe<Array<Users_Bool_Exp>>;
  api_pending_subscription_update?: Maybe<Pending_Api_User_Subscription_Updates_Bool_Exp>;
  api_service_tier_id?: Maybe<Int_Comparison_Exp>;
  api_user_service_tier?: Maybe<Api_User_Service_Tiers_Bool_Exp>;
  bio?: Maybe<String_Comparison_Exp>;
  cognito_id?: Maybe<Uuid_Comparison_Exp>;
  conditional_public_attributes?: Maybe<User_Public_Bool_Exp>;
  contract_submissions?: Maybe<Contract_Submissions_Bool_Exp>;
  contract_submissions_aggregate?: Maybe<Contract_Submissions_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  csv_download_quota_exceeded_until?: Maybe<Timestamptz_Comparison_Exp>;
  dashboards?: Maybe<Dashboards_Bool_Exp>;
  dashboards_aggregate?: Maybe<Dashboards_Aggregate_Bool_Exp>;
  disabled_at?: Maybe<Timestamptz_Comparison_Exp>;
  discord_username?: Maybe<String_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  enable_pro_badge?: Maybe<Boolean_Comparison_Exp>;
  enable_service_tier_badge?: Maybe<Boolean_Comparison_Exp>;
  ethereum_address?: Maybe<String_Comparison_Exp>;
  ethereum_address_is_public?: Maybe<Boolean_Comparison_Exp>;
  execution_quota_exceeded_until?: Maybe<Timestamptz_Comparison_Exp>;
  from_service_tier?: Maybe<Int_Comparison_Exp>;
  handle?: Maybe<String_Comparison_Exp>;
  has_pro_badge?: Maybe<Pro_Badge_Bool_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  is_available_for_gigs?: Maybe<Boolean_Comparison_Exp>;
  is_pro?: Maybe<Boolean_Comparison_Exp>;
  max_datapoints_per_request?: Maybe<Int_Comparison_Exp>;
  max_executions_overage_cost_cents?: Maybe<Int_Comparison_Exp>;
  max_overage_cents?: Maybe<Numeric_Comparison_Exp>;
  memberships?: Maybe<Memberships_Bool_Exp>;
  memberships_aggregate?: Maybe<Memberships_Aggregate_Bool_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  num_parallel_queries?: Maybe<Smallint_Comparison_Exp>;
  onboarding_qs_skipped_until?: Maybe<Timestamptz_Comparison_Exp>;
  orb_api_subscription_id?: Maybe<String_Comparison_Exp>;
  orb_api_subscription_start_date?: Maybe<Timestamptz_Comparison_Exp>;
  orb_customer_id?: Maybe<String_Comparison_Exp>;
  orb_subscription_anchor_day?: Maybe<Int_Comparison_Exp>;
  orb_subscription_id?: Maybe<String_Comparison_Exp>;
  pending_subscription_update?: Maybe<Pending_User_Subscription_Updates_Bool_Exp>;
  permissions?: Maybe<Jsonb_Comparison_Exp>;
  private_info?: Maybe<User_Private_Bool_Exp>;
  profile_image_url?: Maybe<String_Comparison_Exp>;
  queries?: Maybe<Queries_Bool_Exp>;
  queries_aggregate?: Maybe<Queries_Aggregate_Bool_Exp>;
  query_priority?: Maybe<Smallint_Comparison_Exp>;
  query_timeout_seconds?: Maybe<Int_Comparison_Exp>;
  received_stars?: Maybe<User_Received_Stars_Bool_Exp>;
  service_tier?: Maybe<Int_Comparison_Exp>;
  stripe_customer_id?: Maybe<String_Comparison_Exp>;
  telegram_handle?: Maybe<String_Comparison_Exp>;
  twitter_handle?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_service_tier?: Maybe<User_Service_Tiers_Bool_Exp>;
};

/** unique or primary key constraints on table "users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "name" */
  UserNameIdx = 'user_name_idx',
  /** unique or primary key constraint on columns "cognito_id" */
  UsersCognitoIdKey = 'users_cognito_id_key',
  /** unique or primary key constraint on columns "ethereum_address" */
  UsersEthereumAddressUnique = 'users_ethereum_address_unique',
  /** unique or primary key constraint on columns "orb_customer_id" */
  UsersOrbCustomerIdIx = 'users_orb_customer_id_ix',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey',
  /** unique or primary key constraint on columns "stripe_customer_id" */
  UsersStripeCustomerIdIx = 'users_stripe_customer_id_ix',
  /** unique or primary key constraint on columns "email" */
  UsersUniqueEmail = 'users_unique_email',
  /** unique or primary key constraint on columns "name" */
  UsersUniqueName = 'users_unique_name'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Users_Delete_At_Path_Input = {
  permissions?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Users_Delete_Elem_Input = {
  permissions?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Users_Delete_Key_Input = {
  permissions?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "users" */
export type Users_Inc_Input = {
  api_service_tier_id?: Maybe<Scalars['Int']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  api_pending_subscription_update?: Maybe<Pending_Api_User_Subscription_Updates_Obj_Rel_Insert_Input>;
  api_service_tier_id?: Maybe<Scalars['Int']>;
  api_user_service_tier?: Maybe<Api_User_Service_Tiers_Obj_Rel_Insert_Input>;
  bio?: Maybe<Scalars['String']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  conditional_public_attributes?: Maybe<User_Public_Obj_Rel_Insert_Input>;
  contract_submissions?: Maybe<Contract_Submissions_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  dashboards?: Maybe<Dashboards_Arr_Rel_Insert_Input>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  discord_username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address?: Maybe<Scalars['String']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  has_pro_badge?: Maybe<Pro_Badge_Obj_Rel_Insert_Input>;
  id?: Maybe<Scalars['Int']>;
  is_available_for_gigs?: Maybe<Scalars['Boolean']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  memberships?: Maybe<Memberships_Arr_Rel_Insert_Input>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_api_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  pending_subscription_update?: Maybe<Pending_User_Subscription_Updates_Obj_Rel_Insert_Input>;
  permissions?: Maybe<Scalars['jsonb']>;
  private_info?: Maybe<User_Private_Obj_Rel_Insert_Input>;
  profile_image_url?: Maybe<Scalars['String']>;
  queries?: Maybe<Queries_Arr_Rel_Insert_Input>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  received_stars?: Maybe<User_Received_Stars_Obj_Rel_Insert_Input>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_service_tier?: Maybe<User_Service_Tiers_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  api_service_tier_id?: Maybe<Scalars['Int']>;
  bio?: Maybe<Scalars['String']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  discord_username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  ethereum_address?: Maybe<Scalars['String']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_api_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "users" */
export type Users_Max_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  bio?: Maybe<Order_By>;
  cognito_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  csv_download_quota_exceeded_until?: Maybe<Order_By>;
  disabled_at?: Maybe<Order_By>;
  discord_username?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  ethereum_address?: Maybe<Order_By>;
  execution_quota_exceeded_until?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  handle?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  onboarding_qs_skipped_until?: Maybe<Order_By>;
  orb_api_subscription_id?: Maybe<Order_By>;
  orb_api_subscription_start_date?: Maybe<Order_By>;
  orb_customer_id?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  profile_image_url?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  telegram_handle?: Maybe<Order_By>;
  twitter_handle?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  api_service_tier_id?: Maybe<Scalars['Int']>;
  bio?: Maybe<Scalars['String']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  discord_username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  ethereum_address?: Maybe<Scalars['String']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_api_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "users" */
export type Users_Min_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  bio?: Maybe<Order_By>;
  cognito_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  csv_download_quota_exceeded_until?: Maybe<Order_By>;
  disabled_at?: Maybe<Order_By>;
  discord_username?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  ethereum_address?: Maybe<Order_By>;
  execution_quota_exceeded_until?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  handle?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  onboarding_qs_skipped_until?: Maybe<Order_By>;
  orb_api_subscription_id?: Maybe<Order_By>;
  orb_api_subscription_start_date?: Maybe<Order_By>;
  orb_customer_id?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  profile_image_url?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  telegram_handle?: Maybe<Order_By>;
  twitter_handle?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns: Array<Users_Update_Column>;
  where?: Maybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  api_pending_subscription_update?: Maybe<Pending_Api_User_Subscription_Updates_Order_By>;
  api_service_tier_id?: Maybe<Order_By>;
  api_user_service_tier?: Maybe<Api_User_Service_Tiers_Order_By>;
  bio?: Maybe<Order_By>;
  cognito_id?: Maybe<Order_By>;
  conditional_public_attributes?: Maybe<User_Public_Order_By>;
  contract_submissions_aggregate?: Maybe<Contract_Submissions_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  csv_download_quota_exceeded_until?: Maybe<Order_By>;
  dashboards_aggregate?: Maybe<Dashboards_Aggregate_Order_By>;
  disabled_at?: Maybe<Order_By>;
  discord_username?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  enable_pro_badge?: Maybe<Order_By>;
  enable_service_tier_badge?: Maybe<Order_By>;
  ethereum_address?: Maybe<Order_By>;
  ethereum_address_is_public?: Maybe<Order_By>;
  execution_quota_exceeded_until?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  handle?: Maybe<Order_By>;
  has_pro_badge?: Maybe<Pro_Badge_Order_By>;
  id?: Maybe<Order_By>;
  is_available_for_gigs?: Maybe<Order_By>;
  is_pro?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  memberships_aggregate?: Maybe<Memberships_Aggregate_Order_By>;
  name?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  onboarding_qs_skipped_until?: Maybe<Order_By>;
  orb_api_subscription_id?: Maybe<Order_By>;
  orb_api_subscription_start_date?: Maybe<Order_By>;
  orb_customer_id?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  orb_subscription_id?: Maybe<Order_By>;
  pending_subscription_update?: Maybe<Pending_User_Subscription_Updates_Order_By>;
  permissions?: Maybe<Order_By>;
  private_info?: Maybe<User_Private_Order_By>;
  profile_image_url?: Maybe<Order_By>;
  queries_aggregate?: Maybe<Queries_Aggregate_Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  received_stars?: Maybe<User_Received_Stars_Order_By>;
  service_tier?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  telegram_handle?: Maybe<Order_By>;
  twitter_handle?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_service_tier?: Maybe<User_Service_Tiers_Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Users_Prepend_Input = {
  permissions?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "users" */
export enum Users_Select_Column {
  /** column name */
  ApiServiceTierId = 'api_service_tier_id',
  /** column name */
  Bio = 'bio',
  /** column name */
  CognitoId = 'cognito_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadQuotaExceededUntil = 'csv_download_quota_exceeded_until',
  /** column name */
  DisabledAt = 'disabled_at',
  /** column name */
  DiscordUsername = 'discord_username',
  /** column name */
  Email = 'email',
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  EthereumAddress = 'ethereum_address',
  /** column name */
  EthereumAddressIsPublic = 'ethereum_address_is_public',
  /** column name */
  ExecutionQuotaExceededUntil = 'execution_quota_exceeded_until',
  /** column name */
  FromServiceTier = 'from_service_tier',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  IsAvailableForGigs = 'is_available_for_gigs',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  MaxDatapointsPerRequest = 'max_datapoints_per_request',
  /** column name */
  MaxExecutionsOverageCostCents = 'max_executions_overage_cost_cents',
  /** column name */
  MaxOverageCents = 'max_overage_cents',
  /** column name */
  Name = 'name',
  /** column name */
  NumParallelQueries = 'num_parallel_queries',
  /** column name */
  OnboardingQsSkippedUntil = 'onboarding_qs_skipped_until',
  /** column name */
  OrbApiSubscriptionId = 'orb_api_subscription_id',
  /** column name */
  OrbApiSubscriptionStartDate = 'orb_api_subscription_start_date',
  /** column name */
  OrbCustomerId = 'orb_customer_id',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  Permissions = 'permissions',
  /** column name */
  ProfileImageUrl = 'profile_image_url',
  /** column name */
  QueryPriority = 'query_priority',
  /** column name */
  QueryTimeoutSeconds = 'query_timeout_seconds',
  /** column name */
  ServiceTier = 'service_tier',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  TelegramHandle = 'telegram_handle',
  /** column name */
  TwitterHandle = 'twitter_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "users" */
export enum Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  EthereumAddressIsPublic = 'ethereum_address_is_public',
  /** column name */
  IsAvailableForGigs = 'is_available_for_gigs',
  /** column name */
  IsPro = 'is_pro'
}

/** select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "users" */
export enum Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  EthereumAddressIsPublic = 'ethereum_address_is_public',
  /** column name */
  IsAvailableForGigs = 'is_available_for_gigs',
  /** column name */
  IsPro = 'is_pro'
}

/** input type for updating data in table "users" */
export type Users_Set_Input = {
  api_service_tier_id?: Maybe<Scalars['Int']>;
  bio?: Maybe<Scalars['String']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  discord_username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address?: Maybe<Scalars['String']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  is_available_for_gigs?: Maybe<Scalars['Boolean']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_api_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Users_Stddev_Fields = {
  __typename?: 'users_stddev_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "users" */
export type Users_Stddev_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Users_Stddev_Pop_Fields = {
  __typename?: 'users_stddev_pop_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "users" */
export type Users_Stddev_Pop_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Users_Stddev_Samp_Fields = {
  __typename?: 'users_stddev_samp_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "users" */
export type Users_Stddev_Samp_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  api_service_tier_id?: Maybe<Scalars['Int']>;
  bio?: Maybe<Scalars['String']>;
  cognito_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  csv_download_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  disabled_at?: Maybe<Scalars['timestamptz']>;
  discord_username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  enable_pro_badge?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
  ethereum_address?: Maybe<Scalars['String']>;
  ethereum_address_is_public?: Maybe<Scalars['Boolean']>;
  execution_quota_exceeded_until?: Maybe<Scalars['timestamptz']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  handle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  is_available_for_gigs?: Maybe<Scalars['Boolean']>;
  is_pro?: Maybe<Scalars['Boolean']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  onboarding_qs_skipped_until?: Maybe<Scalars['timestamptz']>;
  orb_api_subscription_id?: Maybe<Scalars['String']>;
  orb_api_subscription_start_date?: Maybe<Scalars['timestamptz']>;
  orb_customer_id?: Maybe<Scalars['String']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  orb_subscription_id?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['jsonb']>;
  profile_image_url?: Maybe<Scalars['String']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Users_Sum_Fields = {
  __typename?: 'users_sum_fields';
  api_service_tier_id?: Maybe<Scalars['Int']>;
  from_service_tier?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
  max_overage_cents?: Maybe<Scalars['numeric']>;
  num_parallel_queries?: Maybe<Scalars['smallint']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Int']>;
  query_priority?: Maybe<Scalars['smallint']>;
  query_timeout_seconds?: Maybe<Scalars['Int']>;
  service_tier?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "users" */
export type Users_Sum_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};

/** update columns of table "users" */
export enum Users_Update_Column {
  /** column name */
  ApiServiceTierId = 'api_service_tier_id',
  /** column name */
  Bio = 'bio',
  /** column name */
  CognitoId = 'cognito_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CsvDownloadQuotaExceededUntil = 'csv_download_quota_exceeded_until',
  /** column name */
  DisabledAt = 'disabled_at',
  /** column name */
  DiscordUsername = 'discord_username',
  /** column name */
  Email = 'email',
  /** column name */
  EnableProBadge = 'enable_pro_badge',
  /** column name */
  EnableServiceTierBadge = 'enable_service_tier_badge',
  /** column name */
  EthereumAddress = 'ethereum_address',
  /** column name */
  EthereumAddressIsPublic = 'ethereum_address_is_public',
  /** column name */
  ExecutionQuotaExceededUntil = 'execution_quota_exceeded_until',
  /** column name */
  FromServiceTier = 'from_service_tier',
  /** column name */
  Id = 'id',
  /** column name */
  IsAvailableForGigs = 'is_available_for_gigs',
  /** column name */
  IsPro = 'is_pro',
  /** column name */
  MaxDatapointsPerRequest = 'max_datapoints_per_request',
  /** column name */
  MaxExecutionsOverageCostCents = 'max_executions_overage_cost_cents',
  /** column name */
  MaxOverageCents = 'max_overage_cents',
  /** column name */
  Name = 'name',
  /** column name */
  NumParallelQueries = 'num_parallel_queries',
  /** column name */
  OnboardingQsSkippedUntil = 'onboarding_qs_skipped_until',
  /** column name */
  OrbApiSubscriptionId = 'orb_api_subscription_id',
  /** column name */
  OrbApiSubscriptionStartDate = 'orb_api_subscription_start_date',
  /** column name */
  OrbCustomerId = 'orb_customer_id',
  /** column name */
  OrbSubscriptionAnchorDay = 'orb_subscription_anchor_day',
  /** column name */
  OrbSubscriptionId = 'orb_subscription_id',
  /** column name */
  Permissions = 'permissions',
  /** column name */
  ProfileImageUrl = 'profile_image_url',
  /** column name */
  QueryPriority = 'query_priority',
  /** column name */
  QueryTimeoutSeconds = 'query_timeout_seconds',
  /** column name */
  ServiceTier = 'service_tier',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  TelegramHandle = 'telegram_handle',
  /** column name */
  TwitterHandle = 'twitter_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Users_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Users_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Users_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Users_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Users_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Users_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Users_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Users_Var_Pop_Fields = {
  __typename?: 'users_var_pop_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "users" */
export type Users_Var_Pop_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Users_Var_Samp_Fields = {
  __typename?: 'users_var_samp_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "users" */
export type Users_Var_Samp_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Users_Variance_Fields = {
  __typename?: 'users_variance_fields';
  api_service_tier_id?: Maybe<Scalars['Float']>;
  from_service_tier?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_datapoints_per_request?: Maybe<Scalars['Float']>;
  max_executions_overage_cost_cents?: Maybe<Scalars['Float']>;
  max_overage_cents?: Maybe<Scalars['Float']>;
  num_parallel_queries?: Maybe<Scalars['Float']>;
  orb_subscription_anchor_day?: Maybe<Scalars['Float']>;
  query_priority?: Maybe<Scalars['Float']>;
  query_timeout_seconds?: Maybe<Scalars['Float']>;
  service_tier?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "users" */
export type Users_Variance_Order_By = {
  api_service_tier_id?: Maybe<Order_By>;
  from_service_tier?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  max_datapoints_per_request?: Maybe<Order_By>;
  max_executions_overage_cost_cents?: Maybe<Order_By>;
  max_overage_cents?: Maybe<Order_By>;
  num_parallel_queries?: Maybe<Order_By>;
  orb_subscription_anchor_day?: Maybe<Order_By>;
  query_priority?: Maybe<Order_By>;
  query_timeout_seconds?: Maybe<Order_By>;
  service_tier?: Maybe<Order_By>;
};


/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: Maybe<Scalars['uuid']>;
  _gt?: Maybe<Scalars['uuid']>;
  _gte?: Maybe<Scalars['uuid']>;
  _in?: Maybe<Array<Scalars['uuid']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['uuid']>;
  _lte?: Maybe<Scalars['uuid']>;
  _neq?: Maybe<Scalars['uuid']>;
  _nin?: Maybe<Array<Scalars['uuid']>>;
};

/** columns and relationships of "view_queue_positions" */
export type View_Queue_Positions = {
  __typename?: 'view_queue_positions';
  id?: Maybe<Scalars['uuid']>;
  pos?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "view_queue_positions" */
export type View_Queue_Positions_Aggregate = {
  __typename?: 'view_queue_positions_aggregate';
  aggregate?: Maybe<View_Queue_Positions_Aggregate_Fields>;
  nodes: Array<View_Queue_Positions>;
};

/** aggregate fields of "view_queue_positions" */
export type View_Queue_Positions_Aggregate_Fields = {
  __typename?: 'view_queue_positions_aggregate_fields';
  avg?: Maybe<View_Queue_Positions_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<View_Queue_Positions_Max_Fields>;
  min?: Maybe<View_Queue_Positions_Min_Fields>;
  stddev?: Maybe<View_Queue_Positions_Stddev_Fields>;
  stddev_pop?: Maybe<View_Queue_Positions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<View_Queue_Positions_Stddev_Samp_Fields>;
  sum?: Maybe<View_Queue_Positions_Sum_Fields>;
  var_pop?: Maybe<View_Queue_Positions_Var_Pop_Fields>;
  var_samp?: Maybe<View_Queue_Positions_Var_Samp_Fields>;
  variance?: Maybe<View_Queue_Positions_Variance_Fields>;
};


/** aggregate fields of "view_queue_positions" */
export type View_Queue_Positions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<View_Queue_Positions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type View_Queue_Positions_Avg_Fields = {
  __typename?: 'view_queue_positions_avg_fields';
  pos?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "view_queue_positions". All fields are combined with a logical 'AND'. */
export type View_Queue_Positions_Bool_Exp = {
  _and?: Maybe<Array<View_Queue_Positions_Bool_Exp>>;
  _not?: Maybe<View_Queue_Positions_Bool_Exp>;
  _or?: Maybe<Array<View_Queue_Positions_Bool_Exp>>;
  id?: Maybe<Uuid_Comparison_Exp>;
  pos?: Maybe<Bigint_Comparison_Exp>;
};

/** aggregate max on columns */
export type View_Queue_Positions_Max_Fields = {
  __typename?: 'view_queue_positions_max_fields';
  id?: Maybe<Scalars['uuid']>;
  pos?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type View_Queue_Positions_Min_Fields = {
  __typename?: 'view_queue_positions_min_fields';
  id?: Maybe<Scalars['uuid']>;
  pos?: Maybe<Scalars['bigint']>;
};

/** Ordering options when selecting data from "view_queue_positions". */
export type View_Queue_Positions_Order_By = {
  id?: Maybe<Order_By>;
  pos?: Maybe<Order_By>;
};

/** select columns of table "view_queue_positions" */
export enum View_Queue_Positions_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Pos = 'pos'
}

/** aggregate stddev on columns */
export type View_Queue_Positions_Stddev_Fields = {
  __typename?: 'view_queue_positions_stddev_fields';
  pos?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type View_Queue_Positions_Stddev_Pop_Fields = {
  __typename?: 'view_queue_positions_stddev_pop_fields';
  pos?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type View_Queue_Positions_Stddev_Samp_Fields = {
  __typename?: 'view_queue_positions_stddev_samp_fields';
  pos?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "view_queue_positions" */
export type View_Queue_Positions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: View_Queue_Positions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type View_Queue_Positions_Stream_Cursor_Value_Input = {
  id?: Maybe<Scalars['uuid']>;
  pos?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type View_Queue_Positions_Sum_Fields = {
  __typename?: 'view_queue_positions_sum_fields';
  pos?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type View_Queue_Positions_Var_Pop_Fields = {
  __typename?: 'view_queue_positions_var_pop_fields';
  pos?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type View_Queue_Positions_Var_Samp_Fields = {
  __typename?: 'view_queue_positions_var_samp_fields';
  pos?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type View_Queue_Positions_Variance_Fields = {
  __typename?: 'view_queue_positions_variance_fields';
  pos?: Maybe<Scalars['Float']>;
};


/** Boolean expression to compare columns of type "visualization_types". All fields are combined with logical 'AND'. */
export type Visualization_Types_Comparison_Exp = {
  _eq?: Maybe<Scalars['visualization_types']>;
  _gt?: Maybe<Scalars['visualization_types']>;
  _gte?: Maybe<Scalars['visualization_types']>;
  _in?: Maybe<Array<Scalars['visualization_types']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['visualization_types']>;
  _lte?: Maybe<Scalars['visualization_types']>;
  _neq?: Maybe<Scalars['visualization_types']>;
  _nin?: Maybe<Array<Scalars['visualization_types']>>;
};

/** columns and relationships of "visualization_widgets" */
export type Visualization_Widgets = {
  __typename?: 'visualization_widgets';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dashboard?: Maybe<Dashboards>;
  /** An array relationship */
  dashboard_api_keys: Array<Api_Keys>;
  /** An aggregate relationship */
  dashboard_api_keys_aggregate: Api_Keys_Aggregate;
  dashboard_id?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  options?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  param_widgets: Array<Param_Widgets>;
  /** An aggregate relationship */
  param_widgets_aggregate: Param_Widgets_Aggregate;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  visualization: Visualizations;
  visualization_id: Scalars['Int'];
};


/** columns and relationships of "visualization_widgets" */
export type Visualization_WidgetsDashboard_Api_KeysArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "visualization_widgets" */
export type Visualization_WidgetsDashboard_Api_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Api_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Api_Keys_Order_By>>;
  where?: Maybe<Api_Keys_Bool_Exp>;
};


/** columns and relationships of "visualization_widgets" */
export type Visualization_WidgetsOptionsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "visualization_widgets" */
export type Visualization_WidgetsParam_WidgetsArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};


/** columns and relationships of "visualization_widgets" */
export type Visualization_WidgetsParam_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Param_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Param_Widgets_Order_By>>;
  where?: Maybe<Param_Widgets_Bool_Exp>;
};

/** aggregated selection of "visualization_widgets" */
export type Visualization_Widgets_Aggregate = {
  __typename?: 'visualization_widgets_aggregate';
  aggregate?: Maybe<Visualization_Widgets_Aggregate_Fields>;
  nodes: Array<Visualization_Widgets>;
};

export type Visualization_Widgets_Aggregate_Bool_Exp = {
  count?: Maybe<Visualization_Widgets_Aggregate_Bool_Exp_Count>;
};

export type Visualization_Widgets_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Visualization_Widgets_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "visualization_widgets" */
export type Visualization_Widgets_Aggregate_Fields = {
  __typename?: 'visualization_widgets_aggregate_fields';
  avg?: Maybe<Visualization_Widgets_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Visualization_Widgets_Max_Fields>;
  min?: Maybe<Visualization_Widgets_Min_Fields>;
  stddev?: Maybe<Visualization_Widgets_Stddev_Fields>;
  stddev_pop?: Maybe<Visualization_Widgets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Visualization_Widgets_Stddev_Samp_Fields>;
  sum?: Maybe<Visualization_Widgets_Sum_Fields>;
  var_pop?: Maybe<Visualization_Widgets_Var_Pop_Fields>;
  var_samp?: Maybe<Visualization_Widgets_Var_Samp_Fields>;
  variance?: Maybe<Visualization_Widgets_Variance_Fields>;
};


/** aggregate fields of "visualization_widgets" */
export type Visualization_Widgets_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "visualization_widgets" */
export type Visualization_Widgets_Aggregate_Order_By = {
  avg?: Maybe<Visualization_Widgets_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Visualization_Widgets_Max_Order_By>;
  min?: Maybe<Visualization_Widgets_Min_Order_By>;
  stddev?: Maybe<Visualization_Widgets_Stddev_Order_By>;
  stddev_pop?: Maybe<Visualization_Widgets_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Visualization_Widgets_Stddev_Samp_Order_By>;
  sum?: Maybe<Visualization_Widgets_Sum_Order_By>;
  var_pop?: Maybe<Visualization_Widgets_Var_Pop_Order_By>;
  var_samp?: Maybe<Visualization_Widgets_Var_Samp_Order_By>;
  variance?: Maybe<Visualization_Widgets_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Visualization_Widgets_Append_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "visualization_widgets" */
export type Visualization_Widgets_Arr_Rel_Insert_Input = {
  data: Array<Visualization_Widgets_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Visualization_Widgets_On_Conflict>;
};

/** aggregate avg on columns */
export type Visualization_Widgets_Avg_Fields = {
  __typename?: 'visualization_widgets_avg_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  visualization_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Avg_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "visualization_widgets". All fields are combined with a logical 'AND'. */
export type Visualization_Widgets_Bool_Exp = {
  _and?: Maybe<Array<Visualization_Widgets_Bool_Exp>>;
  _not?: Maybe<Visualization_Widgets_Bool_Exp>;
  _or?: Maybe<Array<Visualization_Widgets_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dashboard?: Maybe<Dashboards_Bool_Exp>;
  dashboard_api_keys?: Maybe<Api_Keys_Bool_Exp>;
  dashboard_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Bool_Exp>;
  dashboard_id?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  options?: Maybe<Jsonb_Comparison_Exp>;
  param_widgets?: Maybe<Param_Widgets_Bool_Exp>;
  param_widgets_aggregate?: Maybe<Param_Widgets_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  visualization?: Maybe<Visualizations_Bool_Exp>;
  visualization_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "visualization_widgets" */
export enum Visualization_Widgets_Constraint {
  /** unique or primary key constraint on columns "id" */
  VisualizationWidgetsPkey = 'visualization_widgets_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Visualization_Widgets_Delete_At_Path_Input = {
  options?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Visualization_Widgets_Delete_Elem_Input = {
  options?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Visualization_Widgets_Delete_Key_Input = {
  options?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "visualization_widgets" */
export type Visualization_Widgets_Inc_Input = {
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  visualization_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "visualization_widgets" */
export type Visualization_Widgets_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard?: Maybe<Dashboards_Obj_Rel_Insert_Input>;
  dashboard_api_keys?: Maybe<Api_Keys_Arr_Rel_Insert_Input>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  options?: Maybe<Scalars['jsonb']>;
  param_widgets?: Maybe<Param_Widgets_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization?: Maybe<Visualizations_Obj_Rel_Insert_Input>;
  visualization_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Visualization_Widgets_Max_Fields = {
  __typename?: 'visualization_widgets_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Visualization_Widgets_Min_Fields = {
  __typename?: 'visualization_widgets_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "visualization_widgets" */
export type Visualization_Widgets_Mutation_Response = {
  __typename?: 'visualization_widgets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Visualization_Widgets>;
};

/** input type for inserting object relation for remote table "visualization_widgets" */
export type Visualization_Widgets_Obj_Rel_Insert_Input = {
  data: Visualization_Widgets_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Visualization_Widgets_On_Conflict>;
};

/** on_conflict condition type for table "visualization_widgets" */
export type Visualization_Widgets_On_Conflict = {
  constraint: Visualization_Widgets_Constraint;
  update_columns: Array<Visualization_Widgets_Update_Column>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};

/** Ordering options when selecting data from "visualization_widgets". */
export type Visualization_Widgets_Order_By = {
  created_at?: Maybe<Order_By>;
  dashboard?: Maybe<Dashboards_Order_By>;
  dashboard_api_keys_aggregate?: Maybe<Api_Keys_Aggregate_Order_By>;
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  options?: Maybe<Order_By>;
  param_widgets_aggregate?: Maybe<Param_Widgets_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  visualization?: Maybe<Visualizations_Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** primary key columns input for table: visualization_widgets */
export type Visualization_Widgets_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Visualization_Widgets_Prepend_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "visualization_widgets" */
export enum Visualization_Widgets_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VisualizationId = 'visualization_id'
}

/** input type for updating data in table "visualization_widgets" */
export type Visualization_Widgets_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  options?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Visualization_Widgets_Stddev_Fields = {
  __typename?: 'visualization_widgets_stddev_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  visualization_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Stddev_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Visualization_Widgets_Stddev_Pop_Fields = {
  __typename?: 'visualization_widgets_stddev_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  visualization_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Stddev_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Visualization_Widgets_Stddev_Samp_Fields = {
  __typename?: 'visualization_widgets_stddev_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  visualization_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Stddev_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "visualization_widgets" */
export type Visualization_Widgets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Visualization_Widgets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Visualization_Widgets_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  options?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Visualization_Widgets_Sum_Fields = {
  __typename?: 'visualization_widgets_sum_fields';
  dashboard_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  visualization_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Sum_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** update columns of table "visualization_widgets" */
export enum Visualization_Widgets_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DashboardId = 'dashboard_id',
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VisualizationId = 'visualization_id'
}

export type Visualization_Widgets_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Visualization_Widgets_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Visualization_Widgets_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Visualization_Widgets_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Visualization_Widgets_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Visualization_Widgets_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Visualization_Widgets_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Visualization_Widgets_Set_Input>;
  where: Visualization_Widgets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Visualization_Widgets_Var_Pop_Fields = {
  __typename?: 'visualization_widgets_var_pop_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  visualization_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Var_Pop_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Visualization_Widgets_Var_Samp_Fields = {
  __typename?: 'visualization_widgets_var_samp_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  visualization_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Var_Samp_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Visualization_Widgets_Variance_Fields = {
  __typename?: 'visualization_widgets_variance_fields';
  dashboard_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  visualization_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "visualization_widgets" */
export type Visualization_Widgets_Variance_Order_By = {
  dashboard_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  visualization_id?: Maybe<Order_By>;
};

/** columns and relationships of "visualizations" */
export type Visualizations = {
  __typename?: 'visualizations';
  created_at: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  options: Scalars['jsonb'];
  /** An object relationship */
  query: Queries;
  /** An object relationship */
  query_details?: Maybe<Query_Details>;
  query_id: Scalars['Int'];
  type: Scalars['visualization_types'];
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  visualization_widgets: Array<Visualization_Widgets>;
  /** An aggregate relationship */
  visualization_widgets_aggregate: Visualization_Widgets_Aggregate;
};


/** columns and relationships of "visualizations" */
export type VisualizationsOptionsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "visualizations" */
export type VisualizationsVisualization_WidgetsArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};


/** columns and relationships of "visualizations" */
export type VisualizationsVisualization_Widgets_AggregateArgs = {
  distinct_on?: Maybe<Array<Visualization_Widgets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Visualization_Widgets_Order_By>>;
  where?: Maybe<Visualization_Widgets_Bool_Exp>;
};

/** aggregated selection of "visualizations" */
export type Visualizations_Aggregate = {
  __typename?: 'visualizations_aggregate';
  aggregate?: Maybe<Visualizations_Aggregate_Fields>;
  nodes: Array<Visualizations>;
};

export type Visualizations_Aggregate_Bool_Exp = {
  count?: Maybe<Visualizations_Aggregate_Bool_Exp_Count>;
};

export type Visualizations_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Visualizations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Visualizations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "visualizations" */
export type Visualizations_Aggregate_Fields = {
  __typename?: 'visualizations_aggregate_fields';
  avg?: Maybe<Visualizations_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Visualizations_Max_Fields>;
  min?: Maybe<Visualizations_Min_Fields>;
  stddev?: Maybe<Visualizations_Stddev_Fields>;
  stddev_pop?: Maybe<Visualizations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Visualizations_Stddev_Samp_Fields>;
  sum?: Maybe<Visualizations_Sum_Fields>;
  var_pop?: Maybe<Visualizations_Var_Pop_Fields>;
  var_samp?: Maybe<Visualizations_Var_Samp_Fields>;
  variance?: Maybe<Visualizations_Variance_Fields>;
};


/** aggregate fields of "visualizations" */
export type Visualizations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Visualizations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "visualizations" */
export type Visualizations_Aggregate_Order_By = {
  avg?: Maybe<Visualizations_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Visualizations_Max_Order_By>;
  min?: Maybe<Visualizations_Min_Order_By>;
  stddev?: Maybe<Visualizations_Stddev_Order_By>;
  stddev_pop?: Maybe<Visualizations_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Visualizations_Stddev_Samp_Order_By>;
  sum?: Maybe<Visualizations_Sum_Order_By>;
  var_pop?: Maybe<Visualizations_Var_Pop_Order_By>;
  var_samp?: Maybe<Visualizations_Var_Samp_Order_By>;
  variance?: Maybe<Visualizations_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Visualizations_Append_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "visualizations" */
export type Visualizations_Arr_Rel_Insert_Input = {
  data: Array<Visualizations_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Visualizations_On_Conflict>;
};

/** aggregate avg on columns */
export type Visualizations_Avg_Fields = {
  __typename?: 'visualizations_avg_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "visualizations" */
export type Visualizations_Avg_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "visualizations". All fields are combined with a logical 'AND'. */
export type Visualizations_Bool_Exp = {
  _and?: Maybe<Array<Visualizations_Bool_Exp>>;
  _not?: Maybe<Visualizations_Bool_Exp>;
  _or?: Maybe<Array<Visualizations_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  options?: Maybe<Jsonb_Comparison_Exp>;
  query?: Maybe<Queries_Bool_Exp>;
  query_details?: Maybe<Query_Details_Bool_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  type?: Maybe<Visualization_Types_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  visualization_widgets?: Maybe<Visualization_Widgets_Bool_Exp>;
  visualization_widgets_aggregate?: Maybe<Visualization_Widgets_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "visualizations" */
export enum Visualizations_Constraint {
  /** unique or primary key constraint on columns "id" */
  VisualizationsPkey = 'visualizations_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Visualizations_Delete_At_Path_Input = {
  options?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Visualizations_Delete_Elem_Input = {
  options?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Visualizations_Delete_Key_Input = {
  options?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "visualizations" */
export type Visualizations_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "visualizations" */
export type Visualizations_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  options?: Maybe<Scalars['jsonb']>;
  query?: Maybe<Queries_Obj_Rel_Insert_Input>;
  query_details?: Maybe<Query_Details_Obj_Rel_Insert_Input>;
  query_id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['visualization_types']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  visualization_widgets?: Maybe<Visualization_Widgets_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Visualizations_Max_Fields = {
  __typename?: 'visualizations_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['visualization_types']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "visualizations" */
export type Visualizations_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Visualizations_Min_Fields = {
  __typename?: 'visualizations_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  query_id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['visualization_types']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "visualizations" */
export type Visualizations_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "visualizations" */
export type Visualizations_Mutation_Response = {
  __typename?: 'visualizations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Visualizations>;
};

/** input type for inserting object relation for remote table "visualizations" */
export type Visualizations_Obj_Rel_Insert_Input = {
  data: Visualizations_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Visualizations_On_Conflict>;
};

/** on_conflict condition type for table "visualizations" */
export type Visualizations_On_Conflict = {
  constraint: Visualizations_Constraint;
  update_columns: Array<Visualizations_Update_Column>;
  where?: Maybe<Visualizations_Bool_Exp>;
};

/** Ordering options when selecting data from "visualizations". */
export type Visualizations_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  options?: Maybe<Order_By>;
  query?: Maybe<Queries_Order_By>;
  query_details?: Maybe<Query_Details_Order_By>;
  query_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  visualization_widgets_aggregate?: Maybe<Visualization_Widgets_Aggregate_Order_By>;
};

/** primary key columns input for table: visualizations */
export type Visualizations_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Visualizations_Prepend_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "visualizations" */
export enum Visualizations_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Options = 'options',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "visualizations" */
export type Visualizations_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  options?: Maybe<Scalars['jsonb']>;
  query_id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['visualization_types']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Visualizations_Stddev_Fields = {
  __typename?: 'visualizations_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "visualizations" */
export type Visualizations_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Visualizations_Stddev_Pop_Fields = {
  __typename?: 'visualizations_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "visualizations" */
export type Visualizations_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Visualizations_Stddev_Samp_Fields = {
  __typename?: 'visualizations_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "visualizations" */
export type Visualizations_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "visualizations" */
export type Visualizations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Visualizations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Visualizations_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  options?: Maybe<Scalars['jsonb']>;
  query_id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['visualization_types']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Visualizations_Sum_Fields = {
  __typename?: 'visualizations_sum_fields';
  id?: Maybe<Scalars['Int']>;
  query_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "visualizations" */
export type Visualizations_Sum_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** update columns of table "visualizations" */
export enum Visualizations_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Options = 'options',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Visualizations_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Visualizations_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Visualizations_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Visualizations_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Visualizations_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Visualizations_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Visualizations_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Visualizations_Set_Input>;
  where: Visualizations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Visualizations_Var_Pop_Fields = {
  __typename?: 'visualizations_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "visualizations" */
export type Visualizations_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Visualizations_Var_Samp_Fields = {
  __typename?: 'visualizations_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "visualizations" */
export type Visualizations_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Visualizations_Variance_Fields = {
  __typename?: 'visualizations_variance_fields';
  id?: Maybe<Scalars['Float']>;
  query_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "visualizations" */
export type Visualizations_Variance_Order_By = {
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
};

/** columns and relationships of "wand_completions" */
export type Wand_Completions = {
  __typename?: 'wand_completions';
  answer: Scalars['String'];
  created_at: Scalars['timestamp'];
  id: Scalars['uuid'];
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  reaction?: Maybe<Scalars['Int']>;
  updated_at: Scalars['timestamp'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id: Scalars['Int'];
};

/** aggregated selection of "wand_completions" */
export type Wand_Completions_Aggregate = {
  __typename?: 'wand_completions_aggregate';
  aggregate?: Maybe<Wand_Completions_Aggregate_Fields>;
  nodes: Array<Wand_Completions>;
};

/** aggregate fields of "wand_completions" */
export type Wand_Completions_Aggregate_Fields = {
  __typename?: 'wand_completions_aggregate_fields';
  avg?: Maybe<Wand_Completions_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Wand_Completions_Max_Fields>;
  min?: Maybe<Wand_Completions_Min_Fields>;
  stddev?: Maybe<Wand_Completions_Stddev_Fields>;
  stddev_pop?: Maybe<Wand_Completions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Wand_Completions_Stddev_Samp_Fields>;
  sum?: Maybe<Wand_Completions_Sum_Fields>;
  var_pop?: Maybe<Wand_Completions_Var_Pop_Fields>;
  var_samp?: Maybe<Wand_Completions_Var_Samp_Fields>;
  variance?: Maybe<Wand_Completions_Variance_Fields>;
};


/** aggregate fields of "wand_completions" */
export type Wand_Completions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Wand_Completions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Wand_Completions_Avg_Fields = {
  __typename?: 'wand_completions_avg_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  reaction?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "wand_completions". All fields are combined with a logical 'AND'. */
export type Wand_Completions_Bool_Exp = {
  _and?: Maybe<Array<Wand_Completions_Bool_Exp>>;
  _not?: Maybe<Wand_Completions_Bool_Exp>;
  _or?: Maybe<Array<Wand_Completions_Bool_Exp>>;
  answer?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  query_id?: Maybe<Int_Comparison_Exp>;
  query_version?: Maybe<Int_Comparison_Exp>;
  question?: Maybe<String_Comparison_Exp>;
  reaction?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamp_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "wand_completions" */
export enum Wand_Completions_Constraint {
  /** unique or primary key constraint on columns "id" */
  NlqPromptsPkey = 'nlq_prompts_pkey'
}

/** input type for incrementing numeric columns in table "wand_completions" */
export type Wand_Completions_Inc_Input = {
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  reaction?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "wand_completions" */
export type Wand_Completions_Insert_Input = {
  answer?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  reaction?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Wand_Completions_Max_Fields = {
  __typename?: 'wand_completions_max_fields';
  answer?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  reaction?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Wand_Completions_Min_Fields = {
  __typename?: 'wand_completions_min_fields';
  answer?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  reaction?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "wand_completions" */
export type Wand_Completions_Mutation_Response = {
  __typename?: 'wand_completions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Wand_Completions>;
};

/** on_conflict condition type for table "wand_completions" */
export type Wand_Completions_On_Conflict = {
  constraint: Wand_Completions_Constraint;
  update_columns: Array<Wand_Completions_Update_Column>;
  where?: Maybe<Wand_Completions_Bool_Exp>;
};

/** Ordering options when selecting data from "wand_completions". */
export type Wand_Completions_Order_By = {
  answer?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  query_id?: Maybe<Order_By>;
  query_version?: Maybe<Order_By>;
  question?: Maybe<Order_By>;
  reaction?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: wand_completions */
export type Wand_Completions_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "wand_completions" */
export enum Wand_Completions_Select_Column {
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  Question = 'question',
  /** column name */
  Reaction = 'reaction',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "wand_completions" */
export type Wand_Completions_Set_Input = {
  answer?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  reaction?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Wand_Completions_Stddev_Fields = {
  __typename?: 'wand_completions_stddev_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  reaction?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Wand_Completions_Stddev_Pop_Fields = {
  __typename?: 'wand_completions_stddev_pop_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  reaction?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Wand_Completions_Stddev_Samp_Fields = {
  __typename?: 'wand_completions_stddev_samp_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  reaction?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "wand_completions" */
export type Wand_Completions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Wand_Completions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Wand_Completions_Stream_Cursor_Value_Input = {
  answer?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  reaction?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Wand_Completions_Sum_Fields = {
  __typename?: 'wand_completions_sum_fields';
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
  reaction?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "wand_completions" */
export enum Wand_Completions_Update_Column {
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  QueryId = 'query_id',
  /** column name */
  QueryVersion = 'query_version',
  /** column name */
  Question = 'question',
  /** column name */
  Reaction = 'reaction',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Wand_Completions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Wand_Completions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Wand_Completions_Set_Input>;
  where: Wand_Completions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Wand_Completions_Var_Pop_Fields = {
  __typename?: 'wand_completions_var_pop_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  reaction?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Wand_Completions_Var_Samp_Fields = {
  __typename?: 'wand_completions_var_samp_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  reaction?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Wand_Completions_Variance_Fields = {
  __typename?: 'wand_completions_variance_fields';
  query_id?: Maybe<Scalars['Float']>;
  query_version?: Maybe<Scalars['Float']>;
  reaction?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

export type ApplyDowngradeApiUserSubscriptionMutationVariables = Exact<{
  userId: Scalars['Int'];
  subscriptionId?: Maybe<Scalars['String']>;
  subscriptionStartDate?: Maybe<Scalars['timestamptz']>;
  serviceTierId?: Maybe<Scalars['Int']>;
}>;


export type ApplyDowngradeApiUserSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { update_users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
  )>, delete_pending_api_user_subscription_updates?: Maybe<(
    { __typename?: 'pending_api_user_subscription_updates_mutation_response' }
    & Pick<Pending_Api_User_Subscription_Updates_Mutation_Response, 'affected_rows'>
  )> }
);

export type FinalizeUpgradeApiUserSubscriptionMutationVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type FinalizeUpgradeApiUserSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { delete_pending_api_user_subscription_updates?: Maybe<(
    { __typename?: 'pending_api_user_subscription_updates_mutation_response' }
    & Pick<Pending_Api_User_Subscription_Updates_Mutation_Response, 'affected_rows'>
  )> }
);

export type UpdateTeamAfterUpgradeMutationVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type UpdateTeamAfterUpgradeMutation = (
  { __typename?: 'mutation_root' }
  & { delete_pending_team_subscription_updates?: Maybe<(
    { __typename?: 'pending_team_subscription_updates_mutation_response' }
    & Pick<Pending_Team_Subscription_Updates_Mutation_Response, 'affected_rows'>
  )> }
);

export type ApplyTeamServiceTierUpdateMutationVariables = Exact<{
  teamId: Scalars['Int'];
  serviceTierId: Scalars['Int'];
  orbSubscriptionId?: Maybe<Scalars['String']>;
  orbSubscriptionAnchorDay?: Maybe<Scalars['Int']>;
  executionQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  csvDownloadQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  maxOverageCents?: Maybe<Scalars['numeric']>;
  updateTeamMaxOverageCents: Scalars['Boolean'];
}>;


export type ApplyTeamServiceTierUpdateMutation = (
  { __typename?: 'mutation_root' }
  & { update_teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
  )>, update_max_overage_cents?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
  )>, delete_pending_team_subscription_updates?: Maybe<(
    { __typename?: 'pending_team_subscription_updates_mutation_response' }
    & Pick<Pending_Team_Subscription_Updates_Mutation_Response, 'affected_rows'>
  )> }
);

export type UpdateTeamServiceTierMutationVariables = Exact<{
  teamId: Scalars['Int'];
  serviceTierId: Scalars['Int'];
  orbSubscriptionId?: Maybe<Scalars['String']>;
  executionQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  csvDownloadQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  maxOverageCents?: Maybe<Scalars['numeric']>;
  updateTeamMaxOverageCents: Scalars['Boolean'];
}>;


export type UpdateTeamServiceTierMutation = (
  { __typename?: 'mutation_root' }
  & { update_teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
  )>, update_max_overage_cents?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
  )> }
);

export type ApplyUserServiceTierUpdateMutationVariables = Exact<{
  userId: Scalars['Int'];
  serviceTierId: Scalars['Int'];
  orbSubscriptionId?: Maybe<Scalars['String']>;
  orbSubscriptionAnchorDay?: Maybe<Scalars['Int']>;
  executionQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  csvDownloadQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  maxOverageCents?: Maybe<Scalars['numeric']>;
  updateUserMaxOverageCents: Scalars['Boolean'];
}>;


export type ApplyUserServiceTierUpdateMutation = (
  { __typename?: 'mutation_root' }
  & { update_users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
  )>, update_max_overage_cents?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
  )>, delete_pending_user_subscription_updates?: Maybe<(
    { __typename?: 'pending_user_subscription_updates_mutation_response' }
    & Pick<Pending_User_Subscription_Updates_Mutation_Response, 'affected_rows'>
  )> }
);

export type UpdateUserAfterUpgradeMutationVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type UpdateUserAfterUpgradeMutation = (
  { __typename?: 'mutation_root' }
  & { delete_pending_user_subscription_updates?: Maybe<(
    { __typename?: 'pending_user_subscription_updates_mutation_response' }
    & Pick<Pending_User_Subscription_Updates_Mutation_Response, 'affected_rows'>
  )> }
);

export type UpdateUserServiceTierMutationVariables = Exact<{
  userId: Scalars['Int'];
  serviceTierId: Scalars['Int'];
  orbSubscriptionId?: Maybe<Scalars['String']>;
  executionQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  csvDownloadQuotaExceededUntil?: Maybe<Scalars['timestamptz']>;
  maxOverageCents?: Maybe<Scalars['numeric']>;
  updateUserMaxOverageCents: Scalars['Boolean'];
}>;


export type UpdateUserServiceTierMutation = (
  { __typename?: 'mutation_root' }
  & { update_users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
  )>, update_max_overage_cents?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
  )> }
);

export type GetPendingApiUserSubUpdatesQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type GetPendingApiUserSubUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_api_user_subscription_updates: Array<(
    { __typename?: 'pending_api_user_subscription_updates' }
    & Pick<Pending_Api_User_Subscription_Updates, 'user_id' | 'update_type' | 'soft_deadline' | 'update_date' | 'base_plan_id' | 'orb_subscription_id' | 'orb_subscription_start_date'>
    & { api_user_service_tier?: Maybe<(
      { __typename?: 'api_user_service_tiers' }
      & Pick<Api_User_Service_Tiers, 'id' | 'name'>
    )> }
  )> }
);

export type GetPendingTeamSubUpdatesQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetPendingTeamSubUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_team_subscription_updates: Array<(
    { __typename?: 'pending_team_subscription_updates' }
    & Pick<Pending_Team_Subscription_Updates, 'base_plan_id' | 'update_date' | 'orb_subscription_id' | 'orb_subscription_anchor_day' | 'soft_deadline' | 'update_type' | 'team_id' | 'metadata'>
    & { service_tier: (
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'name'>
    ) }
  )> }
);

export type GetPendingUserSubUpdatesQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type GetPendingUserSubUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_user_subscription_updates: Array<(
    { __typename?: 'pending_user_subscription_updates' }
    & Pick<Pending_User_Subscription_Updates, 'base_plan_id' | 'update_date' | 'orb_subscription_id' | 'orb_subscription_anchor_day' | 'soft_deadline' | 'update_type' | 'user_id' | 'metadata'>
    & { service_tier: (
      { __typename?: 'user_service_tiers' }
      & Pick<User_Service_Tiers, 'id' | 'name' | 'release_version'>
    ) }
  )> }
);

export type UpdatePendingTeamSubUpdatesMutationVariables = Exact<{
  teamId: Scalars['Int'];
  serviceTierId: Scalars['Int'];
}>;


export type UpdatePendingTeamSubUpdatesMutation = (
  { __typename?: 'mutation_root' }
  & { update_pending_team_subscription_updates_by_pk?: Maybe<(
    { __typename?: 'pending_team_subscription_updates' }
    & Pick<Pending_Team_Subscription_Updates, 'team_id'>
  )> }
);

export type UpdatePendingUserSubUpdatesMutationVariables = Exact<{
  userId: Scalars['Int'];
  serviceTierId: Scalars['Int'];
}>;


export type UpdatePendingUserSubUpdatesMutation = (
  { __typename?: 'mutation_root' }
  & { update_pending_user_subscription_updates_by_pk?: Maybe<(
    { __typename?: 'pending_user_subscription_updates' }
    & Pick<Pending_User_Subscription_Updates, 'user_id'>
  )> }
);

export type TeamByOrbCustomerIdQueryVariables = Exact<{
  orbCustomerId: Scalars['String'];
}>;


export type TeamByOrbCustomerIdQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'name' | 'handle' | 'orb_subscription_id' | 'service_tier_id'>
    & { service_tier: (
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'name'>
    ) }
  )> }
);

export type UpdateTeamAccountForServiceTierMutationVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type UpdateTeamAccountForServiceTierMutation = (
  { __typename?: 'mutation_root' }
  & { update_team_account_for_service_tier?: Maybe<{ __typename: 'UpdateTeamAccountForServiceTierResponse' }> }
);

export type UpdateUserAccountForServiceTierMutationVariables = Exact<{
  userId: Scalars['Int'];
  serviceTierId: Scalars['Int'];
}>;


export type UpdateUserAccountForServiceTierMutation = (
  { __typename?: 'mutation_root' }
  & { update_account_for_service_tier?: Maybe<(
    { __typename?: 'UpdateAccountForServiceTierResponse' }
    & Pick<UpdateAccountForServiceTierResponse, 'archived_dashboards_count' | 'archived_queries_count'>
  )> }
);

export type ProjectNamesQueryVariables = Exact<{
  blockchain: Scalars['blockchain_name'];
}>;


export type ProjectNamesQuery = (
  { __typename?: 'query_root' }
  & { contract_submissions: Array<(
    { __typename?: 'contract_submissions' }
    & Pick<Contract_Submissions, 'project_name'>
  )> }
);

export type GetExistingContractSubmissionQueryVariables = Exact<{
  address: Scalars['String'];
  blockchain: Scalars['blockchain_name'];
}>;


export type GetExistingContractSubmissionQuery = (
  { __typename?: 'query_root' }
  & { contract_submissions: Array<(
    { __typename?: 'contract_submissions' }
    & Pick<Contract_Submissions, 'id' | 'contract_name' | 'project_name' | 'status'>
  )> }
);

export type SubmitContractMutationVariables = Exact<{
  blockchain: Scalars['blockchain_name'];
  address: Scalars['String'];
  project_name: Scalars['String'];
  contract_name: Scalars['String'];
  abi: Scalars['jsonb'];
  has_multiple_instances: Scalars['Boolean'];
  is_created_by_factory: Scalars['Boolean'];
  is_manual_abi: Scalars['Boolean'];
  is_proxy: Scalars['Boolean'];
  cognito_user_id: Scalars['uuid'];
  resubmission_reason?: Maybe<Scalars['String']>;
}>;


export type SubmitContractMutation = (
  { __typename?: 'mutation_root' }
  & { insert_contract_submissions?: Maybe<(
    { __typename?: 'contract_submissions_mutation_response' }
    & Pick<Contract_Submissions_Mutation_Response, 'affected_rows'>
  )> }
);

export type RefetchDashboardFavoritesQueryVariables = Exact<{
  id: Scalars['Int'];
  session_id: Scalars['Int'];
}>;


export type RefetchDashboardFavoritesQuery = (
  { __typename?: 'query_root' }
  & { dashboards_by_pk?: Maybe<(
    { __typename?: 'dashboards' }
    & Pick<Dashboards, 'id'>
    & { favorite_dashboards: Array<(
      { __typename?: 'favorite_dashboards' }
      & Pick<Favorite_Dashboards, 'created_at'>
    )>, dashboard_favorite_count_all?: Maybe<(
      { __typename?: 'dashboard_favorite_count_all' }
      & Pick<Dashboard_Favorite_Count_All, 'favorite_count'>
    )>, dashboard_favorite_count_last_24h?: Maybe<(
      { __typename?: 'dashboard_favorite_count_last_24h' }
      & Pick<Dashboard_Favorite_Count_Last_24h, 'favorite_count'>
    )>, dashboard_favorite_count_last_7d?: Maybe<(
      { __typename?: 'dashboard_favorite_count_last_7d' }
      & Pick<Dashboard_Favorite_Count_Last_7d, 'favorite_count'>
    )>, dashboard_favorite_count_last_30d?: Maybe<(
      { __typename?: 'dashboard_favorite_count_last_30d' }
      & Pick<Dashboard_Favorite_Count_Last_30d, 'favorite_count'>
    )> }
  )> }
);

export type DashboardItemFragment = (
  { __typename?: 'dashboards' }
  & Pick<Dashboards, 'id' | 'name' | 'slug' | 'created_at' | 'updated_at' | 'tags' | 'is_private'>
  & { user?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'name' | 'profile_image_url'>
  )>, team?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'handle' | 'profile_image_url'>
  )>, dashboard_favorite_count_all?: Maybe<(
    { __typename?: 'dashboard_favorite_count_all' }
    & Pick<Dashboard_Favorite_Count_All, 'favorite_count'>
  )>, dashboard_favorite_count_last_24h?: Maybe<(
    { __typename?: 'dashboard_favorite_count_last_24h' }
    & Pick<Dashboard_Favorite_Count_Last_24h, 'favorite_count'>
  )>, dashboard_favorite_count_last_7d?: Maybe<(
    { __typename?: 'dashboard_favorite_count_last_7d' }
    & Pick<Dashboard_Favorite_Count_Last_7d, 'favorite_count'>
  )>, dashboard_favorite_count_last_30d?: Maybe<(
    { __typename?: 'dashboard_favorite_count_last_30d' }
    & Pick<Dashboard_Favorite_Count_Last_30d, 'favorite_count'>
  )>, trending_scores?: Maybe<(
    { __typename?: 'dashboard_trending_scores' }
    & Pick<Dashboard_Trending_Scores, 'score_1h' | 'score_4h' | 'score_24h' | 'updated_at'>
  )> }
);

export type ListBrowseDashboardsQueryVariables = Exact<{
  filter_name?: Maybe<String_Comparison_Exp>;
  filter_tags?: Maybe<Jsonb_Comparison_Exp>;
  filter_custom?: Maybe<Array<Dashboards_Bool_Exp> | Dashboards_Bool_Exp>;
  order?: Maybe<Array<Dashboards_Order_By> | Dashboards_Order_By>;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  include_favs_last_24h?: Scalars['Boolean'];
  include_favs_last_7d?: Scalars['Boolean'];
  include_favs_last_30d?: Scalars['Boolean'];
  include_favs_all_time?: Scalars['Boolean'];
}>;


export type ListBrowseDashboardsQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & DashboardItemFragment
  )>, dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type DashboardsFavoritesQueryVariables = Exact<{
  dashboard_ids: Array<Scalars['Int']> | Scalars['Int'];
  session_id?: Maybe<Scalars['Int']>;
}>;


export type DashboardsFavoritesQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & Pick<Dashboards, 'id'>
    & { favorite_dashboards: Array<(
      { __typename?: 'favorite_dashboards' }
      & Pick<Favorite_Dashboards, 'created_at'>
    )> }
  )> }
);

export type RefetchFavoritesQueryVariables = Exact<{
  id: Scalars['Int'];
  session_id: Scalars['Int'];
}>;


export type RefetchFavoritesQuery = (
  { __typename?: 'query_root' }
  & { queries_by_pk?: Maybe<(
    { __typename?: 'queries' }
    & Pick<Queries, 'id'>
    & { favorite_queries: Array<(
      { __typename?: 'favorite_queries' }
      & Pick<Favorite_Queries, 'created_at'>
    )>, query_favorite_count_all?: Maybe<(
      { __typename?: 'query_favorite_count_all' }
      & Pick<Query_Favorite_Count_All, 'favorite_count'>
    )>, query_favorite_count_last_24h?: Maybe<(
      { __typename?: 'query_favorite_count_last_24h' }
      & Pick<Query_Favorite_Count_Last_24h, 'favorite_count'>
    )>, query_favorite_count_last_7d?: Maybe<(
      { __typename?: 'query_favorite_count_last_7d' }
      & Pick<Query_Favorite_Count_Last_7d, 'favorite_count'>
    )>, query_favorite_count_last_30d?: Maybe<(
      { __typename?: 'query_favorite_count_last_30d' }
      & Pick<Query_Favorite_Count_Last_30d, 'favorite_count'>
    )> }
  )> }
);

export type ListBrowseQueriesQueryVariables = Exact<{
  filter_name: String_Comparison_Exp;
  filter_tags?: Maybe<Jsonb_Comparison_Exp>;
  filter_custom?: Maybe<Array<Queries_Bool_Exp> | Queries_Bool_Exp>;
  order?: Maybe<Array<Queries_Order_By> | Queries_Order_By>;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  include_favs_last_24h?: Scalars['Boolean'];
  include_favs_last_7d?: Scalars['Boolean'];
  include_favs_last_30d?: Scalars['Boolean'];
  include_favs_all_time?: Scalars['Boolean'];
}>;


export type ListBrowseQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & QueryItemFragment
  )>, queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type QueryItemFragment = (
  { __typename?: 'queries' }
  & Pick<Queries, 'id' | 'name' | 'created_at' | 'updated_at' | 'tags' | 'matview_id' | 'is_private'>
  & { user?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name' | 'profile_image_url'>
  )>, team?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'handle' | 'profile_image_url'>
  )>, query_favorite_count_all?: Maybe<(
    { __typename?: 'query_favorite_count_all' }
    & Pick<Query_Favorite_Count_All, 'favorite_count'>
  )>, query_favorite_count_last_24h?: Maybe<(
    { __typename?: 'query_favorite_count_last_24h' }
    & Pick<Query_Favorite_Count_Last_24h, 'favorite_count'>
  )>, query_favorite_count_last_7d?: Maybe<(
    { __typename?: 'query_favorite_count_last_7d' }
    & Pick<Query_Favorite_Count_Last_7d, 'favorite_count'>
  )>, query_favorite_count_last_30d?: Maybe<(
    { __typename?: 'query_favorite_count_last_30d' }
    & Pick<Query_Favorite_Count_Last_30d, 'favorite_count'>
  )> }
);

export type QueriesFavoritesQueryVariables = Exact<{
  query_ids: Array<Scalars['Int']> | Scalars['Int'];
  session_id?: Maybe<Scalars['Int']>;
}>;


export type QueriesFavoritesQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & Pick<Queries, 'id'>
    & { favorite_queries: Array<(
      { __typename?: 'favorite_queries' }
      & Pick<Favorite_Queries, 'created_at'>
    )> }
  )> }
);

export type ListDiscoverTeamsQueryVariables = Exact<{
  filter_name: String_Comparison_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type ListDiscoverTeamsQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & TeamItemFragment
  )>, teams_aggregate: (
    { __typename?: 'teams_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'teams_aggregate_fields' }
      & Pick<Teams_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type TeamItemFragment = (
  { __typename?: 'teams' }
  & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url' | 'created_at'>
  & { received_stars?: Maybe<(
    { __typename?: 'team_received_stars' }
    & Pick<Team_Received_Stars, 'sum'>
  )>, members: Array<(
    { __typename?: 'memberships' }
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name' | 'profile_image_url'>
    )> }
  )> }
);

export type GetGlobalSearchResultsQueryVariables = Exact<{
  query: String_Comparison_Exp;
}>;


export type GetGlobalSearchResultsQuery = (
  { __typename?: 'query_root' }
  & { dashboard_favorite_count_all: Array<(
    { __typename?: 'dashboard_favorite_count_all' }
    & { dashboard?: Maybe<(
      { __typename?: 'dashboards' }
      & Pick<Dashboards, 'id' | 'name' | 'slug'>
      & { user?: Maybe<(
        { __typename?: 'users' }
        & Pick<Users, 'id' | 'name' | 'profile_image_url'>
      )>, team?: Maybe<(
        { __typename?: 'teams' }
        & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url'>
      )> }
    )> }
  )>, query_favorite_count_all: Array<(
    { __typename?: 'query_favorite_count_all' }
    & { query?: Maybe<(
      { __typename?: 'queries' }
      & Pick<Queries, 'id' | 'name'>
      & { user?: Maybe<(
        { __typename?: 'users' }
        & Pick<Users, 'id' | 'name' | 'profile_image_url'>
      )>, team?: Maybe<(
        { __typename?: 'teams' }
        & Pick<Teams, 'id' | 'handle' | 'name' | 'profile_image_url'>
      )> }
    )> }
  )>, user_received_stars: Array<(
    { __typename?: 'user_received_stars' }
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name' | 'profile_image_url'>
    )> }
  )>, teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'handle' | 'name' | 'profile_image_url'>
  )> }
);

export type ListContractsQueryVariables = Exact<{
  cognito_user_id?: Maybe<Scalars['uuid']>;
  freetext_filter: String_Comparison_Exp;
  status_filter: Contract_Submission_Status_Comparison_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type ListContractsQuery = (
  { __typename?: 'query_root' }
  & { contract_submissions: Array<(
    { __typename?: 'contract_submissions' }
    & Pick<Contract_Submissions, 'id' | 'project_name' | 'contract_name' | 'address' | 'abi' | 'blockchain' | 'is_proxy' | 'is_manual_abi' | 'has_multiple_instances' | 'is_created_by_factory' | 'cognito_user_id' | 'comment' | 'resubmission_reason' | 'status' | 'created_at'>
  )>, contract_submissions_aggregate: (
    { __typename?: 'contract_submissions_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'contract_submissions_aggregate_fields' }
      & Pick<Contract_Submissions_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListMyDashboardsQueryVariables = Exact<{
  filter_name?: Maybe<String_Comparison_Exp>;
  filter_tags?: Maybe<Jsonb_Comparison_Exp>;
  filter_is_private?: Maybe<Boolean_Comparison_Exp>;
  filter_custom?: Maybe<Array<Dashboards_Bool_Exp> | Dashboards_Bool_Exp>;
  order?: Maybe<Array<Dashboards_Order_By> | Dashboards_Order_By>;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  include_favs_last_24h?: Scalars['Boolean'];
  include_favs_last_7d?: Scalars['Boolean'];
  include_favs_last_30d?: Scalars['Boolean'];
  include_favs_all_time?: Scalars['Boolean'];
  is_archived?: Scalars['Boolean'];
}>;


export type ListMyDashboardsQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & DashboardItemFragment
  )>, dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListMyFavoriteDashboardsQueryVariables = Exact<{
  session_id: Scalars['Int'];
  filter_name?: Maybe<String_Comparison_Exp>;
  filter_tags?: Maybe<Jsonb_Comparison_Exp>;
  filter_custom?: Maybe<Array<Dashboards_Bool_Exp> | Dashboards_Bool_Exp>;
  order?: Maybe<Array<Dashboards_Order_By> | Dashboards_Order_By>;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  include_favs_last_24h?: Scalars['Boolean'];
  include_favs_last_7d?: Scalars['Boolean'];
  include_favs_last_30d?: Scalars['Boolean'];
  include_favs_all_time?: Scalars['Boolean'];
}>;


export type ListMyFavoriteDashboardsQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & DashboardItemFragment
  )>, dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListMyFavoriteQueriesQueryVariables = Exact<{
  session_id: Scalars['Int'];
  filter_name: String_Comparison_Exp;
  filter_tags?: Maybe<Jsonb_Comparison_Exp>;
  filter_custom?: Maybe<Array<Queries_Bool_Exp> | Queries_Bool_Exp>;
  order?: Maybe<Array<Queries_Order_By> | Queries_Order_By>;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  include_favs_last_24h?: Scalars['Boolean'];
  include_favs_last_7d?: Scalars['Boolean'];
  include_favs_last_30d?: Scalars['Boolean'];
  include_favs_all_time?: Scalars['Boolean'];
}>;


export type ListMyFavoriteQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & QueryItemFragment
  )>, queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListMyQueriesQueryVariables = Exact<{
  filter_name?: Maybe<String_Comparison_Exp>;
  filter_tags?: Maybe<Jsonb_Comparison_Exp>;
  filter_is_private?: Maybe<Boolean_Comparison_Exp>;
  filter_is_matview?: Maybe<String_Comparison_Exp>;
  filter_custom?: Maybe<Array<Queries_Bool_Exp> | Queries_Bool_Exp>;
  is_archived: Scalars['Boolean'];
  order?: Maybe<Array<Queries_Order_By> | Queries_Order_By>;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  include_favs_last_24h?: Scalars['Boolean'];
  include_favs_last_7d?: Scalars['Boolean'];
  include_favs_last_30d?: Scalars['Boolean'];
  include_favs_all_time?: Scalars['Boolean'];
}>;


export type ListMyQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & QueryItemFragment
  )>, queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListOtherTeamMembersQueryVariables = Exact<{
  user_id: Scalars['Int'];
  team_id: Scalars['Int'];
}>;


export type ListOtherTeamMembersQuery = (
  { __typename?: 'query_root' }
  & { memberships_private_details: Array<(
    { __typename?: 'memberships_private_details' }
    & Pick<Memberships_Private_Details, 'role'>
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name'>
    )> }
  )> }
);

export type DeleteAccountMutationVariables = Exact<{ [key: string]: never; }>;


export type DeleteAccountMutation = (
  { __typename?: 'mutation_root' }
  & { delete_account?: Maybe<(
    { __typename?: 'DeleteAccountResult' }
    & Pick<DeleteAccountResult, 'ok'>
  )> }
);

export type GetAuthProviderUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAuthProviderUserQuery = (
  { __typename?: 'query_root' }
  & { get_auth_provider_user?: Maybe<(
    { __typename?: 'AuthProviderUser' }
    & Pick<AuthProviderUser, 'email' | 'emailVerified'>
  )> }
);

export type ResendEmailVerificationCodeMutationVariables = Exact<{ [key: string]: never; }>;


export type ResendEmailVerificationCodeMutation = (
  { __typename?: 'mutation_root' }
  & { resend_email_verification_code?: Maybe<(
    { __typename?: 'ResendEmailVerificationCodeOutput' }
    & Pick<ResendEmailVerificationCodeOutput, 'ok'>
  )> }
);

export type UpdateEmailMutationVariables = Exact<{
  newEmail: Scalars['String'];
}>;


export type UpdateEmailMutation = (
  { __typename?: 'mutation_root' }
  & { change_email?: Maybe<(
    { __typename?: 'ChangeEmailOutput' }
    & Pick<ChangeEmailOutput, 'new_email'>
  )> }
);

export type VerifyEmailMutationVariables = Exact<{
  code: Scalars['String'];
}>;


export type VerifyEmailMutation = (
  { __typename?: 'mutation_root' }
  & { verify_email?: Maybe<(
    { __typename?: 'VerifyEmailOutput' }
    & Pick<VerifyEmailOutput, 'ok'>
  )> }
);

export type ChangePasswordMutationVariables = Exact<{
  currentPassword: Scalars['String'];
  newPassword: Scalars['String'];
}>;


export type ChangePasswordMutation = (
  { __typename?: 'mutation_root' }
  & { change_password?: Maybe<(
    { __typename?: 'ChangePasswordResult' }
    & Pick<ChangePasswordResult, 'ok'>
  )> }
);

export type UpdateUserProfileMutationVariables = Exact<{
  userId: Scalars['Int'];
  profile_image_url?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  is_available_for_gigs: Scalars['Boolean'];
  discord_username?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  enable_service_tier_badge: Scalars['Boolean'];
  ethereum_address_is_public: Scalars['Boolean'];
}>;


export type UpdateUserProfileMutation = (
  { __typename?: 'mutation_root' }
  & { update_users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'bio' | 'is_available_for_gigs' | 'discord_username' | 'twitter_handle' | 'telegram_handle' | 'ethereum_address'>
    & { private_info?: Maybe<(
      { __typename?: 'user_private' }
      & Pick<User_Private, 'enable_service_tier_badge' | 'ethereum_address_is_public'>
    )>, conditional_public_attributes?: Maybe<(
      { __typename?: 'user_public' }
      & Pick<User_Public, 'service_tier_name' | 'ethereum_address'>
    )> }
  )> }
);

export type FindOwnProfileQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type FindOwnProfileQuery = (
  { __typename?: 'query_root' }
  & { users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name' | 'profile_image_url' | 'bio' | 'is_available_for_gigs' | 'discord_username' | 'twitter_handle' | 'telegram_handle' | 'ethereum_address'>
    & { received_stars?: Maybe<(
      { __typename?: 'user_received_stars' }
      & Pick<User_Received_Stars, 'sum'>
    )>, queries: Array<(
      { __typename?: 'queries' }
      & Pick<Queries, 'created_at'>
    )>, private_info?: Maybe<(
      { __typename?: 'user_private' }
      & Pick<User_Private, 'enable_service_tier_badge' | 'ethereum_address_is_public'>
    )>, user_service_tier: (
      { __typename?: 'user_service_tiers' }
      & Pick<User_Service_Tiers, 'id' | 'name'>
    ) }
  )> }
);

export type GetUserServiceTierByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserServiceTierByIdQuery = (
  { __typename?: 'query_root' }
  & { user_service_tiers_by_pk?: Maybe<(
    { __typename?: 'user_service_tiers' }
    & Pick<User_Service_Tiers, 'id' | 'name'>
  )> }
);

export type GetUserUsageDataQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserUsageDataQuery = (
  { __typename?: 'query_root' }
  & { dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ), queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ), billable_usage?: Maybe<(
    { __typename?: 'BillableUsageResponse' }
    & Pick<BillableUsageResponse, 'query_executions' | 'csv_downloads' | 'datapoints_read'>
  )> }
);

export type CancelApiUserPlanMutationVariables = Exact<{ [key: string]: never; }>;


export type CancelApiUserPlanMutation = (
  { __typename?: 'mutation_root' }
  & { cancel_api_user_subscription: (
    { __typename?: 'CancelApiUserSubscriptionResponse' }
    & Pick<CancelApiUserSubscriptionResponse, 'ok'>
  ) }
);

export type CancelUserPlanMutationVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type CancelUserPlanMutation = (
  { __typename?: 'mutation_root' }
  & { downgrade_user_subscription: (
    { __typename?: 'DowngradeUserSubscriptionResponse' }
    & Pick<DowngradeUserSubscriptionResponse, 'ok'>
  ) }
);

export type GetPendingApiUpdatesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPendingApiUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_api_user_subscription_updates: Array<(
    { __typename?: 'pending_api_user_subscription_updates' }
    & Pick<Pending_Api_User_Subscription_Updates, 'update_date' | 'update_type'>
    & { api_user_service_tier?: Maybe<(
      { __typename?: 'api_user_service_tiers' }
      & Pick<Api_User_Service_Tiers, 'name'>
    )> }
  )> }
);

export type GetPendingUserUpdatesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPendingUserUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_user_subscription_updates: Array<(
    { __typename?: 'pending_user_subscription_updates' }
    & Pick<Pending_User_Subscription_Updates, 'update_date' | 'update_type'>
    & { user_service_tier: (
      { __typename?: 'user_service_tiers' }
      & Pick<User_Service_Tiers, 'id' | 'name'>
    ) }
  )> }
);

export type UnlinkWalletMutationVariables = Exact<{ [key: string]: never; }>;


export type UnlinkWalletMutation = (
  { __typename?: 'mutation_root' }
  & { unlink_wallet_address?: Maybe<(
    { __typename?: 'UnlinkWalletAddressResult' }
    & Pick<UnlinkWalletAddressResult, 'ok'>
  )> }
);

export type GetMembershipQueryVariables = Exact<{
  user_id: Scalars['Int'];
  team_id: Scalars['Int'];
}>;


export type GetMembershipQuery = (
  { __typename?: 'query_root' }
  & { memberships: Array<(
    { __typename?: 'memberships' }
    & Pick<Memberships, 'id'>
    & { private_details?: Maybe<(
      { __typename?: 'memberships_private_details' }
      & Pick<Memberships_Private_Details, 'role' | 'status'>
    )> }
  )> }
);

export type StaticTeamProfileDataQueryVariables = Exact<{
  handle: Scalars['String'];
}>;


export type StaticTeamProfileDataQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url' | 'bio' | 'twitter_handle' | 'telegram_handle' | 'discord_url'>
    & { received_stars?: Maybe<(
      { __typename?: 'team_received_stars' }
      & Pick<Team_Received_Stars, 'sum'>
    )>, conditional_public_attributes?: Maybe<(
      { __typename?: 'team_public' }
      & { service_tier?: Maybe<(
        { __typename?: 'team_service_tiers' }
        & Pick<Team_Service_Tiers, 'name'>
      )> }
    )>, dashboards: Array<(
      { __typename?: 'dashboards' }
      & DashboardItemOnProfileFragment
    )>, dashboards_aggregate: (
      { __typename?: 'dashboards_aggregate' }
      & { aggregate?: Maybe<(
        { __typename?: 'dashboards_aggregate_fields' }
        & Pick<Dashboards_Aggregate_Fields, 'count'>
      )> }
    ), queries: Array<(
      { __typename?: 'queries' }
      & QueryItemOnProfileFragment
    )>, queries_aggregate: (
      { __typename?: 'queries_aggregate' }
      & { aggregate?: Maybe<(
        { __typename?: 'queries_aggregate_fields' }
        & Pick<Queries_Aggregate_Fields, 'count'>
      )> }
    ), memberships: Array<(
      { __typename?: 'memberships' }
      & Pick<Memberships, 'id'>
      & { user?: Maybe<(
        { __typename?: 'users' }
        & Pick<Users, 'id' | 'name' | 'profile_image_url'>
      )> }
    )> }
  )> }
);

export type ListUserTeamsQueryVariables = Exact<{
  user_id: Scalars['Int'];
}>;


export type ListUserTeamsQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'name' | 'handle' | 'profile_image_url'>
  )> }
);

export type StaticUserProfileDataQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type StaticUserProfileDataQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name' | 'profile_image_url'>
    & { dashboards: Array<(
      { __typename?: 'dashboards' }
      & DashboardItemOnProfileFragment
    )>, dashboards_aggregate: (
      { __typename?: 'dashboards_aggregate' }
      & { aggregate?: Maybe<(
        { __typename?: 'dashboards_aggregate_fields' }
        & Pick<Dashboards_Aggregate_Fields, 'count'>
      )> }
    ), queries: Array<(
      { __typename?: 'queries' }
      & QueryItemOnProfileFragment
    )>, queries_aggregate: (
      { __typename?: 'queries_aggregate' }
      & { aggregate?: Maybe<(
        { __typename?: 'queries_aggregate_fields' }
        & Pick<Queries_Aggregate_Fields, 'count'>
      )> }
    ) }
  )> }
);

export type FindPublicProfileQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type FindPublicProfileQuery = (
  { __typename?: 'query_root' }
  & { users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name' | 'profile_image_url' | 'bio' | 'is_available_for_gigs' | 'discord_username' | 'twitter_handle' | 'telegram_handle'>
    & { received_stars?: Maybe<(
      { __typename?: 'user_received_stars' }
      & Pick<User_Received_Stars, 'sum'>
    )>, queries: Array<(
      { __typename?: 'queries' }
      & Pick<Queries, 'created_at'>
    )>, conditional_public_attributes?: Maybe<(
      { __typename?: 'user_public' }
      & Pick<User_Public, 'ethereum_address' | 'service_tier_name'>
    )>, contract_submissions_aggregate: (
      { __typename?: 'contract_submissions_aggregate' }
      & { aggregate?: Maybe<(
        { __typename?: 'contract_submissions_aggregate_fields' }
        & Pick<Contract_Submissions_Aggregate_Fields, 'count'>
      )> }
    ) }
  )> }
);

export type GenerateUploadUrlMutationVariables = Exact<{
  content_length: Scalars['Int'];
  file_type: Scalars['String'];
}>;


export type GenerateUploadUrlMutation = (
  { __typename?: 'mutation_root' }
  & { generate_upload_url?: Maybe<(
    { __typename?: 'PresignedUrlResponse' }
    & Pick<PresignedUrlResponse, 'url'>
  )> }
);

export type ForkDashboardMutationVariables = Exact<{
  existing_dashboard_id: Scalars['Int'];
  new_dashboard_name: Scalars['String'];
  new_dashboard_slug: Scalars['String'];
  contextOwner: ContextOwner;
}>;


export type ForkDashboardMutation = (
  { __typename?: 'mutation_root' }
  & { fork_dashboard_v2?: Maybe<(
    { __typename?: 'ForkDashboardResponse' }
    & Pick<ForkDashboardResponse, 'slug'>
  )> }
);

export type UpsertDashboardMutationVariables = Exact<{
  object: Dashboards_Insert_Input;
  on_conflict: Dashboards_On_Conflict;
}>;


export type UpsertDashboardMutation = (
  { __typename?: 'mutation_root' }
  & { insert_dashboards_one?: Maybe<(
    { __typename?: 'dashboards' }
    & Pick<Dashboards, 'slug'>
  )> }
);

export type PatchDashboardSettingsMutationVariables = Exact<{
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
  is_private?: Maybe<Scalars['Boolean']>;
  slug?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['jsonb']>;
}>;


export type PatchDashboardSettingsMutation = (
  { __typename?: 'mutation_root' }
  & { patch_dashboard_settings?: Maybe<(
    { __typename?: 'PatchDashboardSettingsResponse' }
    & { dashboard?: Maybe<(
      { __typename?: 'dashboards' }
      & Pick<Dashboards, 'id' | 'name' | 'is_private' | 'user_id' | 'team_id' | 'slug'>
    )> }
  )>, update_dashboards?: Maybe<(
    { __typename?: 'dashboards_mutation_response' }
    & { returning: Array<(
      { __typename?: 'dashboards' }
      & Pick<Dashboards, 'id' | 'tags'>
    )> }
  )> }
);

export type GetUserPrivateDashboardsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserPrivateDashboardsQuery = (
  { __typename?: 'query_root' }
  & { dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type GetTeamPrivateDashboardsQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamPrivateDashboardsQuery = (
  { __typename?: 'query_root' }
  & { dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ), team_members_details: Array<(
    { __typename?: 'team_members_details' }
    & Pick<Team_Members_Details, 'id'>
    & { service_tier?: Maybe<(
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'max_private_dashboards'>
    )> }
  )> }
);

export type ListAbisForContractQueryVariables = Exact<{
  namespace: Scalars['String'];
  contract_name: Scalars['String'];
  blockchains_filter: Jsonb_Comparison_Exp;
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  abi_type_filter: String_Comparison_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListAbisForContractQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'abi_name' | 'abi_type' | 'full_name'>
  )> }
);

export type ListAbstractionTablesQueryVariables = Exact<{
  namespace: Scalars['String'];
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  filter_blockchains: Jsonb_Comparison_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListAbstractionTablesQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'table_name' | 'full_name' | 'blockchains'>
  )>, distinct_by_blockchains: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'blockchains'>
  )> }
);

export type ListAbstractionsQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  filter_blockchains: Jsonb_Comparison_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListAbstractionsQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'id' | 'namespace' | 'abstraction_type' | 'blockchains'>
  )> }
);

export type ListContractsForSchemaQueryVariables = Exact<{
  namespace: Scalars['String'];
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  filter_blockchains: Jsonb_Comparison_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListContractsForSchemaQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'contract_name' | 'blockchains'>
  )>, distinct_by_blockchains: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'blockchains'>
  )> }
);

export type ListDecodedProjectsQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  filter_blockchains: Jsonb_Comparison_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListDecodedProjectsQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'namespace' | 'blockchains'>
  )> }
);

export type FindDecodedTableDetailQueryVariables = Exact<{
  namespace: Scalars['String'];
  contract_name: Scalars['String'];
  abi: Scalars['String'];
  blockchains_filter: Jsonb_Comparison_Exp;
  dataset_id: Scalars['Int'];
}>;


export type FindDecodedTableDetailQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'id' | 'abi_type' | 'table_name' | 'column_name' | 'data_type' | 'full_name' | 'blockchains'>
  )> }
);

export type ListEssentialTablesQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  full_names: Array<Scalars['String']> | Scalars['String'];
  filter_blockchains: Jsonb_Comparison_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListEssentialTablesQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'id' | 'category' | 'namespace' | 'table_name' | 'full_name' | 'blockchains'>
  )> }
);

export type HomeSearchQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  search_all: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  search_tables: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  search_projects: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  search_contracts: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  search_abis: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
}>;


export type HomeSearchQuery = (
  { __typename?: 'query_root' }
  & { tables: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'namespace' | 'table_name' | 'category' | 'full_name' | 'blockchains'>
  )>, projects: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'namespace' | 'blockchains'>
  )>, contracts: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'namespace' | 'contract_name' | 'blockchains'>
  )>, abis: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'namespace' | 'contract_name' | 'abi_name' | 'abi_type' | 'full_name' | 'blockchains'>
  )> }
);

export type SearchContractsQueryVariables = Exact<{
  contract_address: Scalars['String'];
}>;


export type SearchContractsQuery = (
  { __typename?: 'query_root' }
  & { search_contracts: (
    { __typename?: 'SearchContractsResponse' }
    & { projects: Array<(
      { __typename?: 'SearchContractsProject' }
      & Pick<SearchContractsProject, 'namespace' | 'blockchains'>
    )> }
  ) }
);

export type ListMaterializedViewsQueryVariables = Exact<{
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListMaterializedViewsQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & Pick<Queries, 'name'>
  )> }
);

export type ListRawTablesQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  filter_blockchains: Jsonb_Comparison_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListRawTablesQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'id' | 'namespace' | 'table_name' | 'full_name' | 'blockchains'>
  )> }
);

export type FindTableDetailQueryVariables = Exact<{
  category: Scalars['String'];
  namespace: Scalars['String'];
  table_name: Scalars['String'];
  blockchains_filter: Jsonb_Comparison_Exp;
  dataset_id: Scalars['Int'];
}>;


export type FindTableDetailQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'id' | 'column_name' | 'data_type' | 'full_name' | 'blockchains'>
  )> }
);

export type GetTablePreviewMutationVariables = Exact<{
  table: Scalars['String'];
}>;


export type GetTablePreviewMutation = (
  { __typename?: 'mutation_root' }
  & { get_table_preview: (
    { __typename?: 'GetTablePreviewResponse' }
    & Pick<GetTablePreviewResponse, 'job_id' | 'result_id' | 'error_id' | 'query_id'>
    & { parameters: Array<(
      { __typename?: 'ParameterObject' }
      & Pick<ParameterObject, 'key' | 'type' | 'value'>
    )> }
  ) }
);

export type ListThirdPartiesQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListThirdPartiesQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'id' | 'namespace' | 'blockchains'>
  )> }
);

export type ListThirdPartyTablesQueryVariables = Exact<{
  namespace: Scalars['String'];
  dataset_id: Scalars['Int'];
  search_terms: Array<Arrakis_Schemas_Bool_Exp> | Arrakis_Schemas_Bool_Exp;
  offset?: Maybe<Scalars['Int']>;
}>;


export type ListThirdPartyTablesQuery = (
  { __typename?: 'query_root' }
  & { arrakis_schemas: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'table_name' | 'full_name' | 'blockchains'>
  )>, distinct_by_blockchains: Array<(
    { __typename?: 'arrakis_schemas' }
    & Pick<Arrakis_Schemas, 'blockchains'>
  )> }
);

export type GetQueriesQueryVariables = Exact<{
  filter_name?: Maybe<String_Comparison_Exp>;
  filter_is_private?: Maybe<Boolean_Comparison_Exp>;
  filter_custom?: Maybe<Array<Queries_Bool_Exp> | Queries_Bool_Exp>;
  is_archived: Scalars['Boolean'];
  order?: Maybe<Array<Queries_Order_By> | Queries_Order_By>;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type GetQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & QueryExplorerQueryItemFragment
  )> }
);

export type QueryExplorerQueryItemFragment = (
  { __typename?: 'queries' }
  & Pick<Queries, 'id' | 'name' | 'created_at' | 'dataset_id' | 'matview_id' | 'is_private'>
  & { user?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name' | 'profile_image_url'>
  )>, team?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'handle' | 'profile_image_url'>
  )> }
);

export type GetOwnerInfoQueryVariables = Exact<{
  userIds: Array<Scalars['Int']> | Scalars['Int'];
  teamIds: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type GetOwnerInfoQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'profile_image_url'>
    & { handle: Users['name'] }
  )>, teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'handle' | 'profile_image_url'>
  )> }
);

export type GetInitialQueryEventQueryVariables = Exact<{
  query_id: Scalars['Int'];
}>;


export type GetInitialQueryEventQuery = (
  { __typename?: 'query_root' }
  & { get_initial_query_event?: Maybe<(
    { __typename?: 'QueryEvent' }
    & Pick<QueryEvent, 'id' | 'user_id' | 'team_id' | 'query_version' | 'from' | 'to' | 'type' | 'created_at'>
    & { metadata?: Maybe<(
      { __typename?: 'QueryEventMetadata' }
      & Pick<QueryEventMetadata, 'name' | 'description'>
    )> }
  )> }
);

export type GetQueryEventsQueryVariables = Exact<{
  query_id: Scalars['Int'];
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type GetQueryEventsQuery = (
  { __typename?: 'query_root' }
  & { get_query_events: (
    { __typename?: 'GetQueryEventsResponse' }
    & Pick<GetQueryEventsResponse, 'past_retention_window' | 'retention_days'>
    & { results: Array<(
      { __typename?: 'QueryEvent' }
      & Pick<QueryEvent, 'id' | 'user_id' | 'team_id' | 'query_version' | 'from' | 'to' | 'type' | 'created_at'>
      & { metadata?: Maybe<(
        { __typename?: 'QueryEventMetadata' }
        & Pick<QueryEventMetadata, 'name' | 'description'>
      )> }
    )> }
  ) }
);

export type ForkQueryV3MutationVariables = Exact<{
  queryId: Scalars['Int'];
  contextOwner: ContextOwner;
}>;


export type ForkQueryV3Mutation = (
  { __typename?: 'mutation_root' }
  & { fork_query_v3: (
    { __typename?: 'ForkQueryV3Response' }
    & Pick<ForkQueryV3Response, 'query_id'>
  ) }
);

export type GetQueryContributorsQueryVariables = Exact<{
  queryId: Scalars['Int'];
}>;


export type GetQueryContributorsQuery = (
  { __typename?: 'query_root' }
  & { get_query_contributors: (
    { __typename?: 'GetQueryContributorsResponse' }
    & { contributors: Array<(
      { __typename?: 'QueryContributor' }
      & Pick<QueryContributor, 'handle' | 'contributions' | 'profile_image_url' | 'query_id' | 'user_id'>
    )> }
  ) }
);

export type CreateQueryScheduleMutationVariables = Exact<{
  query_id: Scalars['Int'];
  cron_expression: Scalars['String'];
  performance: Scalars['String'];
}>;


export type CreateQueryScheduleMutation = (
  { __typename?: 'mutation_root' }
  & { create_query_schedule: (
    { __typename?: 'CreateQueryScheduleResponse' }
    & Pick<CreateQueryScheduleResponse, 'query_id'>
  ) }
);

export type DeleteQueryScheduleMutationVariables = Exact<{
  cron_job_id: Scalars['String'];
}>;


export type DeleteQueryScheduleMutation = (
  { __typename?: 'mutation_root' }
  & { delete_query_schedule: (
    { __typename?: 'DeleteQueryScheduleResponse' }
    & Pick<DeleteQueryScheduleResponse, 'cron_job_id'>
  ) }
);

export type QuerySchedulesQueryVariables = Exact<{
  query_id: Scalars['Int'];
}>;


export type QuerySchedulesQuery = (
  { __typename?: 'query_root' }
  & { query_schedules: (
    { __typename?: 'QuerySchedulesResponse' }
    & Pick<QuerySchedulesResponse, 'query_id'>
    & { cron_jobs: Array<(
      { __typename?: 'CronJob' }
      & Pick<CronJob, 'id' | 'cron_expression' | 'performance' | 'owned_by_customer_id'>
      & { metadata: (
        { __typename?: 'CronJobMetadata' }
        & Pick<CronJobMetadata, 'updated_at'>
      ) }
    )> }
  ) }
);

export type UpdateQueryScheduleMutationVariables = Exact<{
  cron_job_id: Scalars['String'];
  cron_expression: Scalars['String'];
  performance: Scalars['String'];
}>;


export type UpdateQueryScheduleMutation = (
  { __typename?: 'mutation_root' }
  & { update_query_schedule: (
    { __typename?: 'UpdateQueryScheduleResponse' }
    & Pick<UpdateQueryScheduleResponse, 'query_id'>
  ) }
);

export type InsertVisualMutationVariables = Exact<{
  visual: Visualizations_Insert_Input;
}>;


export type InsertVisualMutation = (
  { __typename?: 'mutation_root' }
  & { insert_visualizations_one?: Maybe<(
    { __typename?: 'visualizations' }
    & VisualizationFragment
  )> }
);

export type CreateQueryMutationVariables = Exact<{
  query: CreateQueryInput;
}>;


export type CreateQueryMutation = (
  { __typename?: 'mutation_root' }
  & { create_query: (
    { __typename?: 'CreateQueryResponse' }
    & Pick<CreateQueryResponse, 'query_id'>
  ) }
);

export type UpdateQueryMutationVariables = Exact<{
  query: UpdateQueryInput;
}>;


export type UpdateQueryMutation = (
  { __typename?: 'mutation_root' }
  & { update_query: (
    { __typename?: 'UpdateQueryResponse' }
    & Pick<UpdateQueryResponse, 'query_id'>
  ) }
);

export type EditVisualMutationVariables = Exact<{
  id: Scalars['Int'];
  options: Scalars['jsonb'];
  name: Scalars['String'];
  type: Scalars['visualization_types'];
}>;


export type EditVisualMutation = (
  { __typename?: 'mutation_root' }
  & { update_visualizations_by_pk?: Maybe<(
    { __typename?: 'visualizations' }
    & Pick<Visualizations, 'id' | 'type' | 'name' | 'options' | 'created_at'>
  )> }
);

export type CancelExecutionMutationVariables = Exact<{
  execution_id: Scalars['String'];
  query_id: Scalars['Int'];
  parameters: Array<Parameter> | Parameter;
}>;


export type CancelExecutionMutation = (
  { __typename?: 'mutation_root' }
  & { cancel_execution?: Maybe<(
    { __typename?: 'CancelExecutionResponse' }
    & Pick<CancelExecutionResponse, 'execution_id'>
  )> }
);

export type ForkQueryV1MutationVariables = Exact<{
  session_id: Scalars['Int'];
  query_id: Scalars['Int'];
}>;


export type ForkQueryV1Mutation = (
  { __typename?: 'mutation_root' }
  & { fork_query?: Maybe<(
    { __typename?: 'fork_query_response' }
    & Pick<Fork_Query_Response, 'query_id'>
  )> }
);

export type UpdateQueryCodeMutationVariables = Exact<{
  query_id: Scalars['Int'];
  code: Scalars['String'];
}>;


export type UpdateQueryCodeMutation = (
  { __typename?: 'mutation_root' }
  & { update_queries_by_pk?: Maybe<(
    { __typename?: 'queries' }
    & Pick<Queries, 'id'>
  )> }
);

export type ExportCsvQueryVariables = Exact<{
  execution_id: Scalars['String'];
  query_id: Scalars['Int'];
  parameters: Array<Parameter> | Parameter;
  downloadFor: ContextOwner;
}>;


export type ExportCsvQuery = (
  { __typename?: 'query_root' }
  & { export_csv?: Maybe<(
    { __typename?: 'ExportCSVResponse' }
    & Pick<ExportCsvResponse, 'url'>
  )> }
);

export type DeleteVisualizationMutationVariables = Exact<{
  visual_id: Scalars['Int'];
}>;


export type DeleteVisualizationMutation = (
  { __typename?: 'mutation_root' }
  & { delete_visualizations_by_pk?: Maybe<(
    { __typename?: 'visualizations' }
    & Pick<Visualizations, 'id'>
  )> }
);

export type ListDatasetsQueryVariables = Exact<{ [key: string]: never; }>;


export type ListDatasetsQuery = (
  { __typename?: 'query_root' }
  & { datasets: Array<(
    { __typename?: 'datasets' }
    & Pick<Datasets, 'id' | 'name' | 'type'>
  )> }
);

export type ListSchemasQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  query: Array<Blockchain_Schemas_Bool_Exp> | Blockchain_Schemas_Bool_Exp;
  offset: Scalars['Int'];
  limit: Scalars['Int'];
}>;


export type ListSchemasQuery = (
  { __typename?: 'query_root' }
  & { blockchain_schemas: Array<(
    { __typename?: 'blockchain_schemas' }
    & Pick<Blockchain_Schemas, 'schema' | 'table'>
  )> }
);

export type ListColumnsQueryVariables = Exact<{
  dataset_id: Scalars['Int'];
  schema: Scalars['String'];
  table: Scalars['String'];
  limit: Scalars['Int'];
}>;


export type ListColumnsQuery = (
  { __typename?: 'query_root' }
  & { blockchain_schemas: Array<(
    { __typename?: 'blockchain_schemas' }
    & Pick<Blockchain_Schemas, 'column_name' | 'data_type'>
  )> }
);

export type RestoreQueryMutationVariables = Exact<{
  query_event_id: Scalars['String'];
}>;


export type RestoreQueryMutation = (
  { __typename?: 'mutation_root' }
  & { restore_query: (
    { __typename?: 'RestoreQueryResponse' }
    & Pick<RestoreQueryResponse, 'query_id'>
  ) }
);

export type UpsertQueryEventMetadataMutationVariables = Exact<{
  query_event_id: Scalars['String'];
  metadata: UpsertQueryEventMetadataInput;
}>;


export type UpsertQueryEventMetadataMutation = (
  { __typename?: 'mutation_root' }
  & { upsert_query_event_metadata: (
    { __typename?: 'QueryEventMetadata' }
    & Pick<QueryEventMetadata, 'query_event_id' | 'user_id' | 'name' | 'description' | 'created_at' | 'updated_at'>
  ) }
);

export type GetQueryEventQueryVariables = Exact<{
  query_event_id: Scalars['String'];
}>;


export type GetQueryEventQuery = (
  { __typename?: 'query_root' }
  & { get_query_event?: Maybe<(
    { __typename?: 'QueryEvent' }
    & Pick<QueryEvent, 'id' | 'user_id' | 'query_version' | 'from' | 'to' | 'type' | 'created_at'>
    & { metadata?: Maybe<(
      { __typename?: 'QueryEventMetadata' }
      & Pick<QueryEventMetadata, 'name' | 'description'>
    )> }
  )> }
);

export type GetUserPrivateQueriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserPrivateQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type GetTeamPrivateQueriesQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamPrivateQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ), team_members_details: Array<(
    { __typename?: 'team_members_details' }
    & Pick<Team_Members_Details, 'id'>
    & { service_tier?: Maybe<(
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'max_private_queries'>
    )> }
  )> }
);

export type GetTeamServiceTierQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamServiceTierQuery = (
  { __typename?: 'query_root' }
  & { team_members_details: Array<(
    { __typename?: 'team_members_details' }
    & Pick<Team_Members_Details, 'id'>
    & { service_tier?: Maybe<(
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'release_version'>
    )> }
  )> }
);

export type DashboardItemOnProfileFragment = (
  { __typename?: 'dashboards' }
  & Pick<Dashboards, 'id' | 'name' | 'slug' | 'created_at' | 'tags'>
  & { dashboard_favorite_count_all?: Maybe<(
    { __typename?: 'dashboard_favorite_count_all' }
    & Pick<Dashboard_Favorite_Count_All, 'favorite_count'>
  )>, trending_scores?: Maybe<(
    { __typename?: 'dashboard_trending_scores' }
    & Pick<Dashboard_Trending_Scores, 'score_1h' | 'score_4h' | 'score_24h' | 'updated_at'>
  )> }
);

export type QueryItemOnProfileFragment = (
  { __typename?: 'queries' }
  & Pick<Queries, 'id' | 'name' | 'created_at' | 'tags'>
  & { query_favorite_count_all?: Maybe<(
    { __typename?: 'query_favorite_count_all' }
    & Pick<Query_Favorite_Count_All, 'favorite_count'>
  )> }
);

export type InsertDashboardApiKeyMutationVariables = Exact<{
  dashboard_id: Scalars['Int'];
  user_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
}>;


export type InsertDashboardApiKeyMutation = (
  { __typename?: 'mutation_root' }
  & { insert_api_keys_one?: Maybe<(
    { __typename?: 'api_keys' }
    & Pick<Api_Keys, 'id'>
  )> }
);

export type InsertQueryApiKeyMutationVariables = Exact<{
  query_id: Scalars['Int'];
  user_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
}>;


export type InsertQueryApiKeyMutation = (
  { __typename?: 'mutation_root' }
  & { insert_api_keys_one?: Maybe<(
    { __typename?: 'api_keys' }
    & Pick<Api_Keys, 'id'>
  )> }
);

export type DeleteParamWidgetsMutationVariables = Exact<{
  ids: Array<Param_Widgets_Bool_Exp> | Param_Widgets_Bool_Exp;
}>;


export type DeleteParamWidgetsMutation = (
  { __typename?: 'mutation_root' }
  & { delete_param_widgets?: Maybe<(
    { __typename?: 'param_widgets_mutation_response' }
    & Pick<Param_Widgets_Mutation_Response, 'affected_rows'>
  )> }
);

export type InsertVisualizationWidgetMutationVariables = Exact<{
  object: Visualization_Widgets_Insert_Input;
}>;


export type InsertVisualizationWidgetMutation = (
  { __typename?: 'mutation_root' }
  & { insert_visualization_widgets_one?: Maybe<(
    { __typename?: 'visualization_widgets' }
    & Pick<Visualization_Widgets, 'id'>
  )> }
);

export type RemoveVisualizationWidgetsMutationVariables = Exact<{
  widgets: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type RemoveVisualizationWidgetsMutation = (
  { __typename?: 'mutation_root' }
  & { delete_visualization_widgets?: Maybe<(
    { __typename?: 'visualization_widgets_mutation_response' }
    & { returning: Array<(
      { __typename?: 'visualization_widgets' }
      & Pick<Visualization_Widgets, 'id'>
    )> }
  )> }
);

export type UpsertTextWidgetMutationVariables = Exact<{
  object: Text_Widgets_Insert_Input;
  on_conflict: Text_Widgets_On_Conflict;
}>;


export type UpsertTextWidgetMutation = (
  { __typename?: 'mutation_root' }
  & { insert_text_widgets_one?: Maybe<(
    { __typename?: 'text_widgets' }
    & Pick<Text_Widgets, 'id'>
  )> }
);

export type RemoveTextWidgetsMutationVariables = Exact<{
  widgets: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type RemoveTextWidgetsMutation = (
  { __typename?: 'mutation_root' }
  & { delete_text_widgets?: Maybe<(
    { __typename?: 'text_widgets_mutation_response' }
    & { returning: Array<(
      { __typename?: 'text_widgets' }
      & Pick<Text_Widgets, 'id'>
    )> }
  )> }
);

export type TeamFragment = (
  { __typename?: 'teams' }
  & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url'>
);

export type EntryDashboardFragment = (
  { __typename?: 'dashboards' }
  & Pick<Dashboards, 'id' | 'name' | 'slug' | 'is_private' | 'is_archived' | 'created_at' | 'updated_at' | 'tags'>
  & { user?: Maybe<(
    { __typename?: 'users' }
    & UserFragment
  )>, team?: Maybe<(
    { __typename?: 'teams' }
    & TeamFragment
  )>, dashboard_favorite_count_all?: Maybe<(
    { __typename?: 'dashboard_favorite_count_all' }
    & Pick<Dashboard_Favorite_Count_All, 'favorite_count'>
  )>, dashboard_favorite_count_last_24h?: Maybe<(
    { __typename?: 'dashboard_favorite_count_last_24h' }
    & Pick<Dashboard_Favorite_Count_Last_24h, 'favorite_count'>
  )>, dashboard_favorite_count_last_7d?: Maybe<(
    { __typename?: 'dashboard_favorite_count_last_7d' }
    & Pick<Dashboard_Favorite_Count_Last_7d, 'favorite_count'>
  )>, dashboard_favorite_count_last_30d?: Maybe<(
    { __typename?: 'dashboard_favorite_count_last_30d' }
    & Pick<Dashboard_Favorite_Count_Last_30d, 'favorite_count'>
  )>, trending_scores?: Maybe<(
    { __typename?: 'dashboard_trending_scores' }
    & Pick<Dashboard_Trending_Scores, 'score_1h' | 'score_4h' | 'score_24h' | 'updated_at'>
  )> }
);

export type EntryDashboardWithVizWidgetsFragment = (
  { __typename?: 'dashboards' }
  & Pick<Dashboards, 'id' | 'name' | 'slug' | 'is_private' | 'is_archived' | 'created_at' | 'updated_at'>
  & { user?: Maybe<(
    { __typename?: 'users' }
    & UserFragment
  )>, team?: Maybe<(
    { __typename?: 'teams' }
    & TeamFragment
  )>, visualization_widgets: Array<(
    { __typename?: 'visualization_widgets' }
    & Pick<Visualization_Widgets, 'id'>
    & { visualization: (
      { __typename?: 'visualizations' }
      & VisualizationFragment
    ) }
  )> }
);

export type DashboardFragment = (
  { __typename?: 'dashboards' }
  & Pick<Dashboards, 'id' | 'name' | 'slug' | 'is_private' | 'is_archived' | 'created_at' | 'updated_at' | 'tags'>
  & { user?: Maybe<(
    { __typename?: 'users' }
    & UserFragment
  )>, team?: Maybe<(
    { __typename?: 'teams' }
    & TeamFragment
  )>, forked_dashboard?: Maybe<(
    { __typename?: 'dashboards' }
    & Pick<Dashboards, 'slug' | 'name'>
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'name'>
    )>, team?: Maybe<(
      { __typename?: 'teams' }
      & Pick<Teams, 'handle'>
    )> }
  )>, text_widgets: Array<(
    { __typename?: 'text_widgets' }
    & Pick<Text_Widgets, 'id' | 'created_at' | 'updated_at' | 'text' | 'options'>
  )>, visualization_widgets: Array<(
    { __typename?: 'visualization_widgets' }
    & Pick<Visualization_Widgets, 'id' | 'created_at' | 'updated_at' | 'options'>
    & { visualization: (
      { __typename?: 'visualizations' }
      & VisualizationFragment
    ) }
  )>, param_widgets: Array<(
    { __typename?: 'param_widgets' }
    & Pick<Param_Widgets, 'id' | 'key' | 'visualization_widget_id' | 'query_id' | 'dashboard_id' | 'options' | 'created_at' | 'updated_at'>
  )>, dashboard_favorite_count_all?: Maybe<(
    { __typename?: 'dashboard_favorite_count_all' }
    & Pick<Dashboard_Favorite_Count_All, 'favorite_count'>
  )>, trending_scores?: Maybe<(
    { __typename?: 'dashboard_trending_scores' }
    & Pick<Dashboard_Trending_Scores, 'score_1h' | 'score_4h' | 'score_24h' | 'updated_at'>
  )> }
);

export type QueryFavoritesFragment = (
  { __typename?: 'queries' }
  & { query_favorite_count_all?: Maybe<(
    { __typename?: 'query_favorite_count_all' }
    & Pick<Query_Favorite_Count_All, 'favorite_count'>
  )>, query_favorite_count_last_24h?: Maybe<(
    { __typename?: 'query_favorite_count_last_24h' }
    & Pick<Query_Favorite_Count_Last_24h, 'favorite_count'>
  )>, query_favorite_count_last_7d?: Maybe<(
    { __typename?: 'query_favorite_count_last_7d' }
    & Pick<Query_Favorite_Count_Last_7d, 'favorite_count'>
  )>, query_favorite_count_last_30d?: Maybe<(
    { __typename?: 'query_favorite_count_last_30d' }
    & Pick<Query_Favorite_Count_Last_30d, 'favorite_count'>
  )> }
);

export type QueryUsersFragment = (
  { __typename?: 'queries' }
  & { user?: Maybe<(
    { __typename?: 'users' }
    & UserFragment
  )>, team?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url'>
  )> }
);

export type QueryTeamsFragment = (
  { __typename?: 'queries' }
  & { team?: Maybe<(
    { __typename?: 'teams' }
    & TeamFragment
  )> }
);

export type QueryVisualizationsFragment = (
  { __typename?: 'queries' }
  & { visualizations: Array<(
    { __typename?: 'visualizations' }
    & Pick<Visualizations, 'id' | 'type' | 'name' | 'options' | 'created_at'>
  )> }
);

export type QueryForkedFragment = (
  { __typename?: 'queries' }
  & { forked_query?: Maybe<(
    { __typename?: 'queries' }
    & Pick<Queries, 'id' | 'name'>
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'name'>
    )>, team?: Maybe<(
      { __typename?: 'teams' }
      & Pick<Teams, 'handle'>
    )> }
  )> }
);

export type BaseQueryFragment = (
  { __typename?: 'queries' }
  & Pick<Queries, 'id' | 'dataset_id' | 'name' | 'description' | 'query' | 'version' | 'matview_id' | 'is_private' | 'is_temp' | 'is_archived' | 'created_at' | 'updated_at' | 'schedule' | 'tags' | 'parameters'>
);

export type QueryFragment = (
  { __typename?: 'queries' }
  & BaseQueryFragment
  & QueryVisualizationsFragment
  & QueryForkedFragment
  & QueryUsersFragment
  & QueryTeamsFragment
  & QueryFavoritesFragment
);

export type ParametrizedQueryFragment = (
  { __typename?: 'queries' }
  & BaseQueryFragment
  & QueryVisualizationsFragment
  & QueryForkedFragment
  & QueryUsersFragment
  & QueryTeamsFragment
  & QueryFavoritesFragment
);

export type FindDashboardQueryVariables = Exact<{
  session_filter: Int_Comparison_Exp;
  user: Scalars['String'];
  slug: Scalars['String'];
}>;


export type FindDashboardQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & { favorite_dashboards: Array<(
      { __typename?: 'favorite_dashboards' }
      & Pick<Favorite_Dashboards, 'created_at'>
    )> }
    & DashboardFragment
  )> }
);

export type FindDashboardMetadataQueryVariables = Exact<{
  owner_handle: Scalars['String'];
  slug: Scalars['String'];
}>;


export type FindDashboardMetadataQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & Pick<Dashboards, 'name'>
  )> }
);

export type FindQueryMetadataQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type FindQueryMetadataQuery = (
  { __typename?: 'query_root' }
  & { queries_by_pk?: Maybe<(
    { __typename?: 'queries' }
    & Pick<Queries, 'name' | 'description'>
  )> }
);

export type FindQueryQueryVariables = Exact<{
  session_filter: Int_Comparison_Exp;
  id: Scalars['Int'];
  favs_last_24h?: Scalars['Boolean'];
  favs_last_7d?: Scalars['Boolean'];
  favs_last_30d?: Scalars['Boolean'];
  favs_all_time?: Scalars['Boolean'];
}>;


export type FindQueryQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & { favorite_queries: Array<(
      { __typename?: 'favorite_queries' }
      & Pick<Favorite_Queries, 'created_at'>
    )> }
    & QueryFragment
  )> }
);

export type ListDashboardsQueryVariables = Exact<{
  session_filter: Int_Comparison_Exp;
  filter_custom: Array<Dashboards_Bool_Exp> | Dashboards_Bool_Exp;
  tags: Jsonb_Comparison_Exp;
  query: String_Comparison_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  order?: Maybe<Array<Dashboards_Order_By> | Dashboards_Order_By>;
  favs_last_24h?: Scalars['Boolean'];
  favs_last_7d?: Scalars['Boolean'];
  favs_last_30d?: Scalars['Boolean'];
  favs_all_time?: Scalars['Boolean'];
}>;


export type ListDashboardsQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & { favorite_dashboards: Array<(
      { __typename?: 'favorite_dashboards' }
      & Pick<Favorite_Dashboards, 'created_at'>
    )> }
    & EntryDashboardFragment
  )>, dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListDashboardsWithVisualizationWidgetsQueryVariables = Exact<{
  author_name: Scalars['String'];
  query: String_Comparison_Exp;
}>;


export type ListDashboardsWithVisualizationWidgetsQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & EntryDashboardWithVizWidgetsFragment
  )> }
);

export type ListFavoriteDashboardsQueryVariables = Exact<{
  session_id: Scalars['Int'];
  query: String_Comparison_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  order?: Maybe<Array<Dashboards_Order_By> | Dashboards_Order_By>;
  favs_last_24h?: Scalars['Boolean'];
  favs_last_7d?: Scalars['Boolean'];
  favs_last_30d?: Scalars['Boolean'];
  favs_all_time?: Scalars['Boolean'];
}>;


export type ListFavoriteDashboardsQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & { favorite_dashboards: Array<(
      { __typename?: 'favorite_dashboards' }
      & Pick<Favorite_Dashboards, 'created_at'>
    )> }
    & EntryDashboardFragment
  )>, dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListQueriesQueryVariables = Exact<{
  session_filter: Int_Comparison_Exp;
  filter_custom: Array<Queries_Bool_Exp> | Queries_Bool_Exp;
  tags: Jsonb_Comparison_Exp;
  query: String_Comparison_Exp;
  is_archived: Scalars['Boolean'];
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  order?: Maybe<Array<Queries_Order_By> | Queries_Order_By>;
  favs_last_24h?: Scalars['Boolean'];
  favs_last_7d?: Scalars['Boolean'];
  favs_last_30d?: Scalars['Boolean'];
  favs_all_time?: Scalars['Boolean'];
  exclude_favorites?: Scalars['Boolean'];
  exclude_forks?: Scalars['Boolean'];
  exclude_users?: Scalars['Boolean'];
  exclude_teams?: Scalars['Boolean'];
  exclude_visualizations?: Scalars['Boolean'];
}>;


export type ListQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & { favorite_queries: Array<(
      { __typename?: 'favorite_queries' }
      & Pick<Favorite_Queries, 'created_at'>
    )> }
    & ParametrizedQueryFragment
  )>, queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListFavoriteQueriesQueryVariables = Exact<{
  session_id: Scalars['Int'];
  query: String_Comparison_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  order?: Maybe<Array<Queries_Order_By> | Queries_Order_By>;
  favs_last_24h?: Scalars['Boolean'];
  favs_last_7d?: Scalars['Boolean'];
  favs_last_30d?: Scalars['Boolean'];
  favs_all_time?: Scalars['Boolean'];
  exclude_favorites?: Scalars['Boolean'];
  exclude_forks?: Scalars['Boolean'];
  exclude_users?: Scalars['Boolean'];
  exclude_teams?: Scalars['Boolean'];
  exclude_visualizations?: Scalars['Boolean'];
}>;


export type ListFavoriteQueriesQuery = (
  { __typename?: 'query_root' }
  & { queries: Array<(
    { __typename?: 'queries' }
    & { favorite_queries: Array<(
      { __typename?: 'favorite_queries' }
      & Pick<Favorite_Queries, 'created_at'>
    )> }
    & ParametrizedQueryFragment
  )>, queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type ListUsersQueryVariables = Exact<{
  query: String_Comparison_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type ListUsersQuery = (
  { __typename?: 'query_root' }
  & { user_received_stars: Array<(
    { __typename?: 'user_received_stars' }
    & Pick<User_Received_Stars, 'sum'>
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name' | 'profile_image_url' | 'created_at'>
      & { queries: Array<(
        { __typename?: 'queries' }
        & Pick<Queries, 'created_at'>
      )> }
    )> }
  )>, user_received_stars_aggregate: (
    { __typename?: 'user_received_stars_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'user_received_stars_aggregate_fields' }
      & Pick<User_Received_Stars_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type InsertFavoriteDashboardMutationVariables = Exact<{
  session_id: Scalars['Int'];
  dashboard_id: Scalars['Int'];
}>;


export type InsertFavoriteDashboardMutation = (
  { __typename?: 'mutation_root' }
  & { insert_favorite_dashboards_one?: Maybe<(
    { __typename?: 'favorite_dashboards' }
    & Pick<Favorite_Dashboards, 'id'>
  )> }
);

export type InsertFavoriteQueryMutationVariables = Exact<{
  session_id: Scalars['Int'];
  query_id: Scalars['Int'];
}>;


export type InsertFavoriteQueryMutation = (
  { __typename?: 'mutation_root' }
  & { insert_favorite_queries_one?: Maybe<(
    { __typename?: 'favorite_queries' }
    & Pick<Favorite_Queries, 'id'>
  )> }
);

export type DeleteFavoriteDashboardMutationVariables = Exact<{
  session_id: Scalars['Int'];
  dashboard_id: Scalars['Int'];
}>;


export type DeleteFavoriteDashboardMutation = (
  { __typename?: 'mutation_root' }
  & { delete_favorite_dashboards?: Maybe<(
    { __typename?: 'favorite_dashboards_mutation_response' }
    & Pick<Favorite_Dashboards_Mutation_Response, 'affected_rows'>
  )> }
);

export type DeleteFavoriteQueryMutationVariables = Exact<{
  session_id: Scalars['Int'];
  query_id: Scalars['Int'];
}>;


export type DeleteFavoriteQueryMutation = (
  { __typename?: 'mutation_root' }
  & { delete_favorite_queries?: Maybe<(
    { __typename?: 'favorite_queries_mutation_response' }
    & Pick<Favorite_Queries_Mutation_Response, 'affected_rows'>
  )> }
);

export type GetExecutionQueryVariables = Exact<{
  execution_id: Scalars['String'];
  query_id: Scalars['Int'];
  parameters: Array<Parameter> | Parameter;
}>;


export type GetExecutionQuery = (
  { __typename?: 'query_root' }
  & { get_execution?: Maybe<(
    { __typename?: 'GetExecutionResponse' }
    & { execution_queued?: Maybe<(
      { __typename?: 'ExecutionQueued' }
      & Pick<ExecutionQueued, 'execution_id' | 'execution_user_id' | 'position' | 'execution_type' | 'created_at'>
    )>, execution_running?: Maybe<(
      { __typename?: 'ExecutionRunning' }
      & Pick<ExecutionRunning, 'execution_id' | 'execution_user_id' | 'execution_type' | 'started_at' | 'created_at'>
    )>, execution_succeeded?: Maybe<(
      { __typename?: 'ExecutionSucceeded' }
      & Pick<ExecutionSucceeded, 'execution_id' | 'runtime_seconds' | 'generated_at' | 'columns' | 'data' | 'max_result_size_reached_bytes' | 'request_max_result_size_bytes'>
    )>, execution_failed?: Maybe<(
      { __typename?: 'ExecutionFailed' }
      & Pick<ExecutionFailed, 'execution_id' | 'type' | 'message' | 'runtime_seconds' | 'generated_at'>
      & { metadata?: Maybe<(
        { __typename?: 'ErrorMetadata' }
        & Pick<ErrorMetadata, 'line' | 'column' | 'hint'>
      )> }
    )> }
  )> }
);

export type StarRankingWithDiscordUsernameQueryVariables = Exact<{ [key: string]: never; }>;


export type StarRankingWithDiscordUsernameQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name' | 'discord_username'>
    & { received_stars?: Maybe<(
      { __typename?: 'user_received_stars' }
      & Pick<User_Received_Stars, 'sum'>
    )> }
  )> }
);

export type ExampleQueryVariables = Exact<{ [key: string]: never; }>;


export type ExampleQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & Pick<Dashboards, 'id'>
  )> }
);

export type GetEntityBySubscriptionIdQueryVariables = Exact<{
  id: Scalars['String'];
}>;


export type GetEntityBySubscriptionIdQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'orb_subscription_id' | 'orb_api_subscription_id'>
  )>, teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'orb_subscription_id'>
  )> }
);

export type GetApiUserOrbSubscriptionQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type GetApiUserOrbSubscriptionQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'orb_api_subscription_id'>
    & { api_user_service_tier?: Maybe<(
      { __typename?: 'api_user_service_tiers' }
      & Pick<Api_User_Service_Tiers, 'id' | 'name'>
    )> }
  )> }
);

export type GetTeamCommunityTierQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTeamCommunityTierQuery = (
  { __typename?: 'query_root' }
  & { team_service_tiers: Array<(
    { __typename?: 'team_service_tiers' }
    & Pick<Team_Service_Tiers, 'id' | 'orb_base_plan_id'>
  )> }
);

export type GetUserCommunityTierQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserCommunityTierQuery = (
  { __typename?: 'query_root' }
  & { user_service_tiers: Array<(
    { __typename?: 'user_service_tiers' }
    & Pick<User_Service_Tiers, 'id' | 'orb_base_plan_id'>
  )> }
);

export type DowngradeUserToCommunityMutationVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type DowngradeUserToCommunityMutation = (
  { __typename?: 'mutation_root' }
  & { update_users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
  )>, delete_pending_user_subscription_updates?: Maybe<(
    { __typename?: 'pending_user_subscription_updates_mutation_response' }
    & Pick<Pending_User_Subscription_Updates_Mutation_Response, 'affected_rows'>
  )>, update_dashboards?: Maybe<(
    { __typename?: 'dashboards_mutation_response' }
    & Pick<Dashboards_Mutation_Response, 'affected_rows'>
  )>, update_queries?: Maybe<(
    { __typename?: 'queries_mutation_response' }
    & Pick<Queries_Mutation_Response, 'affected_rows'>
  )> }
);

export type TerminateApiUserSubscriptionMutationVariables = Exact<{
  userId: Scalars['Int'];
  subscriptionId: Scalars['String'];
  isForced?: Maybe<Scalars['Boolean']>;
}>;


export type TerminateApiUserSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { terminate_api_user_subscription: (
    { __typename?: 'TerminateApiUserSubscriptionResponse' }
    & Pick<TerminateApiUserSubscriptionResponse, 'ok'>
  ) }
);

export type GetTeamForOverageQueryVariables = Exact<{
  orbCustomerId: Scalars['String'];
}>;


export type GetTeamForOverageQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'name' | 'handle' | 'max_executions_overage_cost_cents'>
    & { service_tier: (
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'csv_downloads_per_month' | 'included_query_executions' | 'included_datapoints' | 'included_nanocredits'>
    ), admins: Array<(
      { __typename?: 'memberships' }
      & Pick<Memberships, 'id'>
      & { user?: Maybe<(
        { __typename?: 'users' }
        & Pick<Users, 'id' | 'name' | 'email'>
      )> }
    )> }
  )> }
);

export type UpdateTeamCsvDownloadQuotaMutationVariables = Exact<{
  id: Scalars['Int'];
  csv_download_quota_exceeded_until: Scalars['timestamptz'];
}>;


export type UpdateTeamCsvDownloadQuotaMutation = (
  { __typename?: 'mutation_root' }
  & { update_teams?: Maybe<(
    { __typename?: 'teams_mutation_response' }
    & { returning: Array<(
      { __typename?: 'teams' }
      & Pick<Teams, 'id'>
    )> }
  )> }
);

export type UpdateTeamQueryExecutionQuotaMutationVariables = Exact<{
  id: Scalars['Int'];
  execution_quota_exceeded_until: Scalars['timestamptz'];
}>;


export type UpdateTeamQueryExecutionQuotaMutation = (
  { __typename?: 'mutation_root' }
  & { update_teams?: Maybe<(
    { __typename?: 'teams_mutation_response' }
    & { returning: Array<(
      { __typename?: 'teams' }
      & Pick<Teams, 'id'>
    )> }
  )> }
);

export type GetUserForOverageQueryVariables = Exact<{
  orbCustomerId: Scalars['String'];
}>;


export type GetUserForOverageQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'max_executions_overage_cost_cents'>
    & { user_service_tier: (
      { __typename?: 'user_service_tiers' }
      & Pick<User_Service_Tiers, 'id' | 'csv_downloads_per_month' | 'included_query_executions' | 'included_nanocredits'>
    ), api_user_service_tier?: Maybe<(
      { __typename?: 'api_user_service_tiers' }
      & Pick<Api_User_Service_Tiers, 'id' | 'included_datapoints'>
    )> }
  )> }
);

export type UpdateUserCsvDownloadQuotaMutationVariables = Exact<{
  id: Scalars['Int'];
  csv_download_quota_exceeded_until: Scalars['timestamptz'];
}>;


export type UpdateUserCsvDownloadQuotaMutation = (
  { __typename?: 'mutation_root' }
  & { update_users?: Maybe<(
    { __typename?: 'users_mutation_response' }
    & { returning: Array<(
      { __typename?: 'users' }
      & Pick<Users, 'id'>
    )> }
  )> }
);

export type UpdateUserQueryExecutionQuotaMutationVariables = Exact<{
  id: Scalars['Int'];
  execution_quota_exceeded_until: Scalars['timestamptz'];
}>;


export type UpdateUserQueryExecutionQuotaMutation = (
  { __typename?: 'mutation_root' }
  & { update_users?: Maybe<(
    { __typename?: 'users_mutation_response' }
    & { returning: Array<(
      { __typename?: 'users' }
      & Pick<Users, 'id'>
    )> }
  )> }
);

export type GetResultQueryVariables = Exact<{
  query_id: Scalars['Int'];
  parameters: Array<Parameter> | Parameter;
  can_refresh: Scalars['Boolean'];
}>;


export type GetResultQuery = (
  { __typename?: 'query_root' }
  & { get_result_v4?: Maybe<(
    { __typename?: 'GetResultV4Response' }
    & Pick<GetResultV4Response, 'job_id' | 'result_id' | 'error_id'>
  )> }
);

export type PopularDashboardTagFragment = (
  { __typename?: 'popular_dashboard_tags' }
  & Pick<Popular_Dashboard_Tags, 'tag' | 'popularity'>
);

export type PopularQueryTagFragment = (
  { __typename?: 'popular_query_tags' }
  & Pick<Popular_Query_Tags, 'tag' | 'popularity'>
);

export type ListPopularDashboardTagsQueryVariables = Exact<{
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type ListPopularDashboardTagsQuery = (
  { __typename?: 'query_root' }
  & { popular_dashboard_tags: Array<(
    { __typename?: 'popular_dashboard_tags' }
    & PopularDashboardTagFragment
  )> }
);

export type ListPopularQueryTagsQueryVariables = Exact<{
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type ListPopularQueryTagsQuery = (
  { __typename?: 'query_root' }
  & { popular_query_tags: Array<(
    { __typename?: 'popular_query_tags' }
    & PopularQueryTagFragment
  )> }
);

export type FindTeamByStripeIdQueryVariables = Exact<{
  stripe_customer_id: Scalars['String'];
}>;


export type FindTeamByStripeIdQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'orb_customer_id'>
  )> }
);

export type FindSessionTeamPrivateInfoByIdQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type FindSessionTeamPrivateInfoByIdQuery = (
  { __typename?: 'query_root' }
  & { memberships_private_details: Array<(
    { __typename?: 'memberships_private_details' }
    & { team?: Maybe<(
      { __typename?: 'teams' }
      & { members_details?: Maybe<(
        { __typename?: 'team_members_details' }
        & Pick<Team_Members_Details, 'stripe_customer_id'>
      )> }
    )> }
  )> }
);

export type TeamMembersDetailsQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type TeamMembersDetailsQuery = (
  { __typename?: 'query_root' }
  & { teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id' | 'service_tier_id'>
    )> }
  )> }
);

export type FindTeamRoleQueryVariables = Exact<{
  user_id?: Maybe<Scalars['Int']>;
  team_id?: Maybe<Scalars['Int']>;
}>;


export type FindTeamRoleQuery = (
  { __typename?: 'query_root' }
  & { memberships: Array<(
    { __typename?: 'memberships' }
    & Pick<Memberships, 'id' | 'team_id'>
    & { private_details?: Maybe<(
      { __typename?: 'memberships_private_details' }
      & Pick<Memberships_Private_Details, 'role' | 'status'>
    )> }
  )> }
);

export type GetUserForEthereumAddressQueryVariables = Exact<{
  ethereum_address: Scalars['String'];
}>;


export type GetUserForEthereumAddressQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name'>
    & { cognitoId: Users['cognito_id'], ethereumAddress: Users['ethereum_address'] }
  )> }
);

export type UpdateUsersEthereumAddressMutationVariables = Exact<{
  cognito_id: Scalars['uuid'];
  ethereum_address: Scalars['String'];
}>;


export type UpdateUsersEthereumAddressMutation = (
  { __typename?: 'mutation_root' }
  & { update_users?: Maybe<(
    { __typename?: 'users_mutation_response' }
    & { returning: Array<(
      { __typename?: 'users' }
      & Pick<Users, 'ethereum_address'>
    )> }
  )> }
);

export type GetNonceForEthereumAddrQueryVariables = Exact<{
  ethereum_address: Scalars['String'];
}>;


export type GetNonceForEthereumAddrQuery = (
  { __typename?: 'query_root' }
  & { user_nonce: Array<(
    { __typename?: 'user_nonce' }
    & Pick<User_Nonce, 'ethereum_address' | 'nonce'>
  )> }
);

export type UpsertNonceForEthereumAddrMutationVariables = Exact<{
  ethereum_address: Scalars['String'];
  nonce: Scalars['String'];
}>;


export type UpsertNonceForEthereumAddrMutation = (
  { __typename?: 'mutation_root' }
  & { insert_user_nonce_one?: Maybe<(
    { __typename?: 'user_nonce' }
    & Pick<User_Nonce, 'ethereum_address' | 'nonce'>
  )> }
);

export type UserFragment = (
  { __typename?: 'users' }
  & Pick<Users, 'id' | 'name' | 'profile_image_url'>
);

export type SessionUserFragment = (
  { __typename?: 'users' }
  & Pick<Users, 'id' | 'name' | 'profile_image_url' | 'created_at'>
  & { private_info?: Maybe<(
    { __typename?: 'user_private' }
    & Pick<User_Private, 'permissions' | 'service_tier' | 'onboarding_qs_skipped_until'>
    & { stripeCustomerId: User_Private['stripe_customer_id'], orbCustomerId: User_Private['orb_customer_id'], serviceTierId: User_Private['service_tier'], apiServiceTierId: User_Private['api_service_tier_id'], orbSubscriptionId: User_Private['orb_subscription_id'], orbApiSubscriptionId: User_Private['orb_api_subscription_id'], fromServiceTier: User_Private['from_service_tier'] }
  )>, user_service_tier: (
    { __typename?: 'user_service_tiers' }
    & Pick<User_Service_Tiers, 'id' | 'name' | 'max_private_queries' | 'max_private_dashboards' | 'csv_downloads_per_month' | 'included_query_executions' | 'included_nanocredits' | 'remove_watermark' | 'base_monthly_price_dollars_cents' | 'max_query_event_retention_days' | 'is_public' | 'performance' | 'release_version'>
  ), api_user_service_tier?: Maybe<(
    { __typename?: 'api_user_service_tiers' }
    & Pick<Api_User_Service_Tiers, 'id' | 'name' | 'base_monthly_price_dollars_cents' | 'included_datapoints' | 'included_executions' | 'is_public'>
  )> }
);

export type FindSessionUserQueryVariables = Exact<{
  sub: Scalars['uuid'];
}>;


export type FindSessionUserQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & SessionUserFragment
  )> }
);

export type FindUserByStripeIdQueryVariables = Exact<{
  customerId: Scalars['String'];
}>;


export type FindUserByStripeIdQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & SessionUserFragment
  )> }
);

export type FindUserByOrbCustomerIdQueryVariables = Exact<{
  customerId: Scalars['String'];
}>;


export type FindUserByOrbCustomerIdQuery = (
  { __typename?: 'query_root' }
  & { users: Array<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'name' | 'email' | 'orb_subscription_id' | 'orb_api_subscription_id' | 'api_service_tier_id' | 'max_executions_overage_cost_cents'>
    & { service_tier: (
      { __typename?: 'user_service_tiers' }
      & Pick<User_Service_Tiers, 'id' | 'name' | 'release_version'>
    ) }
  )> }
);

export type VisualizationFragment = (
  { __typename?: 'visualizations' }
  & Pick<Visualizations, 'id' | 'type' | 'name' | 'options' | 'created_at'>
  & { query_details?: Maybe<(
    { __typename?: 'query_details' }
    & Pick<Query_Details, 'query_id' | 'name' | 'description' | 'show_watermark' | 'parameters' | 'dataset_id'>
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name' | 'profile_image_url'>
    )>, team?: Maybe<(
      { __typename?: 'teams' }
      & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url'>
    )> }
  )> }
);

export type FindVisualQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type FindVisualQuery = (
  { __typename?: 'query_root' }
  & { visualizations_by_pk?: Maybe<(
    { __typename?: 'visualizations' }
    & VisualizationFragment
  )> }
);

export type NlqModelsQueryVariables = Exact<{ [key: string]: never; }>;


export type NlqModelsQuery = (
  { __typename?: 'query_root' }
  & Pick<Query_Root, 'nlq_models'>
);

export type CompleteNlqModelMutationVariables = Exact<{
  model: Scalars['String'];
  prompt: Scalars['String'];
  table: Scalars['String'];
}>;


export type CompleteNlqModelMutation = (
  { __typename?: 'mutation_root' }
  & { complete_nlq_model: (
    { __typename?: 'CompleteNlqModelResponse' }
    & Pick<CompleteNlqModelResponse, 'id' | 'response'>
  ) }
);

export type InsertWandCompletionMutationVariables = Exact<{
  id: Scalars['uuid'];
  question: Scalars['String'];
  answer: Scalars['String'];
  user_id: Scalars['Int'];
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
}>;


export type InsertWandCompletionMutation = (
  { __typename?: 'mutation_root' }
  & { insert_wand_completions_one?: Maybe<(
    { __typename?: 'wand_completions' }
    & Pick<Wand_Completions, 'id'>
  )> }
);

export type UpdateWandCompletionQueryMutationVariables = Exact<{
  id: Scalars['uuid'];
  query_id?: Maybe<Scalars['Int']>;
  query_version?: Maybe<Scalars['Int']>;
}>;


export type UpdateWandCompletionQueryMutation = (
  { __typename?: 'mutation_root' }
  & { update_wand_completions?: Maybe<(
    { __typename?: 'wand_completions_mutation_response' }
    & Pick<Wand_Completions_Mutation_Response, 'affected_rows'>
  )> }
);

export type FindWandCompletionByQueryIdQueryVariables = Exact<{
  query_id: Scalars['Int'];
}>;


export type FindWandCompletionByQueryIdQuery = (
  { __typename?: 'query_root' }
  & { wand_completions: Array<(
    { __typename?: 'wand_completions' }
    & Pick<Wand_Completions, 'id' | 'question' | 'answer'>
  )> }
);

export type GenerateDataUploadUrlMutationVariables = Exact<{
  content_length: Scalars['Int'];
  file_name: Scalars['String'];
}>;


export type GenerateDataUploadUrlMutation = (
  { __typename?: 'mutation_root' }
  & { generate_data_upload_url?: Maybe<(
    { __typename?: 'PresignedUrlResponse' }
    & Pick<PresignedUrlResponse, 'url'>
  )> }
);

export type CreateFolderMutationVariables = Exact<{
  name: Scalars['String'];
  icon: Scalars['String'];
  color: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['Int']>;
}>;


export type CreateFolderMutation = (
  { __typename?: 'mutation_root' }
  & { create_folder: (
    { __typename?: 'Folder' }
    & Pick<Folder, 'id'>
  ) }
);

export type UploadedTablesQueryVariables = Exact<{ [key: string]: never; }>;


export type UploadedTablesQuery = (
  { __typename?: 'query_root' }
  & { uploaded_tables: Array<(
    { __typename?: 'UploadedTable' }
    & Pick<UploadedTable, 'file_name' | 'table_name' | 'status'>
  )> }
);

export type DefaultV2UserServiceTierQueryVariables = Exact<{ [key: string]: never; }>;


export type DefaultV2UserServiceTierQuery = (
  { __typename?: 'query_root' }
  & { user_service_tiers_by_pk?: Maybe<(
    { __typename?: 'user_service_tiers' }
    & Pick<User_Service_Tiers, 'id' | 'name' | 'base_monthly_price_dollars_cents' | 'included_nanocredits' | 'nanocredits_cost_cents' | 'max_private_dashboards' | 'max_private_queries' | 'csv_downloads_per_month'>
  )> }
);

export type GetAllV2TeamServiceTiersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllV2TeamServiceTiersQuery = (
  { __typename?: 'query_root' }
  & { team_service_tiers: Array<(
    { __typename?: 'team_service_tiers' }
    & Pick<Team_Service_Tiers, 'id' | 'name' | 'base_monthly_price_dollars_cents' | 'is_public' | 'included_nanocredits' | 'nanocredits_cost_cents' | 'max_private_dashboards' | 'max_private_queries' | 'csv_downloads_per_month' | 'release_version'>
  )> }
);

export type GetUserFreeTeamsCountQueryVariables = Exact<{
  user_id: Scalars['Int'];
}>;


export type GetUserFreeTeamsCountQuery = (
  { __typename?: 'query_root' }
  & { teams_aggregate: (
    { __typename?: 'teams_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'teams_aggregate_fields' }
      & Pick<Teams_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type CreateUserApiKeyMutationVariables = Exact<{
  name: Scalars['String'];
}>;


export type CreateUserApiKeyMutation = (
  { __typename?: 'mutation_root' }
  & { create_user_api_key: (
    { __typename?: 'CreateUserApiKeyResponse' }
    & Pick<CreateUserApiKeyResponse, 'id' | 'key' | 'name'>
  ) }
);

export type DeleteUserApiKeyMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteUserApiKeyMutation = (
  { __typename?: 'mutation_root' }
  & { delete_user_api_key: (
    { __typename?: 'DeleteUserApiKeyResponse' }
    & Pick<DeleteUserApiKeyResponse, 'id'>
  ) }
);

export type GetUserApiKeysQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserApiKeysQuery = (
  { __typename?: 'query_root' }
  & { user_api_keys: (
    { __typename?: 'ListUserApiKeysResponse' }
    & { keys: Array<(
      { __typename: 'ApiKeyEntry' }
      & Pick<ApiKeyEntry, 'id' | 'name' | 'suffix'>
    )> }
  ) }
);

export type ListInvoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type ListInvoicesQuery = (
  { __typename?: 'query_root' }
  & { get_invoices?: Maybe<(
    { __typename?: 'GetInvoiceResponse' }
    & { invoices: Array<(
      { __typename?: 'Invoice' }
      & Pick<Invoice, 'plan_display_name' | 'source' | 'date' | 'status' | 'href' | 'amount_display' | 'currency_key'>
    )> }
  )> }
);

export type GetMaxExecutionsOverageCostCentsQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetMaxExecutionsOverageCostCentsQuery = (
  { __typename?: 'query_root' }
  & { users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'max_executions_overage_cost_cents'>
  )> }
);

export type SetMaxExecutionsOverageCostCentsMutationVariables = Exact<{
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
}>;


export type SetMaxExecutionsOverageCostCentsMutation = (
  { __typename?: 'mutation_root' }
  & { set_max_executions_overage_cost_cents: (
    { __typename?: 'SetMaxExecutionsOverageCostCentsResponse' }
    & { user: (
      { __typename?: 'SetMaxExecutionsOverageCostCentsUpdatedUser' }
      & Pick<SetMaxExecutionsOverageCostCentsUpdatedUser, 'id' | 'max_executions_overage_cost_cents' | 'execution_quota_exceeded_until'>
    ) }
  ) }
);

export type GetUpcomingInvoiceQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUpcomingInvoiceQuery = (
  { __typename?: 'query_root' }
  & { upcoming_invoice?: Maybe<(
    { __typename?: 'GetUpcomingInvoiceResponse' }
    & { invoice: (
      { __typename?: 'UpcomingInvoice' }
      & Pick<UpcomingInvoice, 'amount_due' | 'target_date' | 'currency' | 'hosted_invoice_url'>
    ) }
  )> }
);

export type GetTeamUpcomingInvoiceQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamUpcomingInvoiceQuery = (
  { __typename?: 'query_root' }
  & { upcoming_invoice: (
    { __typename?: 'GetTeamUpcomingInvoiceResponse' }
    & { invoice: (
      { __typename?: 'UpcomingInvoice' }
      & Pick<UpcomingInvoice, 'amount_due' | 'target_date' | 'currency' | 'hosted_invoice_url'>
    ) }
  ) }
);

export type GetApiUpcomingInvoiceQueryVariables = Exact<{ [key: string]: never; }>;


export type GetApiUpcomingInvoiceQuery = (
  { __typename?: 'query_root' }
  & { upcoming_invoice?: Maybe<(
    { __typename?: 'GetApiUpcomingInvoiceResponse' }
    & { invoice: (
      { __typename?: 'UpcomingInvoice' }
      & Pick<UpcomingInvoice, 'amount_due' | 'target_date' | 'currency' | 'hosted_invoice_url'>
    ) }
  )> }
);

export type CancelPendingUserSubscriptionUpdateMutationVariables = Exact<{ [key: string]: never; }>;


export type CancelPendingUserSubscriptionUpdateMutation = (
  { __typename?: 'mutation_root' }
  & { cancel_user_pending_subscription_change: (
    { __typename?: 'CancelUserPendingSubscriptionChangeResponse' }
    & Pick<CancelUserPendingSubscriptionChangeResponse, 'ok'>
  ) }
);

export type GetPendingUpdatesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPendingUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_user_subscription_updates: Array<(
    { __typename?: 'pending_user_subscription_updates' }
    & Pick<Pending_User_Subscription_Updates, 'update_date' | 'update_type'>
    & { user_service_tier: (
      { __typename?: 'user_service_tiers' }
      & Pick<User_Service_Tiers, 'name'>
    ) }
  )> }
);

export type UserExtraCreditsCentsQueryVariables = Exact<{ [key: string]: never; }>;


export type UserExtraCreditsCentsQuery = (
  { __typename?: 'query_root' }
  & { billable_usage?: Maybe<(
    { __typename?: 'BillableUsageResponse' }
    & Pick<BillableUsageResponse, 'extra_credits_cents'>
  )> }
);

export type GetUserTeamsCountQueryVariables = Exact<{
  user_id: Scalars['Int'];
}>;


export type GetUserTeamsCountQuery = (
  { __typename?: 'query_root' }
  & { teams_aggregate: (
    { __typename?: 'teams_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'teams_aggregate_fields' }
      & Pick<Teams_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type GetUserUsageQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserUsageQuery = (
  { __typename?: 'query_root' }
  & { users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id' | 'max_executions_overage_cost_cents'>
    & { private_info?: Maybe<(
      { __typename?: 'user_private' }
      & Pick<User_Private, 'max_overage_cents'>
    )>, service_tier: (
      { __typename?: 'user_service_tiers' }
      & Pick<User_Service_Tiers, 'id' | 'max_private_queries' | 'max_private_dashboards' | 'csv_downloads_per_month' | 'included_query_executions' | 'nanocredits_cost_cents'>
    ) }
  )>, dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ), queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ), billable_usage?: Maybe<(
    { __typename?: 'BillableUsageResponse' }
    & Pick<BillableUsageResponse, 'query_executions' | 'csv_downloads' | 'datapoints_read' | 'credits_used' | 'credits_included' | 'extra_credits_cents' | 'max_extra_credits_cents'>
  )> }
);

export type MigrateContentMutationVariables = Exact<{
  teamId: Scalars['Int'];
  redirect?: Maybe<Scalars['Boolean']>;
}>;


export type MigrateContentMutation = (
  { __typename?: 'mutation_root' }
  & { migrate_content: (
    { __typename?: 'MigrateContentResponse' }
    & Pick<MigrateContentResponse, 'total_dashboards' | 'migrated_dashboards' | 'total_queries' | 'migrated_queries'>
  ) }
);

export type GetUserMaxOverageCentsQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserMaxOverageCentsQuery = (
  { __typename?: 'query_root' }
  & { users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
    & { private_info?: Maybe<(
      { __typename?: 'user_private' }
      & Pick<User_Private, 'max_overage_cents'>
    )> }
  )> }
);

export type SetUserMaxOverageCentsMutationVariables = Exact<{
  max_overage_cents?: Maybe<Scalars['Int']>;
}>;


export type SetUserMaxOverageCentsMutation = (
  { __typename?: 'mutation_root' }
  & { set_max_overage_cents: (
    { __typename?: 'SetMaxOverageCentsResponse' }
    & Pick<SetMaxOverageCentsResponse, 'max_overage_cents'>
  ) }
);

export type GetUserMaxDatapointsPerRequestQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserMaxDatapointsPerRequestQuery = (
  { __typename?: 'query_root' }
  & { users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
    & { private_info?: Maybe<(
      { __typename?: 'user_private' }
      & Pick<User_Private, 'max_datapoints_per_request'>
    )> }
  )> }
);

export type SetUserMaxDatapointsPerRequestMutationVariables = Exact<{
  id: Scalars['Int'];
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
}>;


export type SetUserMaxDatapointsPerRequestMutation = (
  { __typename?: 'mutation_root' }
  & { update_users_by_pk?: Maybe<(
    { __typename?: 'users' }
    & Pick<Users, 'id'>
    & { private_info?: Maybe<(
      { __typename?: 'user_private' }
      & Pick<User_Private, 'max_datapoints_per_request'>
    )> }
  )> }
);

export type InviteMemberMutationVariables = Exact<{
  team_id: Scalars['Int'];
  role: Scalars['String'];
  usernameOrEmail: Scalars['String'];
}>;


export type InviteMemberMutation = (
  { __typename?: 'mutation_root' }
  & { invite_member_v2?: Maybe<(
    { __typename?: 'InviteMemberResponse' }
    & Pick<InviteMemberResponse, 'id'>
  )> }
);

export type CreateTeamApiKeyMutationVariables = Exact<{
  name: Scalars['String'];
  teamId: Scalars['Int'];
}>;


export type CreateTeamApiKeyMutation = (
  { __typename?: 'mutation_root' }
  & { create_team_api_key: (
    { __typename?: 'CreateTeamApiKeyResponse' }
    & Pick<CreateTeamApiKeyResponse, 'id' | 'key' | 'name'>
  ) }
);

export type DeleteTeamApiKeyMutationVariables = Exact<{
  id: Scalars['String'];
  teamId: Scalars['Int'];
}>;


export type DeleteTeamApiKeyMutation = (
  { __typename?: 'mutation_root' }
  & { delete_team_api_key: (
    { __typename?: 'DeleteTeamApiKeyResponse' }
    & Pick<DeleteTeamApiKeyResponse, 'id'>
  ) }
);

export type GetTeamApiKeysQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamApiKeysQuery = (
  { __typename?: 'query_root' }
  & { team_api_keys: (
    { __typename?: 'ListTeamApiKeysResponse' }
    & { keys: Array<(
      { __typename: 'ApiKeyEntry' }
      & Pick<ApiKeyEntry, 'id' | 'name' | 'suffix'>
    )> }
  ) }
);

export type GetTeamQueryVariables = Exact<{
  team_handle: Scalars['String'];
  userId: Scalars['Int'];
}>;


export type GetTeamQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url' | 'twitter_handle' | 'telegram_handle' | 'discord_url' | 'bio'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id' | 'show_members' | 'enable_service_tier_badge'>
      & { service_tier?: Maybe<(
        { __typename?: 'team_service_tiers' }
        & Pick<Team_Service_Tiers, 'id' | 'name' | 'is_public' | 'base_monthly_price_dollars_cents' | 'included_datapoints' | 'release_version' | 'remove_watermark' | 'performance'>
      )> }
    )> }
  )> }
);

export type ResendInviteMutationVariables = Exact<{
  membership_id: Scalars['uuid'];
}>;


export type ResendInviteMutation = (
  { __typename?: 'mutation_root' }
  & { resend_invite_v2?: Maybe<(
    { __typename?: 'ResendInviteResponse' }
    & Pick<ResendInviteResponse, 'ok'>
  )> }
);

export type ListTeamInvoicesQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type ListTeamInvoicesQuery = (
  { __typename?: 'query_root' }
  & { get_invoices?: Maybe<(
    { __typename?: 'GetTeamInvoiceResponse' }
    & { invoices: Array<(
      { __typename?: 'Invoice' }
      & Pick<Invoice, 'plan_display_name' | 'source' | 'date' | 'status' | 'href' | 'amount_display' | 'currency_key'>
    )> }
  )> }
);

export type TeamExtraCreditsCentsQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type TeamExtraCreditsCentsQuery = (
  { __typename?: 'query_root' }
  & { team_billable_usage: (
    { __typename?: 'TeamBillableUsageResponse' }
    & Pick<TeamBillableUsageResponse, 'extra_credits_cents'>
  ) }
);

export type CancelPendingTeamSubscriptionUpdateMutationVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type CancelPendingTeamSubscriptionUpdateMutation = (
  { __typename?: 'mutation_root' }
  & { cancel_team_pending_subscription_change: (
    { __typename?: 'CancelTeamPendingSubscriptionChangeResponse' }
    & Pick<CancelTeamPendingSubscriptionChangeResponse, 'ok'>
  ) }
);

export type GetIsTeamEnterpriseQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetIsTeamEnterpriseQuery = (
  { __typename?: 'query_root' }
  & { teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id'>
      & { service_tier?: Maybe<(
        { __typename?: 'team_service_tiers' }
        & Pick<Team_Service_Tiers, 'id' | 'is_public'>
      )> }
    )> }
  )> }
);

export type GetTeamPendingUpdatesQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamPendingUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_team_subscription_updates: Array<(
    { __typename?: 'pending_team_subscription_updates' }
    & Pick<Pending_Team_Subscription_Updates, 'update_date' | 'update_type'>
    & { service_tier: (
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'name'>
    ) }
  )> }
);

export type GetTeamMaxOverageCentsQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamMaxOverageCentsQuery = (
  { __typename?: 'query_root' }
  & { teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id' | 'max_overage_cents'>
    )> }
  )> }
);

export type SetTeamMaxOverageCentsMutationVariables = Exact<{
  teamId: Scalars['Int'];
  max_overage_cents?: Maybe<Scalars['Int']>;
}>;


export type SetTeamMaxOverageCentsMutation = (
  { __typename?: 'mutation_root' }
  & { set_team_max_overage_cents: (
    { __typename?: 'SetTeamMaxOverageCentsResponse' }
    & { team: (
      { __typename?: 'SetTeamMaxOverageCentsUpdatedTeam' }
      & Pick<SetTeamMaxOverageCentsUpdatedTeam, 'id' | 'max_overage_cents'>
    ) }
  ) }
);

export type GetTeamMaxExecutionsOverageCostCentsQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamMaxExecutionsOverageCostCentsQuery = (
  { __typename?: 'query_root' }
  & { teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id' | 'max_executions_overage_cost_cents'>
    )> }
  )> }
);

export type SetTeamMaxExecutionsOverageCostCentsMutationVariables = Exact<{
  teamId: Scalars['Int'];
  max_executions_overage_cost_cents?: Maybe<Scalars['Int']>;
}>;


export type SetTeamMaxExecutionsOverageCostCentsMutation = (
  { __typename?: 'mutation_root' }
  & { set_team_max_executions_overage_cost_cents: (
    { __typename?: 'SetTeamMaxExecutionsOverageCostCentsResponse' }
    & { team: (
      { __typename?: 'SetMaxExecutionsOverageCostCentsUpdatedTeam' }
      & Pick<SetMaxExecutionsOverageCostCentsUpdatedTeam, 'id' | 'max_executions_overage_cost_cents' | 'execution_quota_exceeded_until'>
    ) }
  ) }
);

export type GetTeamMaxDatapointsPerRequestQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetTeamMaxDatapointsPerRequestQuery = (
  { __typename?: 'query_root' }
  & { teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id' | 'max_datapoints_per_request'>
    )> }
  )> }
);

export type SetTeamMaxDatapointsPerRequestMutationVariables = Exact<{
  id: Scalars['Int'];
  max_datapoints_per_request?: Maybe<Scalars['Int']>;
}>;


export type SetTeamMaxDatapointsPerRequestMutation = (
  { __typename?: 'mutation_root' }
  & { update_teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id' | 'max_datapoints_per_request'>
    )> }
  )> }
);

export type GetTeamUsageQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamUsageQuery = (
  { __typename?: 'query_root' }
  & { dashboards_aggregate: (
    { __typename?: 'dashboards_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'dashboards_aggregate_fields' }
      & Pick<Dashboards_Aggregate_Fields, 'count'>
    )> }
  ), queries_aggregate: (
    { __typename?: 'queries_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'queries_aggregate_fields' }
      & Pick<Queries_Aggregate_Fields, 'count'>
    )> }
  ), team_members_details: Array<(
    { __typename?: 'team_members_details' }
    & Pick<Team_Members_Details, 'id' | 'max_overage_cents' | 'max_executions_overage_cost_cents'>
    & { service_tier?: Maybe<(
      { __typename?: 'team_service_tiers' }
      & Pick<Team_Service_Tiers, 'id' | 'name' | 'base_monthly_price_dollars_cents' | 'max_private_dashboards' | 'max_private_queries' | 'release_version' | 'nanocredits_cost_cents'>
    )> }
  )>, team_billable_usage: (
    { __typename?: 'TeamBillableUsageResponse' }
    & Pick<TeamBillableUsageResponse, 'query_executions' | 'csv_downloads' | 'max_csv_downloads' | 'max_query_executions' | 'max_datapoints_read' | 'datapoints_read' | 'credits_included' | 'credits_used' | 'extra_credits_cents' | 'max_extra_credits_cents'>
  ) }
);

export type UpdateTeamMutationVariables = Exact<{
  team_id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  handle?: Maybe<Scalars['String']>;
  profile_image_url?: Maybe<Scalars['String']>;
  twitter_handle?: Maybe<Scalars['String']>;
  telegram_handle?: Maybe<Scalars['String']>;
  discord_url?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  show_members?: Maybe<Scalars['Boolean']>;
  enable_service_tier_badge?: Maybe<Scalars['Boolean']>;
}>;


export type UpdateTeamMutation = (
  { __typename?: 'mutation_root' }
  & { update_teams_by_pk?: Maybe<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url' | 'twitter_handle' | 'telegram_handle' | 'discord_url' | 'bio'>
    & { members_details?: Maybe<(
      { __typename?: 'team_members_details' }
      & Pick<Team_Members_Details, 'id' | 'show_members' | 'enable_service_tier_badge'>
    )> }
  )> }
);

export type CreateUserCheckoutSessionMutationVariables = Exact<{
  redirect_path: Scalars['String'];
}>;


export type CreateUserCheckoutSessionMutation = (
  { __typename?: 'mutation_root' }
  & { create_user_checkout_session: (
    { __typename?: 'CreateUserCheckoutSessionResponse' }
    & Pick<CreateUserCheckoutSessionResponse, 'checkout_session_id'>
  ) }
);

export type CreateTeamCheckoutSessionMutationVariables = Exact<{
  team_id: Scalars['Int'];
  redirect_path: Scalars['String'];
}>;


export type CreateTeamCheckoutSessionMutation = (
  { __typename?: 'mutation_root' }
  & { create_team_checkout_session: (
    { __typename?: 'CreateTeamCheckoutSessionResponse' }
    & Pick<CreateTeamCheckoutSessionResponse, 'checkout_session_id'>
  ) }
);

export type CompleteStripeCheckoutSessionMutationVariables = Exact<{
  checkout_session_id: Scalars['String'];
}>;


export type CompleteStripeCheckoutSessionMutation = (
  { __typename?: 'mutation_root' }
  & { complete_stripe_checkout_session: (
    { __typename?: 'CompleteStripeCheckoutSessionResponse' }
    & { card: (
      { __typename?: 'StripeCard' }
      & Pick<StripeCard, 'brand' | 'last4' | 'exp_month' | 'exp_year'>
    ) }
  ) }
);

export type GetTeamDefaultCardQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamDefaultCardQuery = (
  { __typename?: 'query_root' }
  & { team_stripe_default_card: (
    { __typename?: 'TeamStripeDefaultCardResponse' }
    & { card?: Maybe<(
      { __typename?: 'StripeCard' }
      & Pick<StripeCard, 'brand' | 'last4' | 'exp_month' | 'exp_year'>
    )> }
  ) }
);

export type DowngradeTeamSubscriptionMutationVariables = Exact<{
  teamId: Scalars['Int'];
  serviceTierName: Scalars['String'];
}>;


export type DowngradeTeamSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { downgrade_team_subscription: (
    { __typename?: 'DowngradeTeamSubscriptionResponse' }
    & Pick<DowngradeTeamSubscriptionResponse, 'ok'>
  ) }
);

export type PendingTeamSubscriptionUpdatesQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type PendingTeamSubscriptionUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_team_subscription_updates: Array<(
    { __typename?: 'pending_team_subscription_updates' }
    & Pick<Pending_Team_Subscription_Updates, 'update_type'>
  )> }
);

export type UpgradeTeamSubscriptionMutationVariables = Exact<{
  teamId: Scalars['Int'];
  serviceTierName: Scalars['String'];
}>;


export type UpgradeTeamSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { upgrade_team_subscription: (
    { __typename?: 'UpgradeTeamSubscriptionResponse' }
    & Pick<UpgradeTeamSubscriptionResponse, 'ok'>
  ) }
);

export type MigrateLegacyPlanMutationVariables = Exact<{
  teamId?: Maybe<Scalars['Int']>;
  serviceTierId: Scalars['Int'];
}>;


export type MigrateLegacyPlanMutation = (
  { __typename?: 'mutation_root' }
  & { migrate_legacy_plan: (
    { __typename?: 'MigrateLegacyPlanResponse' }
    & Pick<MigrateLegacyPlanResponse, 'ok'>
  ) }
);

export type GetTeamInfoQueryVariables = Exact<{
  handle: Scalars['String'];
}>;


export type GetTeamInfoQuery = (
  { __typename?: 'query_root' }
  & { teams: Array<(
    { __typename?: 'teams' }
    & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url'>
  )> }
);

export type GetTeamPrivateInfoQueryVariables = Exact<{
  teamHandle: Scalars['String'];
  userId: Scalars['Int'];
}>;


export type GetTeamPrivateInfoQuery = (
  { __typename?: 'query_root' }
  & { memberships_private_details: Array<(
    { __typename?: 'memberships_private_details' }
    & Pick<Memberships_Private_Details, 'role' | 'team_id'>
    & { team?: Maybe<(
      { __typename?: 'teams' }
      & { service_tier: (
        { __typename?: 'team_service_tiers' }
        & Pick<Team_Service_Tiers, 'id' | 'base_monthly_price_dollars_cents'>
      ) }
    )> }
  )> }
);

export type DowngradeUserSubscriptionMutationVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type DowngradeUserSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { downgrade_user_subscription: (
    { __typename?: 'DowngradeUserSubscriptionResponse' }
    & Pick<DowngradeUserSubscriptionResponse, 'ok'>
  ) }
);

export type PendingUserSubscriptionUpdatesQueryVariables = Exact<{ [key: string]: never; }>;


export type PendingUserSubscriptionUpdatesQuery = (
  { __typename?: 'query_root' }
  & { pending_user_subscription_updates: Array<(
    { __typename?: 'pending_user_subscription_updates' }
    & Pick<Pending_User_Subscription_Updates, 'user_id' | 'update_type'>
  )> }
);

export type UpgradeUserSubscriptionMutationVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type UpgradeUserSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { upgrade_user_subscription: (
    { __typename?: 'UpgradeUserSubscriptionResponse' }
    & Pick<UpgradeUserSubscriptionResponse, 'ok'>
  ) }
);

export type DowngradeApiUserSubscriptionMutationVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type DowngradeApiUserSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { downgrade_api_user_subscription: (
    { __typename?: 'DowngradeApiUserSubscriptionResponse' }
    & Pick<DowngradeApiUserSubscriptionResponse, 'ok'>
  ) }
);

export type UpgradeApiUserSubscriptionMutationVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type UpgradeApiUserSubscriptionMutation = (
  { __typename?: 'mutation_root' }
  & { upgrade_api_user_subscription: (
    { __typename?: 'UpgradeApiUserSubscriptionResponse' }
    & Pick<UpgradeApiUserSubscriptionResponse, 'ok'>
  ) }
);

export type GetDefaultCardQueryVariables = Exact<{ [key: string]: never; }>;


export type GetDefaultCardQuery = (
  { __typename?: 'query_root' }
  & { stripe_default_card: (
    { __typename?: 'StripeDefaultCardResponse' }
    & { card?: Maybe<(
      { __typename?: 'StripeCard' }
      & Pick<StripeCard, 'brand' | 'last4' | 'exp_month' | 'exp_year'>
    )> }
  ) }
);

export type FindDashboardNameWithRedirectQueryVariables = Exact<{
  redirect_from?: Maybe<Scalars['String']>;
}>;


export type FindDashboardNameWithRedirectQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & Pick<Dashboards, 'id' | 'slug'>
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name'>
    )>, team?: Maybe<(
      { __typename?: 'teams' }
      & Pick<Teams, 'id' | 'handle'>
    )> }
  )> }
);

export type IsHandleAvailableQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type IsHandleAvailableQuery = (
  { __typename?: 'query_root' }
  & { handles_aggregate: (
    { __typename?: 'handles_aggregate' }
    & { aggregate?: Maybe<(
      { __typename?: 'handles_aggregate_fields' }
      & Pick<Handles_Aggregate_Fields, 'count'>
    )> }
  ) }
);

export type FindUserForDashboardQueryVariables = Exact<{
  slug: Scalars['String'];
  before: Scalars['timestamptz'];
}>;


export type FindUserForDashboardQuery = (
  { __typename?: 'query_root' }
  & { dashboards: Array<(
    { __typename?: 'dashboards' }
    & { user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'name'>
    )> }
  )> }
);

export type FindDashboardForKeyQueryVariables = Exact<{
  api_key: Scalars['String'];
}>;


export type FindDashboardForKeyQuery = (
  { __typename?: 'query_root' }
  & { api_keys: Array<(
    { __typename?: 'api_keys' }
    & { dashboard?: Maybe<(
      { __typename?: 'dashboards' }
      & Pick<Dashboards, 'slug' | 'is_private'>
      & { user?: Maybe<(
        { __typename?: 'users' }
        & Pick<Users, 'name'>
      )> }
    )> }
  )> }
);

export type GetServiceTierInfoByNameQueryVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type GetServiceTierInfoByNameQuery = (
  { __typename?: 'query_root' }
  & { user_service_tiers: Array<(
    { __typename?: 'user_service_tiers' }
    & Pick<User_Service_Tiers, 'id' | 'name' | 'base_monthly_price_dollars_cents' | 'max_private_queries' | 'max_private_dashboards' | 'remove_watermark' | 'csv_downloads_per_month' | 'performance' | 'included_query_executions' | 'included_nanocredits' | 'nanocredits_cost_cents' | 'query_exec_overage_dollars_cents' | 'is_public' | 'release_version'>
  )> }
);

export type GetApiUserServiceTierInfoByNameQueryVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type GetApiUserServiceTierInfoByNameQuery = (
  { __typename?: 'query_root' }
  & { api_user_service_tiers: Array<(
    { __typename?: 'api_user_service_tiers' }
    & Pick<Api_User_Service_Tiers, 'id' | 'name' | 'base_monthly_price_dollars_cents' | 'datapoint_overage_10k_cost_dollars_cents' | 'included_datapoints' | 'included_executions' | 'read_results_api_calls_per_minute' | 'dune_attribution_required'>
  )> }
);

export type GetTeamServiceTierInfoByNameQueryVariables = Exact<{
  service_tier_name: Scalars['String'];
}>;


export type GetTeamServiceTierInfoByNameQuery = (
  { __typename?: 'query_root' }
  & { team_service_tiers: Array<(
    { __typename?: 'team_service_tiers' }
    & Pick<Team_Service_Tiers, 'id' | 'name' | 'base_monthly_price_dollars_cents' | 'max_private_queries' | 'max_private_dashboards' | 'remove_watermark' | 'csv_downloads_per_month' | 'performance' | 'included_query_executions' | 'query_exec_overage_dollars_cents' | 'max_query_event_retention_days' | 'included_nanocredits' | 'nanocredits_cost_cents' | 'release_version'>
  )> }
);

export type SubmitOnboardingQsMutationVariables = Exact<{
  user_id: Scalars['Int'];
  brings_to_dune: Scalars['String'];
  achieve_with_dune: Scalars['String'];
  sql_experience?: Maybe<Scalars['String']>;
  blockchain_experience: Scalars['String'];
  organization_size?: Maybe<Scalars['String']>;
  version: Scalars['String'];
  until: Scalars['timestamptz'];
}>;


export type SubmitOnboardingQsMutation = (
  { __typename?: 'mutation_root' }
  & { insert_onboarding_questions?: Maybe<(
    { __typename?: 'onboarding_questions_mutation_response' }
    & Pick<Onboarding_Questions_Mutation_Response, 'affected_rows'>
  )>, update_users?: Maybe<(
    { __typename?: 'users_mutation_response' }
    & { returning: Array<(
      { __typename?: 'users' }
      & Pick<Users, 'id'>
      & { private_info?: Maybe<(
        { __typename?: 'user_private' }
        & Pick<User_Private, 'onboarding_qs_skipped_until'>
      )> }
    )> }
  )> }
);

export type SkipOnboardingQsMutationVariables = Exact<{
  user_id: Scalars['Int'];
  until: Scalars['timestamptz'];
}>;


export type SkipOnboardingQsMutation = (
  { __typename?: 'mutation_root' }
  & { update_users?: Maybe<(
    { __typename?: 'users_mutation_response' }
    & { returning: Array<(
      { __typename?: 'users' }
      & Pick<Users, 'id'>
      & { private_info?: Maybe<(
        { __typename?: 'user_private' }
        & Pick<User_Private, 'onboarding_qs_skipped_until'>
      )> }
    )> }
  )> }
);

export type GetTeamOperationCostsQueryVariables = Exact<{
  teamId: Scalars['Int'];
}>;


export type GetTeamOperationCostsQuery = (
  { __typename?: 'query_root' }
  & { team_operation_costs: (
    { __typename?: 'OperationCosts' }
    & Pick<OperationCosts, 'key'>
    & { interactive_executions: Array<(
      { __typename?: 'InteractiveExecutions' }
      & Pick<InteractiveExecutions, 'dataset_id' | 'public_performance_tier_key' | 'credits'>
    )> }
  ) }
);

export type GetUserOperationCostsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserOperationCostsQuery = (
  { __typename?: 'query_root' }
  & { user_operation_costs: (
    { __typename?: 'OperationCosts' }
    & Pick<OperationCosts, 'key'>
    & { interactive_executions: Array<(
      { __typename?: 'InteractiveExecutions' }
      & Pick<InteractiveExecutions, 'dataset_id' | 'public_performance_tier_key' | 'credits'>
    )> }
  ) }
);

export type ExecuteQueryV3MutationVariables = Exact<{
  query_id: Scalars['Int'];
  executor: ContextOwner;
  performance?: Maybe<Scalars['String']>;
  parameters: Array<Parameter> | Parameter;
}>;


export type ExecuteQueryV3Mutation = (
  { __typename?: 'mutation_root' }
  & { execute_query_v3?: Maybe<(
    { __typename?: 'ExecuteQueryResponse' }
    & Pick<ExecuteQueryResponse, 'job_id'>
  )> }
);

export type AcceptInviteMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type AcceptInviteMutation = (
  { __typename?: 'mutation_root' }
  & { accept_invite_v2?: Maybe<(
    { __typename?: 'AcceptInviteResponse' }
    & Pick<AcceptInviteResponse, 'ok'>
  )> }
);

export type UpdateTeamMemberRoleMutationVariables = Exact<{
  id: Scalars['uuid'];
  role: Scalars['membership_roles'];
}>;


export type UpdateTeamMemberRoleMutation = (
  { __typename?: 'mutation_root' }
  & { update_memberships_by_pk?: Maybe<(
    { __typename?: 'memberships' }
    & Pick<Memberships, 'id'>
    & { private_details?: Maybe<(
      { __typename?: 'memberships_private_details' }
      & Pick<Memberships_Private_Details, 'id' | 'role' | 'status'>
    )>, user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name' | 'profile_image_url'>
    )>, team: (
      { __typename?: 'teams' }
      & Pick<Teams, 'id' | 'name'>
    ) }
  )> }
);

export type CreateTeamMutationVariables = Exact<{
  name: Scalars['String'];
  handle: Scalars['String'];
  profile_image_url?: Maybe<Scalars['String']>;
}>;


export type CreateTeamMutation = (
  { __typename?: 'mutation_root' }
  & { create_team?: Maybe<(
    { __typename?: 'CreateTeamResponse' }
    & Pick<CreateTeamResponse, 'team_id'>
  )> }
);

export type DeleteTeamMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteTeamMutation = (
  { __typename?: 'mutation_root' }
  & { delete_team?: Maybe<(
    { __typename?: 'DeleteTeamResponse' }
    & Pick<DeleteTeamResponse, 'ok'>
  )> }
);

export type DeleteMembershipMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteMembershipMutation = (
  { __typename?: 'mutation_root' }
  & { delete_memberships_by_pk?: Maybe<(
    { __typename?: 'memberships' }
    & Pick<Memberships, 'id'>
  )> }
);

export type ListUserMembershipsQueryVariables = Exact<{
  user_id?: Maybe<Scalars['Int']>;
  user_email?: Maybe<Scalars['String']>;
}>;


export type ListUserMembershipsQuery = (
  { __typename?: 'query_root' }
  & { memberships_private_details: Array<(
    { __typename?: 'memberships_private_details' }
    & Pick<Memberships_Private_Details, 'id' | 'role' | 'status'>
    & { team?: Maybe<(
      { __typename?: 'teams' }
      & Pick<Teams, 'id' | 'name' | 'handle' | 'profile_image_url'>
      & { service_tier: (
        { __typename?: 'team_service_tiers' }
        & Pick<Team_Service_Tiers, 'id' | 'name' | 'release_version' | 'is_public' | 'csv_downloads_per_month' | 'included_datapoints' | 'included_nanocredits'>
      ) }
    )> }
  )> }
);

export type ListTeamMembersQueryVariables = Exact<{
  team_id: Scalars['Int'];
}>;


export type ListTeamMembersQuery = (
  { __typename?: 'query_root' }
  & { memberships_private_details: Array<(
    { __typename?: 'memberships_private_details' }
    & Pick<Memberships_Private_Details, 'id' | 'role' | 'status' | 'email'>
    & { team?: Maybe<(
      { __typename?: 'teams' }
      & Pick<Teams, 'id' | 'name'>
    )>, user?: Maybe<(
      { __typename?: 'users' }
      & Pick<Users, 'id' | 'name' | 'profile_image_url'>
    )> }
  )> }
);

export const DashboardItemFragmentDoc = gql`
    fragment DashboardItem on dashboards {
  id
  name
  slug
  created_at
  updated_at
  tags
  user {
    name
    profile_image_url
  }
  team {
    handle
    profile_image_url
  }
  is_private
  dashboard_favorite_count_all @include(if: $include_favs_all_time) {
    favorite_count
  }
  dashboard_favorite_count_last_24h @include(if: $include_favs_last_24h) {
    favorite_count
  }
  dashboard_favorite_count_last_7d @include(if: $include_favs_last_7d) {
    favorite_count
  }
  dashboard_favorite_count_last_30d @include(if: $include_favs_last_30d) {
    favorite_count
  }
  trending_scores {
    score_1h
    score_4h
    score_24h
    updated_at
  }
}
    `;
export const QueryItemFragmentDoc = gql`
    fragment QueryItem on queries {
  id
  name
  created_at
  updated_at
  tags
  matview_id
  user {
    id
    name
    profile_image_url
  }
  team {
    id
    handle
    profile_image_url
  }
  is_private
  query_favorite_count_all @include(if: $include_favs_all_time) {
    favorite_count
  }
  query_favorite_count_last_24h @include(if: $include_favs_last_24h) {
    favorite_count
  }
  query_favorite_count_last_7d @include(if: $include_favs_last_7d) {
    favorite_count
  }
  query_favorite_count_last_30d @include(if: $include_favs_last_30d) {
    favorite_count
  }
}
    `;
export const TeamItemFragmentDoc = gql`
    fragment TeamItem on teams {
  id
  name
  handle
  profile_image_url
  created_at
  received_stars {
    sum
  }
  members: memberships(where: {user_id: {_is_null: false}}) {
    user {
      id
      name
      profile_image_url
    }
  }
}
    `;
export const QueryExplorerQueryItemFragmentDoc = gql`
    fragment QueryExplorerQueryItem on queries {
  id
  name
  created_at
  dataset_id
  matview_id
  user {
    id
    name
    profile_image_url
  }
  team {
    id
    handle
    profile_image_url
  }
  is_private
}
    `;
export const DashboardItemOnProfileFragmentDoc = gql`
    fragment DashboardItemOnProfile on dashboards {
  id
  name
  slug
  created_at
  tags
  dashboard_favorite_count_all {
    favorite_count
  }
  trending_scores {
    score_1h
    score_4h
    score_24h
    updated_at
  }
}
    `;
export const QueryItemOnProfileFragmentDoc = gql`
    fragment QueryItemOnProfile on queries {
  id
  name
  created_at
  tags
  query_favorite_count_all {
    favorite_count
  }
}
    `;
export const UserFragmentDoc = gql`
    fragment User on users {
  id
  name
  profile_image_url
}
    `;
export const TeamFragmentDoc = gql`
    fragment Team on teams {
  id
  name
  handle
  profile_image_url
}
    `;
export const EntryDashboardFragmentDoc = gql`
    fragment EntryDashboard on dashboards {
  id
  name
  slug
  is_private
  is_archived
  created_at
  updated_at
  tags
  user {
    ...User
  }
  team {
    ...Team
  }
  dashboard_favorite_count_all @include(if: $favs_all_time) {
    favorite_count
  }
  dashboard_favorite_count_last_24h @include(if: $favs_last_24h) {
    favorite_count
  }
  dashboard_favorite_count_last_7d @include(if: $favs_last_7d) {
    favorite_count
  }
  dashboard_favorite_count_last_30d @include(if: $favs_last_30d) {
    favorite_count
  }
  trending_scores {
    score_1h
    score_4h
    score_24h
    updated_at
  }
}
    ${UserFragmentDoc}
${TeamFragmentDoc}`;
export const VisualizationFragmentDoc = gql`
    fragment Visualization on visualizations {
  id
  type
  name
  options
  created_at
  query_details {
    query_id
    name
    description
    show_watermark
    parameters
    dataset_id
    user {
      id
      name
      profile_image_url
    }
    team {
      id
      name
      handle
      profile_image_url
    }
  }
}
    `;
export const EntryDashboardWithVizWidgetsFragmentDoc = gql`
    fragment EntryDashboardWithVizWidgets on dashboards {
  id
  name
  slug
  is_private
  is_archived
  created_at
  updated_at
  user {
    ...User
  }
  team {
    ...Team
  }
  visualization_widgets {
    id
    visualization {
      ...Visualization
    }
  }
}
    ${UserFragmentDoc}
${TeamFragmentDoc}
${VisualizationFragmentDoc}`;
export const DashboardFragmentDoc = gql`
    fragment Dashboard on dashboards {
  id
  name
  slug
  is_private
  is_archived
  created_at
  updated_at
  tags
  user {
    ...User
  }
  team {
    ...Team
  }
  forked_dashboard {
    slug
    name
    user {
      name
    }
    team {
      handle
    }
  }
  text_widgets {
    id
    created_at
    updated_at
    text
    options
  }
  visualization_widgets {
    id
    created_at
    updated_at
    options
    visualization {
      ...Visualization
    }
  }
  param_widgets {
    id
    key
    visualization_widget_id
    query_id
    dashboard_id
    options
    created_at
    updated_at
  }
  dashboard_favorite_count_all {
    favorite_count
  }
  trending_scores {
    score_1h
    score_4h
    score_24h
    updated_at
  }
}
    ${UserFragmentDoc}
${TeamFragmentDoc}
${VisualizationFragmentDoc}`;
export const BaseQueryFragmentDoc = gql`
    fragment BaseQuery on queries {
  id
  dataset_id
  name
  description
  query
  version
  matview_id
  is_private
  is_temp
  is_archived
  created_at
  updated_at
  schedule
  tags
  parameters
}
    `;
export const QueryVisualizationsFragmentDoc = gql`
    fragment QueryVisualizations on queries {
  visualizations {
    id
    type
    name
    options
    created_at
  }
}
    `;
export const QueryForkedFragmentDoc = gql`
    fragment QueryForked on queries {
  forked_query {
    id
    name
    user {
      name
    }
    team {
      handle
    }
  }
}
    `;
export const QueryUsersFragmentDoc = gql`
    fragment QueryUsers on queries {
  user {
    ...User
  }
  team {
    id
    name
    handle
    profile_image_url
  }
}
    ${UserFragmentDoc}`;
export const QueryTeamsFragmentDoc = gql`
    fragment QueryTeams on queries {
  team {
    ...Team
  }
}
    ${TeamFragmentDoc}`;
export const QueryFavoritesFragmentDoc = gql`
    fragment QueryFavorites on queries {
  query_favorite_count_all @include(if: $favs_all_time) {
    favorite_count
  }
  query_favorite_count_last_24h @include(if: $favs_last_24h) {
    favorite_count
  }
  query_favorite_count_last_7d @include(if: $favs_last_7d) {
    favorite_count
  }
  query_favorite_count_last_30d @include(if: $favs_last_30d) {
    favorite_count
  }
}
    `;
export const QueryFragmentDoc = gql`
    fragment Query on queries {
  ...BaseQuery
  ...QueryVisualizations
  ...QueryForked
  ...QueryUsers
  ...QueryTeams
  ...QueryFavorites
}
    ${BaseQueryFragmentDoc}
${QueryVisualizationsFragmentDoc}
${QueryForkedFragmentDoc}
${QueryUsersFragmentDoc}
${QueryTeamsFragmentDoc}
${QueryFavoritesFragmentDoc}`;
export const ParametrizedQueryFragmentDoc = gql`
    fragment ParametrizedQuery on queries {
  ...BaseQuery
  ...QueryVisualizations @skip(if: $exclude_visualizations)
  ...QueryForked @skip(if: $exclude_forks)
  ...QueryUsers @skip(if: $exclude_users)
  ...QueryTeams @skip(if: $exclude_teams)
  ...QueryFavorites @skip(if: $exclude_favorites)
}
    ${BaseQueryFragmentDoc}
${QueryVisualizationsFragmentDoc}
${QueryForkedFragmentDoc}
${QueryUsersFragmentDoc}
${QueryTeamsFragmentDoc}
${QueryFavoritesFragmentDoc}`;
export const PopularDashboardTagFragmentDoc = gql`
    fragment PopularDashboardTag on popular_dashboard_tags {
  tag
  popularity
}
    `;
export const PopularQueryTagFragmentDoc = gql`
    fragment PopularQueryTag on popular_query_tags {
  tag
  popularity
}
    `;
export const SessionUserFragmentDoc = gql`
    fragment SessionUser on users {
  id
  name
  profile_image_url
  created_at
  private_info {
    stripeCustomerId: stripe_customer_id
    orbCustomerId: orb_customer_id
    serviceTierId: service_tier
    apiServiceTierId: api_service_tier_id
    permissions
    service_tier
    orbSubscriptionId: orb_subscription_id
    orbApiSubscriptionId: orb_api_subscription_id
    fromServiceTier: from_service_tier
    onboarding_qs_skipped_until
  }
  user_service_tier {
    id
    name
    max_private_queries
    max_private_dashboards
    csv_downloads_per_month
    included_query_executions
    included_nanocredits
    remove_watermark
    base_monthly_price_dollars_cents
    max_query_event_retention_days
    is_public
    performance
    release_version
  }
  api_user_service_tier {
    id
    name
    base_monthly_price_dollars_cents
    included_datapoints
    included_executions
    is_public
  }
}
    `;
export const ApplyDowngradeApiUserSubscriptionDocument = gql`
    mutation ApplyDowngradeApiUserSubscription($userId: Int!, $subscriptionId: String, $subscriptionStartDate: timestamptz, $serviceTierId: Int) {
  update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {orb_api_subscription_id: $subscriptionId, orb_api_subscription_start_date: $subscriptionStartDate, api_service_tier_id: $serviceTierId}
  ) {
    id
  }
  delete_pending_api_user_subscription_updates(where: {user_id: {_eq: $userId}}) {
    affected_rows
  }
}
    `;
export type ApplyDowngradeApiUserSubscriptionMutationFn = Apollo.MutationFunction<ApplyDowngradeApiUserSubscriptionMutation, ApplyDowngradeApiUserSubscriptionMutationVariables>;

/**
 * __useApplyDowngradeApiUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useApplyDowngradeApiUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyDowngradeApiUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyDowngradeApiUserSubscriptionMutation, { data, loading, error }] = useApplyDowngradeApiUserSubscriptionMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      subscriptionId: // value for 'subscriptionId'
 *      subscriptionStartDate: // value for 'subscriptionStartDate'
 *      serviceTierId: // value for 'serviceTierId'
 *   },
 * });
 */
export function useApplyDowngradeApiUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<ApplyDowngradeApiUserSubscriptionMutation, ApplyDowngradeApiUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<ApplyDowngradeApiUserSubscriptionMutation, ApplyDowngradeApiUserSubscriptionMutationVariables>(ApplyDowngradeApiUserSubscriptionDocument, baseOptions);
      }
export type ApplyDowngradeApiUserSubscriptionMutationHookResult = ReturnType<typeof useApplyDowngradeApiUserSubscriptionMutation>;
export type ApplyDowngradeApiUserSubscriptionMutationResult = Apollo.MutationResult<ApplyDowngradeApiUserSubscriptionMutation>;
export type ApplyDowngradeApiUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<ApplyDowngradeApiUserSubscriptionMutation, ApplyDowngradeApiUserSubscriptionMutationVariables>;
export const FinalizeUpgradeApiUserSubscriptionDocument = gql`
    mutation FinalizeUpgradeApiUserSubscription($userId: Int!) {
  delete_pending_api_user_subscription_updates(where: {user_id: {_eq: $userId}}) {
    affected_rows
  }
}
    `;
export type FinalizeUpgradeApiUserSubscriptionMutationFn = Apollo.MutationFunction<FinalizeUpgradeApiUserSubscriptionMutation, FinalizeUpgradeApiUserSubscriptionMutationVariables>;

/**
 * __useFinalizeUpgradeApiUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useFinalizeUpgradeApiUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFinalizeUpgradeApiUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [finalizeUpgradeApiUserSubscriptionMutation, { data, loading, error }] = useFinalizeUpgradeApiUserSubscriptionMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFinalizeUpgradeApiUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<FinalizeUpgradeApiUserSubscriptionMutation, FinalizeUpgradeApiUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<FinalizeUpgradeApiUserSubscriptionMutation, FinalizeUpgradeApiUserSubscriptionMutationVariables>(FinalizeUpgradeApiUserSubscriptionDocument, baseOptions);
      }
export type FinalizeUpgradeApiUserSubscriptionMutationHookResult = ReturnType<typeof useFinalizeUpgradeApiUserSubscriptionMutation>;
export type FinalizeUpgradeApiUserSubscriptionMutationResult = Apollo.MutationResult<FinalizeUpgradeApiUserSubscriptionMutation>;
export type FinalizeUpgradeApiUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<FinalizeUpgradeApiUserSubscriptionMutation, FinalizeUpgradeApiUserSubscriptionMutationVariables>;
export const UpdateTeamAfterUpgradeDocument = gql`
    mutation UpdateTeamAfterUpgrade($teamId: Int!) {
  delete_pending_team_subscription_updates(where: {team_id: {_eq: $teamId}}) {
    affected_rows
  }
}
    `;
export type UpdateTeamAfterUpgradeMutationFn = Apollo.MutationFunction<UpdateTeamAfterUpgradeMutation, UpdateTeamAfterUpgradeMutationVariables>;

/**
 * __useUpdateTeamAfterUpgradeMutation__
 *
 * To run a mutation, you first call `useUpdateTeamAfterUpgradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamAfterUpgradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamAfterUpgradeMutation, { data, loading, error }] = useUpdateTeamAfterUpgradeMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useUpdateTeamAfterUpgradeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTeamAfterUpgradeMutation, UpdateTeamAfterUpgradeMutationVariables>) {
        return Apollo.useMutation<UpdateTeamAfterUpgradeMutation, UpdateTeamAfterUpgradeMutationVariables>(UpdateTeamAfterUpgradeDocument, baseOptions);
      }
export type UpdateTeamAfterUpgradeMutationHookResult = ReturnType<typeof useUpdateTeamAfterUpgradeMutation>;
export type UpdateTeamAfterUpgradeMutationResult = Apollo.MutationResult<UpdateTeamAfterUpgradeMutation>;
export type UpdateTeamAfterUpgradeMutationOptions = Apollo.BaseMutationOptions<UpdateTeamAfterUpgradeMutation, UpdateTeamAfterUpgradeMutationVariables>;
export const ApplyTeamServiceTierUpdateDocument = gql`
    mutation ApplyTeamServiceTierUpdate($teamId: Int!, $serviceTierId: Int!, $orbSubscriptionId: String, $orbSubscriptionAnchorDay: Int, $executionQuotaExceededUntil: timestamptz, $csvDownloadQuotaExceededUntil: timestamptz, $maxOverageCents: numeric, $updateTeamMaxOverageCents: Boolean!) {
  update_teams_by_pk(
    pk_columns: {id: $teamId}
    _set: {execution_quota_exceeded_until: $executionQuotaExceededUntil, csv_download_quota_exceeded_until: $csvDownloadQuotaExceededUntil, service_tier_id: $serviceTierId, orb_subscription_id: $orbSubscriptionId, orb_subscription_anchor_day: $orbSubscriptionAnchorDay}
  ) {
    id
  }
  update_max_overage_cents: update_teams_by_pk(
    pk_columns: {id: $teamId}
    _set: {max_overage_cents: $maxOverageCents}
  ) @include(if: $updateTeamMaxOverageCents) {
    id
  }
  delete_pending_team_subscription_updates(where: {team_id: {_eq: $teamId}}) {
    affected_rows
  }
}
    `;
export type ApplyTeamServiceTierUpdateMutationFn = Apollo.MutationFunction<ApplyTeamServiceTierUpdateMutation, ApplyTeamServiceTierUpdateMutationVariables>;

/**
 * __useApplyTeamServiceTierUpdateMutation__
 *
 * To run a mutation, you first call `useApplyTeamServiceTierUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyTeamServiceTierUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyTeamServiceTierUpdateMutation, { data, loading, error }] = useApplyTeamServiceTierUpdateMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      serviceTierId: // value for 'serviceTierId'
 *      orbSubscriptionId: // value for 'orbSubscriptionId'
 *      orbSubscriptionAnchorDay: // value for 'orbSubscriptionAnchorDay'
 *      executionQuotaExceededUntil: // value for 'executionQuotaExceededUntil'
 *      csvDownloadQuotaExceededUntil: // value for 'csvDownloadQuotaExceededUntil'
 *      maxOverageCents: // value for 'maxOverageCents'
 *      updateTeamMaxOverageCents: // value for 'updateTeamMaxOverageCents'
 *   },
 * });
 */
export function useApplyTeamServiceTierUpdateMutation(baseOptions?: Apollo.MutationHookOptions<ApplyTeamServiceTierUpdateMutation, ApplyTeamServiceTierUpdateMutationVariables>) {
        return Apollo.useMutation<ApplyTeamServiceTierUpdateMutation, ApplyTeamServiceTierUpdateMutationVariables>(ApplyTeamServiceTierUpdateDocument, baseOptions);
      }
export type ApplyTeamServiceTierUpdateMutationHookResult = ReturnType<typeof useApplyTeamServiceTierUpdateMutation>;
export type ApplyTeamServiceTierUpdateMutationResult = Apollo.MutationResult<ApplyTeamServiceTierUpdateMutation>;
export type ApplyTeamServiceTierUpdateMutationOptions = Apollo.BaseMutationOptions<ApplyTeamServiceTierUpdateMutation, ApplyTeamServiceTierUpdateMutationVariables>;
export const UpdateTeamServiceTierDocument = gql`
    mutation UpdateTeamServiceTier($teamId: Int!, $serviceTierId: Int!, $orbSubscriptionId: String, $executionQuotaExceededUntil: timestamptz, $csvDownloadQuotaExceededUntil: timestamptz, $maxOverageCents: numeric, $updateTeamMaxOverageCents: Boolean!) {
  update_teams_by_pk(
    pk_columns: {id: $teamId}
    _set: {service_tier_id: $serviceTierId, orb_subscription_id: $orbSubscriptionId, execution_quota_exceeded_until: $executionQuotaExceededUntil, csv_download_quota_exceeded_until: $csvDownloadQuotaExceededUntil}
  ) {
    id
  }
  update_max_overage_cents: update_teams_by_pk(
    pk_columns: {id: $teamId}
    _set: {max_overage_cents: $maxOverageCents}
  ) @include(if: $updateTeamMaxOverageCents) {
    id
  }
}
    `;
export type UpdateTeamServiceTierMutationFn = Apollo.MutationFunction<UpdateTeamServiceTierMutation, UpdateTeamServiceTierMutationVariables>;

/**
 * __useUpdateTeamServiceTierMutation__
 *
 * To run a mutation, you first call `useUpdateTeamServiceTierMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamServiceTierMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamServiceTierMutation, { data, loading, error }] = useUpdateTeamServiceTierMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      serviceTierId: // value for 'serviceTierId'
 *      orbSubscriptionId: // value for 'orbSubscriptionId'
 *      executionQuotaExceededUntil: // value for 'executionQuotaExceededUntil'
 *      csvDownloadQuotaExceededUntil: // value for 'csvDownloadQuotaExceededUntil'
 *      maxOverageCents: // value for 'maxOverageCents'
 *      updateTeamMaxOverageCents: // value for 'updateTeamMaxOverageCents'
 *   },
 * });
 */
export function useUpdateTeamServiceTierMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTeamServiceTierMutation, UpdateTeamServiceTierMutationVariables>) {
        return Apollo.useMutation<UpdateTeamServiceTierMutation, UpdateTeamServiceTierMutationVariables>(UpdateTeamServiceTierDocument, baseOptions);
      }
export type UpdateTeamServiceTierMutationHookResult = ReturnType<typeof useUpdateTeamServiceTierMutation>;
export type UpdateTeamServiceTierMutationResult = Apollo.MutationResult<UpdateTeamServiceTierMutation>;
export type UpdateTeamServiceTierMutationOptions = Apollo.BaseMutationOptions<UpdateTeamServiceTierMutation, UpdateTeamServiceTierMutationVariables>;
export const ApplyUserServiceTierUpdateDocument = gql`
    mutation ApplyUserServiceTierUpdate($userId: Int!, $serviceTierId: Int!, $orbSubscriptionId: String, $orbSubscriptionAnchorDay: Int, $executionQuotaExceededUntil: timestamptz, $csvDownloadQuotaExceededUntil: timestamptz, $maxOverageCents: numeric, $updateUserMaxOverageCents: Boolean!) {
  update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {service_tier: $serviceTierId, orb_subscription_id: $orbSubscriptionId, orb_subscription_anchor_day: $orbSubscriptionAnchorDay, execution_quota_exceeded_until: $executionQuotaExceededUntil, csv_download_quota_exceeded_until: $csvDownloadQuotaExceededUntil}
  ) {
    id
  }
  update_max_overage_cents: update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {max_overage_cents: $maxOverageCents}
  ) @include(if: $updateUserMaxOverageCents) {
    id
  }
  delete_pending_user_subscription_updates(where: {user_id: {_eq: $userId}}) {
    affected_rows
  }
}
    `;
export type ApplyUserServiceTierUpdateMutationFn = Apollo.MutationFunction<ApplyUserServiceTierUpdateMutation, ApplyUserServiceTierUpdateMutationVariables>;

/**
 * __useApplyUserServiceTierUpdateMutation__
 *
 * To run a mutation, you first call `useApplyUserServiceTierUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyUserServiceTierUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyUserServiceTierUpdateMutation, { data, loading, error }] = useApplyUserServiceTierUpdateMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      serviceTierId: // value for 'serviceTierId'
 *      orbSubscriptionId: // value for 'orbSubscriptionId'
 *      orbSubscriptionAnchorDay: // value for 'orbSubscriptionAnchorDay'
 *      executionQuotaExceededUntil: // value for 'executionQuotaExceededUntil'
 *      csvDownloadQuotaExceededUntil: // value for 'csvDownloadQuotaExceededUntil'
 *      maxOverageCents: // value for 'maxOverageCents'
 *      updateUserMaxOverageCents: // value for 'updateUserMaxOverageCents'
 *   },
 * });
 */
export function useApplyUserServiceTierUpdateMutation(baseOptions?: Apollo.MutationHookOptions<ApplyUserServiceTierUpdateMutation, ApplyUserServiceTierUpdateMutationVariables>) {
        return Apollo.useMutation<ApplyUserServiceTierUpdateMutation, ApplyUserServiceTierUpdateMutationVariables>(ApplyUserServiceTierUpdateDocument, baseOptions);
      }
export type ApplyUserServiceTierUpdateMutationHookResult = ReturnType<typeof useApplyUserServiceTierUpdateMutation>;
export type ApplyUserServiceTierUpdateMutationResult = Apollo.MutationResult<ApplyUserServiceTierUpdateMutation>;
export type ApplyUserServiceTierUpdateMutationOptions = Apollo.BaseMutationOptions<ApplyUserServiceTierUpdateMutation, ApplyUserServiceTierUpdateMutationVariables>;
export const UpdateUserAfterUpgradeDocument = gql`
    mutation UpdateUserAfterUpgrade($userId: Int!) {
  delete_pending_user_subscription_updates(where: {user_id: {_eq: $userId}}) {
    affected_rows
  }
}
    `;
export type UpdateUserAfterUpgradeMutationFn = Apollo.MutationFunction<UpdateUserAfterUpgradeMutation, UpdateUserAfterUpgradeMutationVariables>;

/**
 * __useUpdateUserAfterUpgradeMutation__
 *
 * To run a mutation, you first call `useUpdateUserAfterUpgradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserAfterUpgradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserAfterUpgradeMutation, { data, loading, error }] = useUpdateUserAfterUpgradeMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUpdateUserAfterUpgradeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserAfterUpgradeMutation, UpdateUserAfterUpgradeMutationVariables>) {
        return Apollo.useMutation<UpdateUserAfterUpgradeMutation, UpdateUserAfterUpgradeMutationVariables>(UpdateUserAfterUpgradeDocument, baseOptions);
      }
export type UpdateUserAfterUpgradeMutationHookResult = ReturnType<typeof useUpdateUserAfterUpgradeMutation>;
export type UpdateUserAfterUpgradeMutationResult = Apollo.MutationResult<UpdateUserAfterUpgradeMutation>;
export type UpdateUserAfterUpgradeMutationOptions = Apollo.BaseMutationOptions<UpdateUserAfterUpgradeMutation, UpdateUserAfterUpgradeMutationVariables>;
export const UpdateUserServiceTierDocument = gql`
    mutation UpdateUserServiceTier($userId: Int!, $serviceTierId: Int!, $orbSubscriptionId: String, $executionQuotaExceededUntil: timestamptz, $csvDownloadQuotaExceededUntil: timestamptz, $maxOverageCents: numeric, $updateUserMaxOverageCents: Boolean!) {
  update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {service_tier: $serviceTierId, orb_subscription_id: $orbSubscriptionId, execution_quota_exceeded_until: $executionQuotaExceededUntil, csv_download_quota_exceeded_until: $csvDownloadQuotaExceededUntil}
  ) {
    id
  }
  update_max_overage_cents: update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {max_overage_cents: $maxOverageCents}
  ) @include(if: $updateUserMaxOverageCents) {
    id
  }
}
    `;
export type UpdateUserServiceTierMutationFn = Apollo.MutationFunction<UpdateUserServiceTierMutation, UpdateUserServiceTierMutationVariables>;

/**
 * __useUpdateUserServiceTierMutation__
 *
 * To run a mutation, you first call `useUpdateUserServiceTierMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserServiceTierMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserServiceTierMutation, { data, loading, error }] = useUpdateUserServiceTierMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      serviceTierId: // value for 'serviceTierId'
 *      orbSubscriptionId: // value for 'orbSubscriptionId'
 *      executionQuotaExceededUntil: // value for 'executionQuotaExceededUntil'
 *      csvDownloadQuotaExceededUntil: // value for 'csvDownloadQuotaExceededUntil'
 *      maxOverageCents: // value for 'maxOverageCents'
 *      updateUserMaxOverageCents: // value for 'updateUserMaxOverageCents'
 *   },
 * });
 */
export function useUpdateUserServiceTierMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserServiceTierMutation, UpdateUserServiceTierMutationVariables>) {
        return Apollo.useMutation<UpdateUserServiceTierMutation, UpdateUserServiceTierMutationVariables>(UpdateUserServiceTierDocument, baseOptions);
      }
export type UpdateUserServiceTierMutationHookResult = ReturnType<typeof useUpdateUserServiceTierMutation>;
export type UpdateUserServiceTierMutationResult = Apollo.MutationResult<UpdateUserServiceTierMutation>;
export type UpdateUserServiceTierMutationOptions = Apollo.BaseMutationOptions<UpdateUserServiceTierMutation, UpdateUserServiceTierMutationVariables>;
export const GetPendingApiUserSubUpdatesDocument = gql`
    query GetPendingApiUserSubUpdates($userId: Int!) {
  pending_api_user_subscription_updates(where: {user_id: {_eq: $userId}}) {
    user_id
    update_type
    soft_deadline
    update_date
    base_plan_id
    orb_subscription_id
    orb_subscription_start_date
    api_user_service_tier {
      id
      name
    }
  }
}
    `;

/**
 * __useGetPendingApiUserSubUpdatesQuery__
 *
 * To run a query within a React component, call `useGetPendingApiUserSubUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPendingApiUserSubUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPendingApiUserSubUpdatesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetPendingApiUserSubUpdatesQuery(baseOptions: Apollo.QueryHookOptions<GetPendingApiUserSubUpdatesQuery, GetPendingApiUserSubUpdatesQueryVariables>) {
        return Apollo.useQuery<GetPendingApiUserSubUpdatesQuery, GetPendingApiUserSubUpdatesQueryVariables>(GetPendingApiUserSubUpdatesDocument, baseOptions);
      }
export function useGetPendingApiUserSubUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPendingApiUserSubUpdatesQuery, GetPendingApiUserSubUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<GetPendingApiUserSubUpdatesQuery, GetPendingApiUserSubUpdatesQueryVariables>(GetPendingApiUserSubUpdatesDocument, baseOptions);
        }
export type GetPendingApiUserSubUpdatesQueryHookResult = ReturnType<typeof useGetPendingApiUserSubUpdatesQuery>;
export type GetPendingApiUserSubUpdatesLazyQueryHookResult = ReturnType<typeof useGetPendingApiUserSubUpdatesLazyQuery>;
export type GetPendingApiUserSubUpdatesQueryResult = Apollo.QueryResult<GetPendingApiUserSubUpdatesQuery, GetPendingApiUserSubUpdatesQueryVariables>;
export const GetPendingTeamSubUpdatesDocument = gql`
    query GetPendingTeamSubUpdates($teamId: Int!) {
  pending_team_subscription_updates(where: {team_id: {_eq: $teamId}}) {
    base_plan_id
    update_date
    orb_subscription_id
    orb_subscription_anchor_day
    soft_deadline
    update_type
    team_id
    metadata
    service_tier {
      id
      name
    }
  }
}
    `;

/**
 * __useGetPendingTeamSubUpdatesQuery__
 *
 * To run a query within a React component, call `useGetPendingTeamSubUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPendingTeamSubUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPendingTeamSubUpdatesQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetPendingTeamSubUpdatesQuery(baseOptions: Apollo.QueryHookOptions<GetPendingTeamSubUpdatesQuery, GetPendingTeamSubUpdatesQueryVariables>) {
        return Apollo.useQuery<GetPendingTeamSubUpdatesQuery, GetPendingTeamSubUpdatesQueryVariables>(GetPendingTeamSubUpdatesDocument, baseOptions);
      }
export function useGetPendingTeamSubUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPendingTeamSubUpdatesQuery, GetPendingTeamSubUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<GetPendingTeamSubUpdatesQuery, GetPendingTeamSubUpdatesQueryVariables>(GetPendingTeamSubUpdatesDocument, baseOptions);
        }
export type GetPendingTeamSubUpdatesQueryHookResult = ReturnType<typeof useGetPendingTeamSubUpdatesQuery>;
export type GetPendingTeamSubUpdatesLazyQueryHookResult = ReturnType<typeof useGetPendingTeamSubUpdatesLazyQuery>;
export type GetPendingTeamSubUpdatesQueryResult = Apollo.QueryResult<GetPendingTeamSubUpdatesQuery, GetPendingTeamSubUpdatesQueryVariables>;
export const GetPendingUserSubUpdatesDocument = gql`
    query GetPendingUserSubUpdates($userId: Int!) {
  pending_user_subscription_updates(where: {user_id: {_eq: $userId}}) {
    base_plan_id
    update_date
    orb_subscription_id
    orb_subscription_anchor_day
    soft_deadline
    update_type
    user_id
    metadata
    service_tier: user_service_tier {
      id
      name
      release_version
    }
  }
}
    `;

/**
 * __useGetPendingUserSubUpdatesQuery__
 *
 * To run a query within a React component, call `useGetPendingUserSubUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPendingUserSubUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPendingUserSubUpdatesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetPendingUserSubUpdatesQuery(baseOptions: Apollo.QueryHookOptions<GetPendingUserSubUpdatesQuery, GetPendingUserSubUpdatesQueryVariables>) {
        return Apollo.useQuery<GetPendingUserSubUpdatesQuery, GetPendingUserSubUpdatesQueryVariables>(GetPendingUserSubUpdatesDocument, baseOptions);
      }
export function useGetPendingUserSubUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPendingUserSubUpdatesQuery, GetPendingUserSubUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<GetPendingUserSubUpdatesQuery, GetPendingUserSubUpdatesQueryVariables>(GetPendingUserSubUpdatesDocument, baseOptions);
        }
export type GetPendingUserSubUpdatesQueryHookResult = ReturnType<typeof useGetPendingUserSubUpdatesQuery>;
export type GetPendingUserSubUpdatesLazyQueryHookResult = ReturnType<typeof useGetPendingUserSubUpdatesLazyQuery>;
export type GetPendingUserSubUpdatesQueryResult = Apollo.QueryResult<GetPendingUserSubUpdatesQuery, GetPendingUserSubUpdatesQueryVariables>;
export const UpdatePendingTeamSubUpdatesDocument = gql`
    mutation UpdatePendingTeamSubUpdates($teamId: Int!, $serviceTierId: Int!) {
  update_pending_team_subscription_updates_by_pk(
    pk_columns: {team_id: $teamId}
    _set: {service_tier_id: $serviceTierId}
  ) {
    team_id
  }
}
    `;
export type UpdatePendingTeamSubUpdatesMutationFn = Apollo.MutationFunction<UpdatePendingTeamSubUpdatesMutation, UpdatePendingTeamSubUpdatesMutationVariables>;

/**
 * __useUpdatePendingTeamSubUpdatesMutation__
 *
 * To run a mutation, you first call `useUpdatePendingTeamSubUpdatesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePendingTeamSubUpdatesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePendingTeamSubUpdatesMutation, { data, loading, error }] = useUpdatePendingTeamSubUpdatesMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      serviceTierId: // value for 'serviceTierId'
 *   },
 * });
 */
export function useUpdatePendingTeamSubUpdatesMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePendingTeamSubUpdatesMutation, UpdatePendingTeamSubUpdatesMutationVariables>) {
        return Apollo.useMutation<UpdatePendingTeamSubUpdatesMutation, UpdatePendingTeamSubUpdatesMutationVariables>(UpdatePendingTeamSubUpdatesDocument, baseOptions);
      }
export type UpdatePendingTeamSubUpdatesMutationHookResult = ReturnType<typeof useUpdatePendingTeamSubUpdatesMutation>;
export type UpdatePendingTeamSubUpdatesMutationResult = Apollo.MutationResult<UpdatePendingTeamSubUpdatesMutation>;
export type UpdatePendingTeamSubUpdatesMutationOptions = Apollo.BaseMutationOptions<UpdatePendingTeamSubUpdatesMutation, UpdatePendingTeamSubUpdatesMutationVariables>;
export const UpdatePendingUserSubUpdatesDocument = gql`
    mutation UpdatePendingUserSubUpdates($userId: Int!, $serviceTierId: Int!) {
  update_pending_user_subscription_updates_by_pk(
    pk_columns: {user_id: $userId}
    _set: {service_tier: $serviceTierId}
  ) {
    user_id
  }
}
    `;
export type UpdatePendingUserSubUpdatesMutationFn = Apollo.MutationFunction<UpdatePendingUserSubUpdatesMutation, UpdatePendingUserSubUpdatesMutationVariables>;

/**
 * __useUpdatePendingUserSubUpdatesMutation__
 *
 * To run a mutation, you first call `useUpdatePendingUserSubUpdatesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePendingUserSubUpdatesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePendingUserSubUpdatesMutation, { data, loading, error }] = useUpdatePendingUserSubUpdatesMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      serviceTierId: // value for 'serviceTierId'
 *   },
 * });
 */
export function useUpdatePendingUserSubUpdatesMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePendingUserSubUpdatesMutation, UpdatePendingUserSubUpdatesMutationVariables>) {
        return Apollo.useMutation<UpdatePendingUserSubUpdatesMutation, UpdatePendingUserSubUpdatesMutationVariables>(UpdatePendingUserSubUpdatesDocument, baseOptions);
      }
export type UpdatePendingUserSubUpdatesMutationHookResult = ReturnType<typeof useUpdatePendingUserSubUpdatesMutation>;
export type UpdatePendingUserSubUpdatesMutationResult = Apollo.MutationResult<UpdatePendingUserSubUpdatesMutation>;
export type UpdatePendingUserSubUpdatesMutationOptions = Apollo.BaseMutationOptions<UpdatePendingUserSubUpdatesMutation, UpdatePendingUserSubUpdatesMutationVariables>;
export const TeamByOrbCustomerIdDocument = gql`
    query TeamByOrbCustomerId($orbCustomerId: String!) {
  teams(where: {orb_customer_id: {_eq: $orbCustomerId}}) {
    id
    name
    handle
    orb_subscription_id
    service_tier_id
    service_tier {
      id
      name
    }
  }
}
    `;

/**
 * __useTeamByOrbCustomerIdQuery__
 *
 * To run a query within a React component, call `useTeamByOrbCustomerIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useTeamByOrbCustomerIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTeamByOrbCustomerIdQuery({
 *   variables: {
 *      orbCustomerId: // value for 'orbCustomerId'
 *   },
 * });
 */
export function useTeamByOrbCustomerIdQuery(baseOptions: Apollo.QueryHookOptions<TeamByOrbCustomerIdQuery, TeamByOrbCustomerIdQueryVariables>) {
        return Apollo.useQuery<TeamByOrbCustomerIdQuery, TeamByOrbCustomerIdQueryVariables>(TeamByOrbCustomerIdDocument, baseOptions);
      }
export function useTeamByOrbCustomerIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TeamByOrbCustomerIdQuery, TeamByOrbCustomerIdQueryVariables>) {
          return Apollo.useLazyQuery<TeamByOrbCustomerIdQuery, TeamByOrbCustomerIdQueryVariables>(TeamByOrbCustomerIdDocument, baseOptions);
        }
export type TeamByOrbCustomerIdQueryHookResult = ReturnType<typeof useTeamByOrbCustomerIdQuery>;
export type TeamByOrbCustomerIdLazyQueryHookResult = ReturnType<typeof useTeamByOrbCustomerIdLazyQuery>;
export type TeamByOrbCustomerIdQueryResult = Apollo.QueryResult<TeamByOrbCustomerIdQuery, TeamByOrbCustomerIdQueryVariables>;
export const UpdateTeamAccountForServiceTierDocument = gql`
    mutation UpdateTeamAccountForServiceTier($teamId: Int!) {
  update_team_account_for_service_tier(team_id: $teamId) {
    __typename
  }
}
    `;
export type UpdateTeamAccountForServiceTierMutationFn = Apollo.MutationFunction<UpdateTeamAccountForServiceTierMutation, UpdateTeamAccountForServiceTierMutationVariables>;

/**
 * __useUpdateTeamAccountForServiceTierMutation__
 *
 * To run a mutation, you first call `useUpdateTeamAccountForServiceTierMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamAccountForServiceTierMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamAccountForServiceTierMutation, { data, loading, error }] = useUpdateTeamAccountForServiceTierMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useUpdateTeamAccountForServiceTierMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTeamAccountForServiceTierMutation, UpdateTeamAccountForServiceTierMutationVariables>) {
        return Apollo.useMutation<UpdateTeamAccountForServiceTierMutation, UpdateTeamAccountForServiceTierMutationVariables>(UpdateTeamAccountForServiceTierDocument, baseOptions);
      }
export type UpdateTeamAccountForServiceTierMutationHookResult = ReturnType<typeof useUpdateTeamAccountForServiceTierMutation>;
export type UpdateTeamAccountForServiceTierMutationResult = Apollo.MutationResult<UpdateTeamAccountForServiceTierMutation>;
export type UpdateTeamAccountForServiceTierMutationOptions = Apollo.BaseMutationOptions<UpdateTeamAccountForServiceTierMutation, UpdateTeamAccountForServiceTierMutationVariables>;
export const UpdateUserAccountForServiceTierDocument = gql`
    mutation UpdateUserAccountForServiceTier($userId: Int!, $serviceTierId: Int!) {
  update_account_for_service_tier(
    user_id: $userId
    service_tier_id: $serviceTierId
  ) {
    archived_dashboards_count
    archived_queries_count
  }
}
    `;
export type UpdateUserAccountForServiceTierMutationFn = Apollo.MutationFunction<UpdateUserAccountForServiceTierMutation, UpdateUserAccountForServiceTierMutationVariables>;

/**
 * __useUpdateUserAccountForServiceTierMutation__
 *
 * To run a mutation, you first call `useUpdateUserAccountForServiceTierMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserAccountForServiceTierMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserAccountForServiceTierMutation, { data, loading, error }] = useUpdateUserAccountForServiceTierMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      serviceTierId: // value for 'serviceTierId'
 *   },
 * });
 */
export function useUpdateUserAccountForServiceTierMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserAccountForServiceTierMutation, UpdateUserAccountForServiceTierMutationVariables>) {
        return Apollo.useMutation<UpdateUserAccountForServiceTierMutation, UpdateUserAccountForServiceTierMutationVariables>(UpdateUserAccountForServiceTierDocument, baseOptions);
      }
export type UpdateUserAccountForServiceTierMutationHookResult = ReturnType<typeof useUpdateUserAccountForServiceTierMutation>;
export type UpdateUserAccountForServiceTierMutationResult = Apollo.MutationResult<UpdateUserAccountForServiceTierMutation>;
export type UpdateUserAccountForServiceTierMutationOptions = Apollo.BaseMutationOptions<UpdateUserAccountForServiceTierMutation, UpdateUserAccountForServiceTierMutationVariables>;
export const ProjectNamesDocument = gql`
    query ProjectNames($blockchain: blockchain_name!) {
  contract_submissions(
    where: {blockchain: {_eq: $blockchain}, status: {_nin: ["rejected", "cancelled"]}}
    distinct_on: project_name
  ) {
    project_name
  }
}
    `;

/**
 * __useProjectNamesQuery__
 *
 * To run a query within a React component, call `useProjectNamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectNamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectNamesQuery({
 *   variables: {
 *      blockchain: // value for 'blockchain'
 *   },
 * });
 */
export function useProjectNamesQuery(baseOptions: Apollo.QueryHookOptions<ProjectNamesQuery, ProjectNamesQueryVariables>) {
        return Apollo.useQuery<ProjectNamesQuery, ProjectNamesQueryVariables>(ProjectNamesDocument, baseOptions);
      }
export function useProjectNamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectNamesQuery, ProjectNamesQueryVariables>) {
          return Apollo.useLazyQuery<ProjectNamesQuery, ProjectNamesQueryVariables>(ProjectNamesDocument, baseOptions);
        }
export type ProjectNamesQueryHookResult = ReturnType<typeof useProjectNamesQuery>;
export type ProjectNamesLazyQueryHookResult = ReturnType<typeof useProjectNamesLazyQuery>;
export type ProjectNamesQueryResult = Apollo.QueryResult<ProjectNamesQuery, ProjectNamesQueryVariables>;
export const GetExistingContractSubmissionDocument = gql`
    query GetExistingContractSubmission($address: String!, $blockchain: blockchain_name!) {
  contract_submissions(
    where: {address: {_ilike: $address}, blockchain: {_eq: $blockchain}, status: {_nin: ["rejected", "cancelled"]}}
    order_by: {created_at: asc}
    limit: 1
  ) {
    id
    contract_name
    project_name
    status
  }
}
    `;

/**
 * __useGetExistingContractSubmissionQuery__
 *
 * To run a query within a React component, call `useGetExistingContractSubmissionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExistingContractSubmissionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExistingContractSubmissionQuery({
 *   variables: {
 *      address: // value for 'address'
 *      blockchain: // value for 'blockchain'
 *   },
 * });
 */
export function useGetExistingContractSubmissionQuery(baseOptions: Apollo.QueryHookOptions<GetExistingContractSubmissionQuery, GetExistingContractSubmissionQueryVariables>) {
        return Apollo.useQuery<GetExistingContractSubmissionQuery, GetExistingContractSubmissionQueryVariables>(GetExistingContractSubmissionDocument, baseOptions);
      }
export function useGetExistingContractSubmissionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExistingContractSubmissionQuery, GetExistingContractSubmissionQueryVariables>) {
          return Apollo.useLazyQuery<GetExistingContractSubmissionQuery, GetExistingContractSubmissionQueryVariables>(GetExistingContractSubmissionDocument, baseOptions);
        }
export type GetExistingContractSubmissionQueryHookResult = ReturnType<typeof useGetExistingContractSubmissionQuery>;
export type GetExistingContractSubmissionLazyQueryHookResult = ReturnType<typeof useGetExistingContractSubmissionLazyQuery>;
export type GetExistingContractSubmissionQueryResult = Apollo.QueryResult<GetExistingContractSubmissionQuery, GetExistingContractSubmissionQueryVariables>;
export const SubmitContractDocument = gql`
    mutation SubmitContract($blockchain: blockchain_name!, $address: String!, $project_name: String!, $contract_name: String!, $abi: jsonb!, $has_multiple_instances: Boolean!, $is_created_by_factory: Boolean!, $is_manual_abi: Boolean!, $is_proxy: Boolean!, $cognito_user_id: uuid!, $resubmission_reason: String) {
  insert_contract_submissions(
    objects: {blockchain: $blockchain, address: $address, project_name: $project_name, contract_name: $contract_name, abi: $abi, has_multiple_instances: $has_multiple_instances, is_created_by_factory: $is_created_by_factory, is_manual_abi: $is_manual_abi, is_proxy: $is_proxy, cognito_user_id: $cognito_user_id, resubmission_reason: $resubmission_reason}
  ) {
    affected_rows
  }
}
    `;
export type SubmitContractMutationFn = Apollo.MutationFunction<SubmitContractMutation, SubmitContractMutationVariables>;

/**
 * __useSubmitContractMutation__
 *
 * To run a mutation, you first call `useSubmitContractMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitContractMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitContractMutation, { data, loading, error }] = useSubmitContractMutation({
 *   variables: {
 *      blockchain: // value for 'blockchain'
 *      address: // value for 'address'
 *      project_name: // value for 'project_name'
 *      contract_name: // value for 'contract_name'
 *      abi: // value for 'abi'
 *      has_multiple_instances: // value for 'has_multiple_instances'
 *      is_created_by_factory: // value for 'is_created_by_factory'
 *      is_manual_abi: // value for 'is_manual_abi'
 *      is_proxy: // value for 'is_proxy'
 *      cognito_user_id: // value for 'cognito_user_id'
 *      resubmission_reason: // value for 'resubmission_reason'
 *   },
 * });
 */
export function useSubmitContractMutation(baseOptions?: Apollo.MutationHookOptions<SubmitContractMutation, SubmitContractMutationVariables>) {
        return Apollo.useMutation<SubmitContractMutation, SubmitContractMutationVariables>(SubmitContractDocument, baseOptions);
      }
export type SubmitContractMutationHookResult = ReturnType<typeof useSubmitContractMutation>;
export type SubmitContractMutationResult = Apollo.MutationResult<SubmitContractMutation>;
export type SubmitContractMutationOptions = Apollo.BaseMutationOptions<SubmitContractMutation, SubmitContractMutationVariables>;
export const RefetchDashboardFavoritesDocument = gql`
    query RefetchDashboardFavorites($id: Int!, $session_id: Int!) {
  dashboards_by_pk(id: $id) {
    id
    favorite_dashboards(where: {user_id: {_eq: $session_id}}, limit: 1) {
      created_at
    }
    dashboard_favorite_count_all {
      favorite_count
    }
    dashboard_favorite_count_last_24h {
      favorite_count
    }
    dashboard_favorite_count_last_7d {
      favorite_count
    }
    dashboard_favorite_count_last_30d {
      favorite_count
    }
  }
}
    `;

/**
 * __useRefetchDashboardFavoritesQuery__
 *
 * To run a query within a React component, call `useRefetchDashboardFavoritesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRefetchDashboardFavoritesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRefetchDashboardFavoritesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      session_id: // value for 'session_id'
 *   },
 * });
 */
export function useRefetchDashboardFavoritesQuery(baseOptions: Apollo.QueryHookOptions<RefetchDashboardFavoritesQuery, RefetchDashboardFavoritesQueryVariables>) {
        return Apollo.useQuery<RefetchDashboardFavoritesQuery, RefetchDashboardFavoritesQueryVariables>(RefetchDashboardFavoritesDocument, baseOptions);
      }
export function useRefetchDashboardFavoritesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RefetchDashboardFavoritesQuery, RefetchDashboardFavoritesQueryVariables>) {
          return Apollo.useLazyQuery<RefetchDashboardFavoritesQuery, RefetchDashboardFavoritesQueryVariables>(RefetchDashboardFavoritesDocument, baseOptions);
        }
export type RefetchDashboardFavoritesQueryHookResult = ReturnType<typeof useRefetchDashboardFavoritesQuery>;
export type RefetchDashboardFavoritesLazyQueryHookResult = ReturnType<typeof useRefetchDashboardFavoritesLazyQuery>;
export type RefetchDashboardFavoritesQueryResult = Apollo.QueryResult<RefetchDashboardFavoritesQuery, RefetchDashboardFavoritesQueryVariables>;
export const ListBrowseDashboardsDocument = gql`
    query ListBrowseDashboards($filter_name: String_comparison_exp, $filter_tags: jsonb_comparison_exp, $filter_custom: [dashboards_bool_exp!], $order: [dashboards_order_by!], $limit: Int!, $offset: Int!, $include_favs_last_24h: Boolean! = false, $include_favs_last_7d: Boolean! = false, $include_favs_last_30d: Boolean! = false, $include_favs_all_time: Boolean! = false) {
  dashboards(
    where: {is_archived: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...DashboardItem
  }
  dashboards_aggregate(
    where: {is_archived: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${DashboardItemFragmentDoc}`;

/**
 * __useListBrowseDashboardsQuery__
 *
 * To run a query within a React component, call `useListBrowseDashboardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListBrowseDashboardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListBrowseDashboardsQuery({
 *   variables: {
 *      filter_name: // value for 'filter_name'
 *      filter_tags: // value for 'filter_tags'
 *      filter_custom: // value for 'filter_custom'
 *      order: // value for 'order'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      include_favs_last_24h: // value for 'include_favs_last_24h'
 *      include_favs_last_7d: // value for 'include_favs_last_7d'
 *      include_favs_last_30d: // value for 'include_favs_last_30d'
 *      include_favs_all_time: // value for 'include_favs_all_time'
 *   },
 * });
 */
export function useListBrowseDashboardsQuery(baseOptions: Apollo.QueryHookOptions<ListBrowseDashboardsQuery, ListBrowseDashboardsQueryVariables>) {
        return Apollo.useQuery<ListBrowseDashboardsQuery, ListBrowseDashboardsQueryVariables>(ListBrowseDashboardsDocument, baseOptions);
      }
export function useListBrowseDashboardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListBrowseDashboardsQuery, ListBrowseDashboardsQueryVariables>) {
          return Apollo.useLazyQuery<ListBrowseDashboardsQuery, ListBrowseDashboardsQueryVariables>(ListBrowseDashboardsDocument, baseOptions);
        }
export type ListBrowseDashboardsQueryHookResult = ReturnType<typeof useListBrowseDashboardsQuery>;
export type ListBrowseDashboardsLazyQueryHookResult = ReturnType<typeof useListBrowseDashboardsLazyQuery>;
export type ListBrowseDashboardsQueryResult = Apollo.QueryResult<ListBrowseDashboardsQuery, ListBrowseDashboardsQueryVariables>;
export const DashboardsFavoritesDocument = gql`
    query DashboardsFavorites($dashboard_ids: [Int!]!, $session_id: Int) {
  dashboards(where: {id: {_in: $dashboard_ids}}, limit: 20) {
    id
    favorite_dashboards(where: {user_id: {_eq: $session_id}}, limit: 1) {
      created_at
    }
  }
}
    `;

/**
 * __useDashboardsFavoritesQuery__
 *
 * To run a query within a React component, call `useDashboardsFavoritesQuery` and pass it any options that fit your needs.
 * When your component renders, `useDashboardsFavoritesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDashboardsFavoritesQuery({
 *   variables: {
 *      dashboard_ids: // value for 'dashboard_ids'
 *      session_id: // value for 'session_id'
 *   },
 * });
 */
export function useDashboardsFavoritesQuery(baseOptions: Apollo.QueryHookOptions<DashboardsFavoritesQuery, DashboardsFavoritesQueryVariables>) {
        return Apollo.useQuery<DashboardsFavoritesQuery, DashboardsFavoritesQueryVariables>(DashboardsFavoritesDocument, baseOptions);
      }
export function useDashboardsFavoritesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DashboardsFavoritesQuery, DashboardsFavoritesQueryVariables>) {
          return Apollo.useLazyQuery<DashboardsFavoritesQuery, DashboardsFavoritesQueryVariables>(DashboardsFavoritesDocument, baseOptions);
        }
export type DashboardsFavoritesQueryHookResult = ReturnType<typeof useDashboardsFavoritesQuery>;
export type DashboardsFavoritesLazyQueryHookResult = ReturnType<typeof useDashboardsFavoritesLazyQuery>;
export type DashboardsFavoritesQueryResult = Apollo.QueryResult<DashboardsFavoritesQuery, DashboardsFavoritesQueryVariables>;
export const RefetchFavoritesDocument = gql`
    query RefetchFavorites($id: Int!, $session_id: Int!) {
  queries_by_pk(id: $id) {
    id
    favorite_queries(where: {user_id: {_eq: $session_id}}, limit: 1) {
      created_at
    }
    query_favorite_count_all {
      favorite_count
    }
    query_favorite_count_last_24h {
      favorite_count
    }
    query_favorite_count_last_7d {
      favorite_count
    }
    query_favorite_count_last_30d {
      favorite_count
    }
  }
}
    `;

/**
 * __useRefetchFavoritesQuery__
 *
 * To run a query within a React component, call `useRefetchFavoritesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRefetchFavoritesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRefetchFavoritesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      session_id: // value for 'session_id'
 *   },
 * });
 */
export function useRefetchFavoritesQuery(baseOptions: Apollo.QueryHookOptions<RefetchFavoritesQuery, RefetchFavoritesQueryVariables>) {
        return Apollo.useQuery<RefetchFavoritesQuery, RefetchFavoritesQueryVariables>(RefetchFavoritesDocument, baseOptions);
      }
export function useRefetchFavoritesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RefetchFavoritesQuery, RefetchFavoritesQueryVariables>) {
          return Apollo.useLazyQuery<RefetchFavoritesQuery, RefetchFavoritesQueryVariables>(RefetchFavoritesDocument, baseOptions);
        }
export type RefetchFavoritesQueryHookResult = ReturnType<typeof useRefetchFavoritesQuery>;
export type RefetchFavoritesLazyQueryHookResult = ReturnType<typeof useRefetchFavoritesLazyQuery>;
export type RefetchFavoritesQueryResult = Apollo.QueryResult<RefetchFavoritesQuery, RefetchFavoritesQueryVariables>;
export const ListBrowseQueriesDocument = gql`
    query ListBrowseQueries($filter_name: String_comparison_exp!, $filter_tags: jsonb_comparison_exp, $filter_custom: [queries_bool_exp!], $order: [queries_order_by!], $limit: Int!, $offset: Int!, $include_favs_last_24h: Boolean! = false, $include_favs_last_7d: Boolean! = false, $include_favs_last_30d: Boolean! = false, $include_favs_all_time: Boolean! = false) {
  queries(
    where: {is_temp: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...QueryItem
  }
  queries_aggregate(
    where: {is_temp: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${QueryItemFragmentDoc}`;

/**
 * __useListBrowseQueriesQuery__
 *
 * To run a query within a React component, call `useListBrowseQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListBrowseQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListBrowseQueriesQuery({
 *   variables: {
 *      filter_name: // value for 'filter_name'
 *      filter_tags: // value for 'filter_tags'
 *      filter_custom: // value for 'filter_custom'
 *      order: // value for 'order'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      include_favs_last_24h: // value for 'include_favs_last_24h'
 *      include_favs_last_7d: // value for 'include_favs_last_7d'
 *      include_favs_last_30d: // value for 'include_favs_last_30d'
 *      include_favs_all_time: // value for 'include_favs_all_time'
 *   },
 * });
 */
export function useListBrowseQueriesQuery(baseOptions: Apollo.QueryHookOptions<ListBrowseQueriesQuery, ListBrowseQueriesQueryVariables>) {
        return Apollo.useQuery<ListBrowseQueriesQuery, ListBrowseQueriesQueryVariables>(ListBrowseQueriesDocument, baseOptions);
      }
export function useListBrowseQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListBrowseQueriesQuery, ListBrowseQueriesQueryVariables>) {
          return Apollo.useLazyQuery<ListBrowseQueriesQuery, ListBrowseQueriesQueryVariables>(ListBrowseQueriesDocument, baseOptions);
        }
export type ListBrowseQueriesQueryHookResult = ReturnType<typeof useListBrowseQueriesQuery>;
export type ListBrowseQueriesLazyQueryHookResult = ReturnType<typeof useListBrowseQueriesLazyQuery>;
export type ListBrowseQueriesQueryResult = Apollo.QueryResult<ListBrowseQueriesQuery, ListBrowseQueriesQueryVariables>;
export const QueriesFavoritesDocument = gql`
    query QueriesFavorites($query_ids: [Int!]!, $session_id: Int) {
  queries(where: {id: {_in: $query_ids}}, limit: 20) {
    id
    favorite_queries(where: {user_id: {_eq: $session_id}}, limit: 1) {
      created_at
    }
  }
}
    `;

/**
 * __useQueriesFavoritesQuery__
 *
 * To run a query within a React component, call `useQueriesFavoritesQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueriesFavoritesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueriesFavoritesQuery({
 *   variables: {
 *      query_ids: // value for 'query_ids'
 *      session_id: // value for 'session_id'
 *   },
 * });
 */
export function useQueriesFavoritesQuery(baseOptions: Apollo.QueryHookOptions<QueriesFavoritesQuery, QueriesFavoritesQueryVariables>) {
        return Apollo.useQuery<QueriesFavoritesQuery, QueriesFavoritesQueryVariables>(QueriesFavoritesDocument, baseOptions);
      }
export function useQueriesFavoritesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QueriesFavoritesQuery, QueriesFavoritesQueryVariables>) {
          return Apollo.useLazyQuery<QueriesFavoritesQuery, QueriesFavoritesQueryVariables>(QueriesFavoritesDocument, baseOptions);
        }
export type QueriesFavoritesQueryHookResult = ReturnType<typeof useQueriesFavoritesQuery>;
export type QueriesFavoritesLazyQueryHookResult = ReturnType<typeof useQueriesFavoritesLazyQuery>;
export type QueriesFavoritesQueryResult = Apollo.QueryResult<QueriesFavoritesQuery, QueriesFavoritesQueryVariables>;
export const ListDiscoverTeamsDocument = gql`
    query ListDiscoverTeams($filter_name: String_comparison_exp!, $limit: Int!, $offset: Int!) {
  teams(
    where: {name: $filter_name}
    order_by: [{received_stars: {sum: desc_nulls_last}}, {id: asc}]
    limit: $limit
    offset: $offset
  ) {
    ...TeamItem
  }
  teams_aggregate(where: {name: $filter_name}) {
    aggregate {
      count
    }
  }
}
    ${TeamItemFragmentDoc}`;

/**
 * __useListDiscoverTeamsQuery__
 *
 * To run a query within a React component, call `useListDiscoverTeamsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListDiscoverTeamsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListDiscoverTeamsQuery({
 *   variables: {
 *      filter_name: // value for 'filter_name'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListDiscoverTeamsQuery(baseOptions: Apollo.QueryHookOptions<ListDiscoverTeamsQuery, ListDiscoverTeamsQueryVariables>) {
        return Apollo.useQuery<ListDiscoverTeamsQuery, ListDiscoverTeamsQueryVariables>(ListDiscoverTeamsDocument, baseOptions);
      }
export function useListDiscoverTeamsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListDiscoverTeamsQuery, ListDiscoverTeamsQueryVariables>) {
          return Apollo.useLazyQuery<ListDiscoverTeamsQuery, ListDiscoverTeamsQueryVariables>(ListDiscoverTeamsDocument, baseOptions);
        }
export type ListDiscoverTeamsQueryHookResult = ReturnType<typeof useListDiscoverTeamsQuery>;
export type ListDiscoverTeamsLazyQueryHookResult = ReturnType<typeof useListDiscoverTeamsLazyQuery>;
export type ListDiscoverTeamsQueryResult = Apollo.QueryResult<ListDiscoverTeamsQuery, ListDiscoverTeamsQueryVariables>;
export const GetGlobalSearchResultsDocument = gql`
    query GetGlobalSearchResults($query: String_comparison_exp!) {
  dashboard_favorite_count_all(
    where: {dashboard: {name: $query, is_archived: {_eq: false}}}
    order_by: [{favorite_count: desc_nulls_last}, {dashboard_id: asc}]
    limit: 3
  ) {
    dashboard {
      id
      name
      slug
      user {
        id
        name
        profile_image_url
      }
      team {
        id
        name
        handle
        profile_image_url
      }
    }
  }
  query_favorite_count_all(
    where: {query: {name: $query, is_archived: {_eq: false}, is_temp: {_eq: false}}}
    order_by: [{favorite_count: desc_nulls_last}, {query_id: asc}]
    limit: 3
  ) {
    query {
      id
      name
      user {
        id
        name
        profile_image_url
      }
      team {
        id
        handle
        name
        profile_image_url
      }
    }
  }
  user_received_stars(
    where: {user: {name: $query}}
    order_by: [{sum: desc_nulls_last}, {id: asc}]
    limit: 3
  ) {
    user {
      id
      name
      profile_image_url
    }
  }
  teams(
    where: {_or: [{handle: $query}, {name: $query}]}
    order_by: [{id: asc}]
    limit: 3
  ) {
    id
    handle
    name
    profile_image_url
  }
}
    `;

/**
 * __useGetGlobalSearchResultsQuery__
 *
 * To run a query within a React component, call `useGetGlobalSearchResultsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGlobalSearchResultsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGlobalSearchResultsQuery({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useGetGlobalSearchResultsQuery(baseOptions: Apollo.QueryHookOptions<GetGlobalSearchResultsQuery, GetGlobalSearchResultsQueryVariables>) {
        return Apollo.useQuery<GetGlobalSearchResultsQuery, GetGlobalSearchResultsQueryVariables>(GetGlobalSearchResultsDocument, baseOptions);
      }
export function useGetGlobalSearchResultsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGlobalSearchResultsQuery, GetGlobalSearchResultsQueryVariables>) {
          return Apollo.useLazyQuery<GetGlobalSearchResultsQuery, GetGlobalSearchResultsQueryVariables>(GetGlobalSearchResultsDocument, baseOptions);
        }
export type GetGlobalSearchResultsQueryHookResult = ReturnType<typeof useGetGlobalSearchResultsQuery>;
export type GetGlobalSearchResultsLazyQueryHookResult = ReturnType<typeof useGetGlobalSearchResultsLazyQuery>;
export type GetGlobalSearchResultsQueryResult = Apollo.QueryResult<GetGlobalSearchResultsQuery, GetGlobalSearchResultsQueryVariables>;
export const ListContractsDocument = gql`
    query ListContracts($cognito_user_id: uuid, $freetext_filter: String_comparison_exp!, $status_filter: contract_submission_status_comparison_exp!, $limit: Int!, $offset: Int!) {
  contract_submissions(
    where: {cognito_user_id: {_eq: $cognito_user_id}, _or: [{contract_name: $freetext_filter}, {project_name: $freetext_filter}, {address: $freetext_filter}], status: $status_filter}
    order_by: {created_at: desc}
    limit: $limit
    offset: $offset
  ) {
    id
    project_name
    contract_name
    address
    abi
    blockchain
    is_proxy
    is_manual_abi
    has_multiple_instances
    is_created_by_factory
    cognito_user_id
    comment
    resubmission_reason
    status
    created_at
  }
  contract_submissions_aggregate(
    where: {cognito_user_id: {_eq: $cognito_user_id}, _or: [{contract_name: $freetext_filter}, {project_name: $freetext_filter}, {address: $freetext_filter}], status: $status_filter}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useListContractsQuery__
 *
 * To run a query within a React component, call `useListContractsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListContractsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListContractsQuery({
 *   variables: {
 *      cognito_user_id: // value for 'cognito_user_id'
 *      freetext_filter: // value for 'freetext_filter'
 *      status_filter: // value for 'status_filter'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListContractsQuery(baseOptions: Apollo.QueryHookOptions<ListContractsQuery, ListContractsQueryVariables>) {
        return Apollo.useQuery<ListContractsQuery, ListContractsQueryVariables>(ListContractsDocument, baseOptions);
      }
export function useListContractsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListContractsQuery, ListContractsQueryVariables>) {
          return Apollo.useLazyQuery<ListContractsQuery, ListContractsQueryVariables>(ListContractsDocument, baseOptions);
        }
export type ListContractsQueryHookResult = ReturnType<typeof useListContractsQuery>;
export type ListContractsLazyQueryHookResult = ReturnType<typeof useListContractsLazyQuery>;
export type ListContractsQueryResult = Apollo.QueryResult<ListContractsQuery, ListContractsQueryVariables>;
export const ListMyDashboardsDocument = gql`
    query ListMyDashboards($filter_name: String_comparison_exp, $filter_tags: jsonb_comparison_exp, $filter_is_private: Boolean_comparison_exp, $filter_custom: [dashboards_bool_exp!], $order: [dashboards_order_by!], $limit: Int!, $offset: Int!, $include_favs_last_24h: Boolean! = false, $include_favs_last_7d: Boolean! = false, $include_favs_last_30d: Boolean! = false, $include_favs_all_time: Boolean! = false, $is_archived: Boolean! = false) {
  dashboards(
    where: {is_archived: {_eq: $is_archived}, name: $filter_name, tags: $filter_tags, is_private: $filter_is_private, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...DashboardItem
  }
  dashboards_aggregate(
    where: {is_archived: {_eq: $is_archived}, name: $filter_name, tags: $filter_tags, is_private: $filter_is_private, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${DashboardItemFragmentDoc}`;

/**
 * __useListMyDashboardsQuery__
 *
 * To run a query within a React component, call `useListMyDashboardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListMyDashboardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListMyDashboardsQuery({
 *   variables: {
 *      filter_name: // value for 'filter_name'
 *      filter_tags: // value for 'filter_tags'
 *      filter_is_private: // value for 'filter_is_private'
 *      filter_custom: // value for 'filter_custom'
 *      order: // value for 'order'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      include_favs_last_24h: // value for 'include_favs_last_24h'
 *      include_favs_last_7d: // value for 'include_favs_last_7d'
 *      include_favs_last_30d: // value for 'include_favs_last_30d'
 *      include_favs_all_time: // value for 'include_favs_all_time'
 *      is_archived: // value for 'is_archived'
 *   },
 * });
 */
export function useListMyDashboardsQuery(baseOptions: Apollo.QueryHookOptions<ListMyDashboardsQuery, ListMyDashboardsQueryVariables>) {
        return Apollo.useQuery<ListMyDashboardsQuery, ListMyDashboardsQueryVariables>(ListMyDashboardsDocument, baseOptions);
      }
export function useListMyDashboardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListMyDashboardsQuery, ListMyDashboardsQueryVariables>) {
          return Apollo.useLazyQuery<ListMyDashboardsQuery, ListMyDashboardsQueryVariables>(ListMyDashboardsDocument, baseOptions);
        }
export type ListMyDashboardsQueryHookResult = ReturnType<typeof useListMyDashboardsQuery>;
export type ListMyDashboardsLazyQueryHookResult = ReturnType<typeof useListMyDashboardsLazyQuery>;
export type ListMyDashboardsQueryResult = Apollo.QueryResult<ListMyDashboardsQuery, ListMyDashboardsQueryVariables>;
export const ListMyFavoriteDashboardsDocument = gql`
    query ListMyFavoriteDashboards($session_id: Int!, $filter_name: String_comparison_exp, $filter_tags: jsonb_comparison_exp, $filter_custom: [dashboards_bool_exp!], $order: [dashboards_order_by!], $limit: Int!, $offset: Int!, $include_favs_last_24h: Boolean! = false, $include_favs_last_7d: Boolean! = false, $include_favs_last_30d: Boolean! = false, $include_favs_all_time: Boolean! = false) {
  dashboards(
    where: {favorite_dashboards: {user_id: {_eq: $session_id}}, is_archived: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...DashboardItem
  }
  dashboards_aggregate(
    where: {favorite_dashboards: {user_id: {_eq: $session_id}}, is_archived: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${DashboardItemFragmentDoc}`;

/**
 * __useListMyFavoriteDashboardsQuery__
 *
 * To run a query within a React component, call `useListMyFavoriteDashboardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListMyFavoriteDashboardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListMyFavoriteDashboardsQuery({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      filter_name: // value for 'filter_name'
 *      filter_tags: // value for 'filter_tags'
 *      filter_custom: // value for 'filter_custom'
 *      order: // value for 'order'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      include_favs_last_24h: // value for 'include_favs_last_24h'
 *      include_favs_last_7d: // value for 'include_favs_last_7d'
 *      include_favs_last_30d: // value for 'include_favs_last_30d'
 *      include_favs_all_time: // value for 'include_favs_all_time'
 *   },
 * });
 */
export function useListMyFavoriteDashboardsQuery(baseOptions: Apollo.QueryHookOptions<ListMyFavoriteDashboardsQuery, ListMyFavoriteDashboardsQueryVariables>) {
        return Apollo.useQuery<ListMyFavoriteDashboardsQuery, ListMyFavoriteDashboardsQueryVariables>(ListMyFavoriteDashboardsDocument, baseOptions);
      }
export function useListMyFavoriteDashboardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListMyFavoriteDashboardsQuery, ListMyFavoriteDashboardsQueryVariables>) {
          return Apollo.useLazyQuery<ListMyFavoriteDashboardsQuery, ListMyFavoriteDashboardsQueryVariables>(ListMyFavoriteDashboardsDocument, baseOptions);
        }
export type ListMyFavoriteDashboardsQueryHookResult = ReturnType<typeof useListMyFavoriteDashboardsQuery>;
export type ListMyFavoriteDashboardsLazyQueryHookResult = ReturnType<typeof useListMyFavoriteDashboardsLazyQuery>;
export type ListMyFavoriteDashboardsQueryResult = Apollo.QueryResult<ListMyFavoriteDashboardsQuery, ListMyFavoriteDashboardsQueryVariables>;
export const ListMyFavoriteQueriesDocument = gql`
    query ListMyFavoriteQueries($session_id: Int!, $filter_name: String_comparison_exp!, $filter_tags: jsonb_comparison_exp, $filter_custom: [queries_bool_exp!], $order: [queries_order_by!], $limit: Int!, $offset: Int!, $include_favs_last_24h: Boolean! = false, $include_favs_last_7d: Boolean! = false, $include_favs_last_30d: Boolean! = false, $include_favs_all_time: Boolean! = false) {
  queries(
    where: {favorite_queries: {user_id: {_eq: $session_id}}, is_temp: {_eq: false}, is_archived: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...QueryItem
  }
  queries_aggregate(
    where: {favorite_queries: {user_id: {_eq: $session_id}}, is_temp: {_eq: false}, is_archived: {_eq: false}, name: $filter_name, tags: $filter_tags, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${QueryItemFragmentDoc}`;

/**
 * __useListMyFavoriteQueriesQuery__
 *
 * To run a query within a React component, call `useListMyFavoriteQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListMyFavoriteQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListMyFavoriteQueriesQuery({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      filter_name: // value for 'filter_name'
 *      filter_tags: // value for 'filter_tags'
 *      filter_custom: // value for 'filter_custom'
 *      order: // value for 'order'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      include_favs_last_24h: // value for 'include_favs_last_24h'
 *      include_favs_last_7d: // value for 'include_favs_last_7d'
 *      include_favs_last_30d: // value for 'include_favs_last_30d'
 *      include_favs_all_time: // value for 'include_favs_all_time'
 *   },
 * });
 */
export function useListMyFavoriteQueriesQuery(baseOptions: Apollo.QueryHookOptions<ListMyFavoriteQueriesQuery, ListMyFavoriteQueriesQueryVariables>) {
        return Apollo.useQuery<ListMyFavoriteQueriesQuery, ListMyFavoriteQueriesQueryVariables>(ListMyFavoriteQueriesDocument, baseOptions);
      }
export function useListMyFavoriteQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListMyFavoriteQueriesQuery, ListMyFavoriteQueriesQueryVariables>) {
          return Apollo.useLazyQuery<ListMyFavoriteQueriesQuery, ListMyFavoriteQueriesQueryVariables>(ListMyFavoriteQueriesDocument, baseOptions);
        }
export type ListMyFavoriteQueriesQueryHookResult = ReturnType<typeof useListMyFavoriteQueriesQuery>;
export type ListMyFavoriteQueriesLazyQueryHookResult = ReturnType<typeof useListMyFavoriteQueriesLazyQuery>;
export type ListMyFavoriteQueriesQueryResult = Apollo.QueryResult<ListMyFavoriteQueriesQuery, ListMyFavoriteQueriesQueryVariables>;
export const ListMyQueriesDocument = gql`
    query ListMyQueries($filter_name: String_comparison_exp, $filter_tags: jsonb_comparison_exp, $filter_is_private: Boolean_comparison_exp, $filter_is_matview: String_comparison_exp, $filter_custom: [queries_bool_exp!], $is_archived: Boolean!, $order: [queries_order_by!], $limit: Int!, $offset: Int!, $include_favs_last_24h: Boolean! = false, $include_favs_last_7d: Boolean! = false, $include_favs_last_30d: Boolean! = false, $include_favs_all_time: Boolean! = false) {
  queries(
    where: {is_temp: {_eq: false}, is_archived: {_eq: $is_archived}, name: $filter_name, tags: $filter_tags, is_private: $filter_is_private, matview_id: $filter_is_matview, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...QueryItem
  }
  queries_aggregate(
    where: {is_temp: {_eq: false}, is_archived: {_eq: $is_archived}, name: $filter_name, tags: $filter_tags, matview_id: $filter_is_matview, is_private: $filter_is_private, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${QueryItemFragmentDoc}`;

/**
 * __useListMyQueriesQuery__
 *
 * To run a query within a React component, call `useListMyQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListMyQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListMyQueriesQuery({
 *   variables: {
 *      filter_name: // value for 'filter_name'
 *      filter_tags: // value for 'filter_tags'
 *      filter_is_private: // value for 'filter_is_private'
 *      filter_is_matview: // value for 'filter_is_matview'
 *      filter_custom: // value for 'filter_custom'
 *      is_archived: // value for 'is_archived'
 *      order: // value for 'order'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      include_favs_last_24h: // value for 'include_favs_last_24h'
 *      include_favs_last_7d: // value for 'include_favs_last_7d'
 *      include_favs_last_30d: // value for 'include_favs_last_30d'
 *      include_favs_all_time: // value for 'include_favs_all_time'
 *   },
 * });
 */
export function useListMyQueriesQuery(baseOptions: Apollo.QueryHookOptions<ListMyQueriesQuery, ListMyQueriesQueryVariables>) {
        return Apollo.useQuery<ListMyQueriesQuery, ListMyQueriesQueryVariables>(ListMyQueriesDocument, baseOptions);
      }
export function useListMyQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListMyQueriesQuery, ListMyQueriesQueryVariables>) {
          return Apollo.useLazyQuery<ListMyQueriesQuery, ListMyQueriesQueryVariables>(ListMyQueriesDocument, baseOptions);
        }
export type ListMyQueriesQueryHookResult = ReturnType<typeof useListMyQueriesQuery>;
export type ListMyQueriesLazyQueryHookResult = ReturnType<typeof useListMyQueriesLazyQuery>;
export type ListMyQueriesQueryResult = Apollo.QueryResult<ListMyQueriesQuery, ListMyQueriesQueryVariables>;
export const ListOtherTeamMembersDocument = gql`
    query ListOtherTeamMembers($user_id: Int!, $team_id: Int!) {
  memberships_private_details(
    where: {user_id: {_neq: $user_id}, team_id: {_eq: $team_id}, status: {_eq: "invite_accepted"}}
    order_by: {role: desc}
  ) {
    user {
      id
      name
    }
    role
  }
}
    `;

/**
 * __useListOtherTeamMembersQuery__
 *
 * To run a query within a React component, call `useListOtherTeamMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useListOtherTeamMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListOtherTeamMembersQuery({
 *   variables: {
 *      user_id: // value for 'user_id'
 *      team_id: // value for 'team_id'
 *   },
 * });
 */
export function useListOtherTeamMembersQuery(baseOptions: Apollo.QueryHookOptions<ListOtherTeamMembersQuery, ListOtherTeamMembersQueryVariables>) {
        return Apollo.useQuery<ListOtherTeamMembersQuery, ListOtherTeamMembersQueryVariables>(ListOtherTeamMembersDocument, baseOptions);
      }
export function useListOtherTeamMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListOtherTeamMembersQuery, ListOtherTeamMembersQueryVariables>) {
          return Apollo.useLazyQuery<ListOtherTeamMembersQuery, ListOtherTeamMembersQueryVariables>(ListOtherTeamMembersDocument, baseOptions);
        }
export type ListOtherTeamMembersQueryHookResult = ReturnType<typeof useListOtherTeamMembersQuery>;
export type ListOtherTeamMembersLazyQueryHookResult = ReturnType<typeof useListOtherTeamMembersLazyQuery>;
export type ListOtherTeamMembersQueryResult = Apollo.QueryResult<ListOtherTeamMembersQuery, ListOtherTeamMembersQueryVariables>;
export const DeleteAccountDocument = gql`
    mutation DeleteAccount {
  delete_account {
    ok
  }
}
    `;
export type DeleteAccountMutationFn = Apollo.MutationFunction<DeleteAccountMutation, DeleteAccountMutationVariables>;

/**
 * __useDeleteAccountMutation__
 *
 * To run a mutation, you first call `useDeleteAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAccountMutation, { data, loading, error }] = useDeleteAccountMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteAccountMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAccountMutation, DeleteAccountMutationVariables>) {
        return Apollo.useMutation<DeleteAccountMutation, DeleteAccountMutationVariables>(DeleteAccountDocument, baseOptions);
      }
export type DeleteAccountMutationHookResult = ReturnType<typeof useDeleteAccountMutation>;
export type DeleteAccountMutationResult = Apollo.MutationResult<DeleteAccountMutation>;
export type DeleteAccountMutationOptions = Apollo.BaseMutationOptions<DeleteAccountMutation, DeleteAccountMutationVariables>;
export const GetAuthProviderUserDocument = gql`
    query GetAuthProviderUser {
  get_auth_provider_user {
    email
    emailVerified
  }
}
    `;

/**
 * __useGetAuthProviderUserQuery__
 *
 * To run a query within a React component, call `useGetAuthProviderUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAuthProviderUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAuthProviderUserQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAuthProviderUserQuery(baseOptions?: Apollo.QueryHookOptions<GetAuthProviderUserQuery, GetAuthProviderUserQueryVariables>) {
        return Apollo.useQuery<GetAuthProviderUserQuery, GetAuthProviderUserQueryVariables>(GetAuthProviderUserDocument, baseOptions);
      }
export function useGetAuthProviderUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAuthProviderUserQuery, GetAuthProviderUserQueryVariables>) {
          return Apollo.useLazyQuery<GetAuthProviderUserQuery, GetAuthProviderUserQueryVariables>(GetAuthProviderUserDocument, baseOptions);
        }
export type GetAuthProviderUserQueryHookResult = ReturnType<typeof useGetAuthProviderUserQuery>;
export type GetAuthProviderUserLazyQueryHookResult = ReturnType<typeof useGetAuthProviderUserLazyQuery>;
export type GetAuthProviderUserQueryResult = Apollo.QueryResult<GetAuthProviderUserQuery, GetAuthProviderUserQueryVariables>;
export const ResendEmailVerificationCodeDocument = gql`
    mutation ResendEmailVerificationCode {
  resend_email_verification_code {
    ok
  }
}
    `;
export type ResendEmailVerificationCodeMutationFn = Apollo.MutationFunction<ResendEmailVerificationCodeMutation, ResendEmailVerificationCodeMutationVariables>;

/**
 * __useResendEmailVerificationCodeMutation__
 *
 * To run a mutation, you first call `useResendEmailVerificationCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResendEmailVerificationCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resendEmailVerificationCodeMutation, { data, loading, error }] = useResendEmailVerificationCodeMutation({
 *   variables: {
 *   },
 * });
 */
export function useResendEmailVerificationCodeMutation(baseOptions?: Apollo.MutationHookOptions<ResendEmailVerificationCodeMutation, ResendEmailVerificationCodeMutationVariables>) {
        return Apollo.useMutation<ResendEmailVerificationCodeMutation, ResendEmailVerificationCodeMutationVariables>(ResendEmailVerificationCodeDocument, baseOptions);
      }
export type ResendEmailVerificationCodeMutationHookResult = ReturnType<typeof useResendEmailVerificationCodeMutation>;
export type ResendEmailVerificationCodeMutationResult = Apollo.MutationResult<ResendEmailVerificationCodeMutation>;
export type ResendEmailVerificationCodeMutationOptions = Apollo.BaseMutationOptions<ResendEmailVerificationCodeMutation, ResendEmailVerificationCodeMutationVariables>;
export const UpdateEmailDocument = gql`
    mutation UpdateEmail($newEmail: String!) {
  change_email(new_email: $newEmail) {
    new_email
  }
}
    `;
export type UpdateEmailMutationFn = Apollo.MutationFunction<UpdateEmailMutation, UpdateEmailMutationVariables>;

/**
 * __useUpdateEmailMutation__
 *
 * To run a mutation, you first call `useUpdateEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEmailMutation, { data, loading, error }] = useUpdateEmailMutation({
 *   variables: {
 *      newEmail: // value for 'newEmail'
 *   },
 * });
 */
export function useUpdateEmailMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEmailMutation, UpdateEmailMutationVariables>) {
        return Apollo.useMutation<UpdateEmailMutation, UpdateEmailMutationVariables>(UpdateEmailDocument, baseOptions);
      }
export type UpdateEmailMutationHookResult = ReturnType<typeof useUpdateEmailMutation>;
export type UpdateEmailMutationResult = Apollo.MutationResult<UpdateEmailMutation>;
export type UpdateEmailMutationOptions = Apollo.BaseMutationOptions<UpdateEmailMutation, UpdateEmailMutationVariables>;
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($code: String!) {
  verify_email(code: $code) {
    ok
  }
}
    `;
export type VerifyEmailMutationFn = Apollo.MutationFunction<VerifyEmailMutation, VerifyEmailMutationVariables>;

/**
 * __useVerifyEmailMutation__
 *
 * To run a mutation, you first call `useVerifyEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyEmailMutation, { data, loading, error }] = useVerifyEmailMutation({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useVerifyEmailMutation(baseOptions?: Apollo.MutationHookOptions<VerifyEmailMutation, VerifyEmailMutationVariables>) {
        return Apollo.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument, baseOptions);
      }
export type VerifyEmailMutationHookResult = ReturnType<typeof useVerifyEmailMutation>;
export type VerifyEmailMutationResult = Apollo.MutationResult<VerifyEmailMutation>;
export type VerifyEmailMutationOptions = Apollo.BaseMutationOptions<VerifyEmailMutation, VerifyEmailMutationVariables>;
export const ChangePasswordDocument = gql`
    mutation ChangePassword($currentPassword: String!, $newPassword: String!) {
  change_password(current_password: $currentPassword, new_password: $newPassword) {
    ok
  }
}
    `;
export type ChangePasswordMutationFn = Apollo.MutationFunction<ChangePasswordMutation, ChangePasswordMutationVariables>;

/**
 * __useChangePasswordMutation__
 *
 * To run a mutation, you first call `useChangePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changePasswordMutation, { data, loading, error }] = useChangePasswordMutation({
 *   variables: {
 *      currentPassword: // value for 'currentPassword'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export function useChangePasswordMutation(baseOptions?: Apollo.MutationHookOptions<ChangePasswordMutation, ChangePasswordMutationVariables>) {
        return Apollo.useMutation<ChangePasswordMutation, ChangePasswordMutationVariables>(ChangePasswordDocument, baseOptions);
      }
export type ChangePasswordMutationHookResult = ReturnType<typeof useChangePasswordMutation>;
export type ChangePasswordMutationResult = Apollo.MutationResult<ChangePasswordMutation>;
export type ChangePasswordMutationOptions = Apollo.BaseMutationOptions<ChangePasswordMutation, ChangePasswordMutationVariables>;
export const UpdateUserProfileDocument = gql`
    mutation UpdateUserProfile($userId: Int!, $profile_image_url: String, $bio: String, $is_available_for_gigs: Boolean!, $discord_username: String, $twitter_handle: String, $telegram_handle: String, $enable_service_tier_badge: Boolean!, $ethereum_address_is_public: Boolean!) {
  update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {profile_image_url: $profile_image_url, bio: $bio, is_available_for_gigs: $is_available_for_gigs, discord_username: $discord_username, twitter_handle: $twitter_handle, telegram_handle: $telegram_handle, enable_service_tier_badge: $enable_service_tier_badge, ethereum_address_is_public: $ethereum_address_is_public}
  ) {
    id
    bio
    is_available_for_gigs
    discord_username
    twitter_handle
    telegram_handle
    ethereum_address
    private_info {
      enable_service_tier_badge
      ethereum_address_is_public
    }
    conditional_public_attributes {
      service_tier_name
      ethereum_address
    }
  }
}
    `;
export type UpdateUserProfileMutationFn = Apollo.MutationFunction<UpdateUserProfileMutation, UpdateUserProfileMutationVariables>;

/**
 * __useUpdateUserProfileMutation__
 *
 * To run a mutation, you first call `useUpdateUserProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserProfileMutation, { data, loading, error }] = useUpdateUserProfileMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      profile_image_url: // value for 'profile_image_url'
 *      bio: // value for 'bio'
 *      is_available_for_gigs: // value for 'is_available_for_gigs'
 *      discord_username: // value for 'discord_username'
 *      twitter_handle: // value for 'twitter_handle'
 *      telegram_handle: // value for 'telegram_handle'
 *      enable_service_tier_badge: // value for 'enable_service_tier_badge'
 *      ethereum_address_is_public: // value for 'ethereum_address_is_public'
 *   },
 * });
 */
export function useUpdateUserProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserProfileMutation, UpdateUserProfileMutationVariables>) {
        return Apollo.useMutation<UpdateUserProfileMutation, UpdateUserProfileMutationVariables>(UpdateUserProfileDocument, baseOptions);
      }
export type UpdateUserProfileMutationHookResult = ReturnType<typeof useUpdateUserProfileMutation>;
export type UpdateUserProfileMutationResult = Apollo.MutationResult<UpdateUserProfileMutation>;
export type UpdateUserProfileMutationOptions = Apollo.BaseMutationOptions<UpdateUserProfileMutation, UpdateUserProfileMutationVariables>;
export const FindOwnProfileDocument = gql`
    query FindOwnProfile($id: Int!) {
  users_by_pk(id: $id) {
    id
    name
    profile_image_url
    bio
    is_available_for_gigs
    discord_username
    twitter_handle
    telegram_handle
    ethereum_address
    received_stars {
      sum
    }
    queries(order_by: {created_at: asc_nulls_last}, limit: 1) {
      created_at
    }
    private_info {
      enable_service_tier_badge
      ethereum_address_is_public
    }
    user_service_tier {
      id
      name
    }
  }
}
    `;

/**
 * __useFindOwnProfileQuery__
 *
 * To run a query within a React component, call `useFindOwnProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOwnProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOwnProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFindOwnProfileQuery(baseOptions: Apollo.QueryHookOptions<FindOwnProfileQuery, FindOwnProfileQueryVariables>) {
        return Apollo.useQuery<FindOwnProfileQuery, FindOwnProfileQueryVariables>(FindOwnProfileDocument, baseOptions);
      }
export function useFindOwnProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindOwnProfileQuery, FindOwnProfileQueryVariables>) {
          return Apollo.useLazyQuery<FindOwnProfileQuery, FindOwnProfileQueryVariables>(FindOwnProfileDocument, baseOptions);
        }
export type FindOwnProfileQueryHookResult = ReturnType<typeof useFindOwnProfileQuery>;
export type FindOwnProfileLazyQueryHookResult = ReturnType<typeof useFindOwnProfileLazyQuery>;
export type FindOwnProfileQueryResult = Apollo.QueryResult<FindOwnProfileQuery, FindOwnProfileQueryVariables>;
export const GetUserServiceTierByIdDocument = gql`
    query GetUserServiceTierById($id: Int!) {
  user_service_tiers_by_pk(id: $id) {
    id
    name
  }
}
    `;

/**
 * __useGetUserServiceTierByIdQuery__
 *
 * To run a query within a React component, call `useGetUserServiceTierByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserServiceTierByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserServiceTierByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserServiceTierByIdQuery(baseOptions: Apollo.QueryHookOptions<GetUserServiceTierByIdQuery, GetUserServiceTierByIdQueryVariables>) {
        return Apollo.useQuery<GetUserServiceTierByIdQuery, GetUserServiceTierByIdQueryVariables>(GetUserServiceTierByIdDocument, baseOptions);
      }
export function useGetUserServiceTierByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserServiceTierByIdQuery, GetUserServiceTierByIdQueryVariables>) {
          return Apollo.useLazyQuery<GetUserServiceTierByIdQuery, GetUserServiceTierByIdQueryVariables>(GetUserServiceTierByIdDocument, baseOptions);
        }
export type GetUserServiceTierByIdQueryHookResult = ReturnType<typeof useGetUserServiceTierByIdQuery>;
export type GetUserServiceTierByIdLazyQueryHookResult = ReturnType<typeof useGetUserServiceTierByIdLazyQuery>;
export type GetUserServiceTierByIdQueryResult = Apollo.QueryResult<GetUserServiceTierByIdQuery, GetUserServiceTierByIdQueryVariables>;
export const GetUserUsageDataDocument = gql`
    query GetUserUsageData {
  dashboards_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, team_id: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
  queries_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, is_temp: {_eq: false}, team_id: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
  billable_usage {
    query_executions
    csv_downloads
    datapoints_read
  }
}
    `;

/**
 * __useGetUserUsageDataQuery__
 *
 * To run a query within a React component, call `useGetUserUsageDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserUsageDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserUsageDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUserUsageDataQuery(baseOptions?: Apollo.QueryHookOptions<GetUserUsageDataQuery, GetUserUsageDataQueryVariables>) {
        return Apollo.useQuery<GetUserUsageDataQuery, GetUserUsageDataQueryVariables>(GetUserUsageDataDocument, baseOptions);
      }
export function useGetUserUsageDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserUsageDataQuery, GetUserUsageDataQueryVariables>) {
          return Apollo.useLazyQuery<GetUserUsageDataQuery, GetUserUsageDataQueryVariables>(GetUserUsageDataDocument, baseOptions);
        }
export type GetUserUsageDataQueryHookResult = ReturnType<typeof useGetUserUsageDataQuery>;
export type GetUserUsageDataLazyQueryHookResult = ReturnType<typeof useGetUserUsageDataLazyQuery>;
export type GetUserUsageDataQueryResult = Apollo.QueryResult<GetUserUsageDataQuery, GetUserUsageDataQueryVariables>;
export const CancelApiUserPlanDocument = gql`
    mutation CancelApiUserPlan {
  cancel_api_user_subscription {
    ok
  }
}
    `;
export type CancelApiUserPlanMutationFn = Apollo.MutationFunction<CancelApiUserPlanMutation, CancelApiUserPlanMutationVariables>;

/**
 * __useCancelApiUserPlanMutation__
 *
 * To run a mutation, you first call `useCancelApiUserPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelApiUserPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelApiUserPlanMutation, { data, loading, error }] = useCancelApiUserPlanMutation({
 *   variables: {
 *   },
 * });
 */
export function useCancelApiUserPlanMutation(baseOptions?: Apollo.MutationHookOptions<CancelApiUserPlanMutation, CancelApiUserPlanMutationVariables>) {
        return Apollo.useMutation<CancelApiUserPlanMutation, CancelApiUserPlanMutationVariables>(CancelApiUserPlanDocument, baseOptions);
      }
export type CancelApiUserPlanMutationHookResult = ReturnType<typeof useCancelApiUserPlanMutation>;
export type CancelApiUserPlanMutationResult = Apollo.MutationResult<CancelApiUserPlanMutation>;
export type CancelApiUserPlanMutationOptions = Apollo.BaseMutationOptions<CancelApiUserPlanMutation, CancelApiUserPlanMutationVariables>;
export const CancelUserPlanDocument = gql`
    mutation CancelUserPlan($service_tier_name: String!) {
  downgrade_user_subscription(service_tier_name: $service_tier_name) {
    ok
  }
}
    `;
export type CancelUserPlanMutationFn = Apollo.MutationFunction<CancelUserPlanMutation, CancelUserPlanMutationVariables>;

/**
 * __useCancelUserPlanMutation__
 *
 * To run a mutation, you first call `useCancelUserPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelUserPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelUserPlanMutation, { data, loading, error }] = useCancelUserPlanMutation({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useCancelUserPlanMutation(baseOptions?: Apollo.MutationHookOptions<CancelUserPlanMutation, CancelUserPlanMutationVariables>) {
        return Apollo.useMutation<CancelUserPlanMutation, CancelUserPlanMutationVariables>(CancelUserPlanDocument, baseOptions);
      }
export type CancelUserPlanMutationHookResult = ReturnType<typeof useCancelUserPlanMutation>;
export type CancelUserPlanMutationResult = Apollo.MutationResult<CancelUserPlanMutation>;
export type CancelUserPlanMutationOptions = Apollo.BaseMutationOptions<CancelUserPlanMutation, CancelUserPlanMutationVariables>;
export const GetPendingApiUpdatesDocument = gql`
    query GetPendingApiUpdates {
  pending_api_user_subscription_updates {
    update_date
    api_user_service_tier {
      name
    }
    update_type
  }
}
    `;

/**
 * __useGetPendingApiUpdatesQuery__
 *
 * To run a query within a React component, call `useGetPendingApiUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPendingApiUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPendingApiUpdatesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPendingApiUpdatesQuery(baseOptions?: Apollo.QueryHookOptions<GetPendingApiUpdatesQuery, GetPendingApiUpdatesQueryVariables>) {
        return Apollo.useQuery<GetPendingApiUpdatesQuery, GetPendingApiUpdatesQueryVariables>(GetPendingApiUpdatesDocument, baseOptions);
      }
export function useGetPendingApiUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPendingApiUpdatesQuery, GetPendingApiUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<GetPendingApiUpdatesQuery, GetPendingApiUpdatesQueryVariables>(GetPendingApiUpdatesDocument, baseOptions);
        }
export type GetPendingApiUpdatesQueryHookResult = ReturnType<typeof useGetPendingApiUpdatesQuery>;
export type GetPendingApiUpdatesLazyQueryHookResult = ReturnType<typeof useGetPendingApiUpdatesLazyQuery>;
export type GetPendingApiUpdatesQueryResult = Apollo.QueryResult<GetPendingApiUpdatesQuery, GetPendingApiUpdatesQueryVariables>;
export const GetPendingUserUpdatesDocument = gql`
    query GetPendingUserUpdates {
  pending_user_subscription_updates {
    update_date
    user_service_tier {
      id
      name
    }
    update_type
  }
}
    `;

/**
 * __useGetPendingUserUpdatesQuery__
 *
 * To run a query within a React component, call `useGetPendingUserUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPendingUserUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPendingUserUpdatesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPendingUserUpdatesQuery(baseOptions?: Apollo.QueryHookOptions<GetPendingUserUpdatesQuery, GetPendingUserUpdatesQueryVariables>) {
        return Apollo.useQuery<GetPendingUserUpdatesQuery, GetPendingUserUpdatesQueryVariables>(GetPendingUserUpdatesDocument, baseOptions);
      }
export function useGetPendingUserUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPendingUserUpdatesQuery, GetPendingUserUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<GetPendingUserUpdatesQuery, GetPendingUserUpdatesQueryVariables>(GetPendingUserUpdatesDocument, baseOptions);
        }
export type GetPendingUserUpdatesQueryHookResult = ReturnType<typeof useGetPendingUserUpdatesQuery>;
export type GetPendingUserUpdatesLazyQueryHookResult = ReturnType<typeof useGetPendingUserUpdatesLazyQuery>;
export type GetPendingUserUpdatesQueryResult = Apollo.QueryResult<GetPendingUserUpdatesQuery, GetPendingUserUpdatesQueryVariables>;
export const UnlinkWalletDocument = gql`
    mutation UnlinkWallet {
  unlink_wallet_address {
    ok
  }
}
    `;
export type UnlinkWalletMutationFn = Apollo.MutationFunction<UnlinkWalletMutation, UnlinkWalletMutationVariables>;

/**
 * __useUnlinkWalletMutation__
 *
 * To run a mutation, you first call `useUnlinkWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnlinkWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unlinkWalletMutation, { data, loading, error }] = useUnlinkWalletMutation({
 *   variables: {
 *   },
 * });
 */
export function useUnlinkWalletMutation(baseOptions?: Apollo.MutationHookOptions<UnlinkWalletMutation, UnlinkWalletMutationVariables>) {
        return Apollo.useMutation<UnlinkWalletMutation, UnlinkWalletMutationVariables>(UnlinkWalletDocument, baseOptions);
      }
export type UnlinkWalletMutationHookResult = ReturnType<typeof useUnlinkWalletMutation>;
export type UnlinkWalletMutationResult = Apollo.MutationResult<UnlinkWalletMutation>;
export type UnlinkWalletMutationOptions = Apollo.BaseMutationOptions<UnlinkWalletMutation, UnlinkWalletMutationVariables>;
export const GetMembershipDocument = gql`
    query GetMembership($user_id: Int!, $team_id: Int!) {
  memberships(where: {user_id: {_eq: $user_id}, _and: {team_id: {_eq: $team_id}}}) {
    id
    private_details {
      role
      status
    }
  }
}
    `;

/**
 * __useGetMembershipQuery__
 *
 * To run a query within a React component, call `useGetMembershipQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMembershipQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMembershipQuery({
 *   variables: {
 *      user_id: // value for 'user_id'
 *      team_id: // value for 'team_id'
 *   },
 * });
 */
export function useGetMembershipQuery(baseOptions: Apollo.QueryHookOptions<GetMembershipQuery, GetMembershipQueryVariables>) {
        return Apollo.useQuery<GetMembershipQuery, GetMembershipQueryVariables>(GetMembershipDocument, baseOptions);
      }
export function useGetMembershipLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMembershipQuery, GetMembershipQueryVariables>) {
          return Apollo.useLazyQuery<GetMembershipQuery, GetMembershipQueryVariables>(GetMembershipDocument, baseOptions);
        }
export type GetMembershipQueryHookResult = ReturnType<typeof useGetMembershipQuery>;
export type GetMembershipLazyQueryHookResult = ReturnType<typeof useGetMembershipLazyQuery>;
export type GetMembershipQueryResult = Apollo.QueryResult<GetMembershipQuery, GetMembershipQueryVariables>;
export const StaticTeamProfileDataDocument = gql`
    query StaticTeamProfileData($handle: String!) {
  teams(where: {handle: {_eq: $handle}}) {
    id
    name
    handle
    profile_image_url
    bio
    twitter_handle
    telegram_handle
    discord_url
    received_stars {
      sum
    }
    conditional_public_attributes {
      service_tier {
        name
      }
    }
    dashboards(
      where: {is_archived: {_eq: false}}
      limit: 20
      order_by: [{dashboard_favorite_count_all: {favorite_count: desc_nulls_last}}, {id: asc}]
    ) {
      ...DashboardItemOnProfile
    }
    dashboards_aggregate(where: {is_archived: {_eq: false}}) {
      aggregate {
        count
      }
    }
    queries(
      where: {is_temp: {_eq: false}, is_archived: {_eq: false}}
      limit: 20
      order_by: [{query_favorite_count_all: {favorite_count: desc_nulls_last}}, {id: asc}]
    ) {
      ...QueryItemOnProfile
    }
    queries_aggregate(where: {is_temp: {_eq: false}, is_archived: {_eq: false}}) {
      aggregate {
        count
      }
    }
    memberships {
      id
      user {
        id
        name
        profile_image_url
      }
    }
  }
}
    ${DashboardItemOnProfileFragmentDoc}
${QueryItemOnProfileFragmentDoc}`;

/**
 * __useStaticTeamProfileDataQuery__
 *
 * To run a query within a React component, call `useStaticTeamProfileDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useStaticTeamProfileDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStaticTeamProfileDataQuery({
 *   variables: {
 *      handle: // value for 'handle'
 *   },
 * });
 */
export function useStaticTeamProfileDataQuery(baseOptions: Apollo.QueryHookOptions<StaticTeamProfileDataQuery, StaticTeamProfileDataQueryVariables>) {
        return Apollo.useQuery<StaticTeamProfileDataQuery, StaticTeamProfileDataQueryVariables>(StaticTeamProfileDataDocument, baseOptions);
      }
export function useStaticTeamProfileDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StaticTeamProfileDataQuery, StaticTeamProfileDataQueryVariables>) {
          return Apollo.useLazyQuery<StaticTeamProfileDataQuery, StaticTeamProfileDataQueryVariables>(StaticTeamProfileDataDocument, baseOptions);
        }
export type StaticTeamProfileDataQueryHookResult = ReturnType<typeof useStaticTeamProfileDataQuery>;
export type StaticTeamProfileDataLazyQueryHookResult = ReturnType<typeof useStaticTeamProfileDataLazyQuery>;
export type StaticTeamProfileDataQueryResult = Apollo.QueryResult<StaticTeamProfileDataQuery, StaticTeamProfileDataQueryVariables>;
export const ListUserTeamsDocument = gql`
    query ListUserTeams($user_id: Int!) {
  teams(where: {memberships: {user: {id: {_eq: $user_id}}}}) {
    name
    handle
    profile_image_url
  }
}
    `;

/**
 * __useListUserTeamsQuery__
 *
 * To run a query within a React component, call `useListUserTeamsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListUserTeamsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListUserTeamsQuery({
 *   variables: {
 *      user_id: // value for 'user_id'
 *   },
 * });
 */
export function useListUserTeamsQuery(baseOptions: Apollo.QueryHookOptions<ListUserTeamsQuery, ListUserTeamsQueryVariables>) {
        return Apollo.useQuery<ListUserTeamsQuery, ListUserTeamsQueryVariables>(ListUserTeamsDocument, baseOptions);
      }
export function useListUserTeamsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListUserTeamsQuery, ListUserTeamsQueryVariables>) {
          return Apollo.useLazyQuery<ListUserTeamsQuery, ListUserTeamsQueryVariables>(ListUserTeamsDocument, baseOptions);
        }
export type ListUserTeamsQueryHookResult = ReturnType<typeof useListUserTeamsQuery>;
export type ListUserTeamsLazyQueryHookResult = ReturnType<typeof useListUserTeamsLazyQuery>;
export type ListUserTeamsQueryResult = Apollo.QueryResult<ListUserTeamsQuery, ListUserTeamsQueryVariables>;
export const StaticUserProfileDataDocument = gql`
    query StaticUserProfileData($name: String!) {
  users(where: {name: {_eq: $name}}) {
    id
    name
    profile_image_url
    dashboards(
      where: {is_archived: {_eq: false}}
      limit: 20
      order_by: [{dashboard_favorite_count_all: {favorite_count: desc_nulls_last}}, {id: asc}]
    ) {
      ...DashboardItemOnProfile
    }
    dashboards_aggregate(where: {is_archived: {_eq: false}}) {
      aggregate {
        count
      }
    }
    queries(
      where: {is_temp: {_eq: false}, is_archived: {_eq: false}}
      limit: 20
      order_by: [{query_favorite_count_all: {favorite_count: desc_nulls_last}}, {id: asc}]
    ) {
      ...QueryItemOnProfile
    }
    queries_aggregate(where: {is_temp: {_eq: false}, is_archived: {_eq: false}}) {
      aggregate {
        count
      }
    }
  }
}
    ${DashboardItemOnProfileFragmentDoc}
${QueryItemOnProfileFragmentDoc}`;

/**
 * __useStaticUserProfileDataQuery__
 *
 * To run a query within a React component, call `useStaticUserProfileDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useStaticUserProfileDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStaticUserProfileDataQuery({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useStaticUserProfileDataQuery(baseOptions: Apollo.QueryHookOptions<StaticUserProfileDataQuery, StaticUserProfileDataQueryVariables>) {
        return Apollo.useQuery<StaticUserProfileDataQuery, StaticUserProfileDataQueryVariables>(StaticUserProfileDataDocument, baseOptions);
      }
export function useStaticUserProfileDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StaticUserProfileDataQuery, StaticUserProfileDataQueryVariables>) {
          return Apollo.useLazyQuery<StaticUserProfileDataQuery, StaticUserProfileDataQueryVariables>(StaticUserProfileDataDocument, baseOptions);
        }
export type StaticUserProfileDataQueryHookResult = ReturnType<typeof useStaticUserProfileDataQuery>;
export type StaticUserProfileDataLazyQueryHookResult = ReturnType<typeof useStaticUserProfileDataLazyQuery>;
export type StaticUserProfileDataQueryResult = Apollo.QueryResult<StaticUserProfileDataQuery, StaticUserProfileDataQueryVariables>;
export const FindPublicProfileDocument = gql`
    query FindPublicProfile($id: Int!) {
  users_by_pk(id: $id) {
    id
    name
    profile_image_url
    bio
    is_available_for_gigs
    discord_username
    twitter_handle
    telegram_handle
    received_stars {
      sum
    }
    queries(order_by: {created_at: asc_nulls_last}, limit: 1) {
      created_at
    }
    conditional_public_attributes {
      ethereum_address
      service_tier_name
    }
    contract_submissions_aggregate(where: {status: {_eq: "processed"}}) {
      aggregate {
        count(distinct: true, columns: [address, blockchain])
      }
    }
  }
}
    `;

/**
 * __useFindPublicProfileQuery__
 *
 * To run a query within a React component, call `useFindPublicProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindPublicProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindPublicProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFindPublicProfileQuery(baseOptions: Apollo.QueryHookOptions<FindPublicProfileQuery, FindPublicProfileQueryVariables>) {
        return Apollo.useQuery<FindPublicProfileQuery, FindPublicProfileQueryVariables>(FindPublicProfileDocument, baseOptions);
      }
export function useFindPublicProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindPublicProfileQuery, FindPublicProfileQueryVariables>) {
          return Apollo.useLazyQuery<FindPublicProfileQuery, FindPublicProfileQueryVariables>(FindPublicProfileDocument, baseOptions);
        }
export type FindPublicProfileQueryHookResult = ReturnType<typeof useFindPublicProfileQuery>;
export type FindPublicProfileLazyQueryHookResult = ReturnType<typeof useFindPublicProfileLazyQuery>;
export type FindPublicProfileQueryResult = Apollo.QueryResult<FindPublicProfileQuery, FindPublicProfileQueryVariables>;
export const GenerateUploadUrlDocument = gql`
    mutation GenerateUploadUrl($content_length: Int!, $file_type: String!) {
  generate_upload_url(
    content_length: $content_length
    file_type: $file_type
    upload_type: "profile_image"
  ) {
    url
  }
}
    `;
export type GenerateUploadUrlMutationFn = Apollo.MutationFunction<GenerateUploadUrlMutation, GenerateUploadUrlMutationVariables>;

/**
 * __useGenerateUploadUrlMutation__
 *
 * To run a mutation, you first call `useGenerateUploadUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateUploadUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateUploadUrlMutation, { data, loading, error }] = useGenerateUploadUrlMutation({
 *   variables: {
 *      content_length: // value for 'content_length'
 *      file_type: // value for 'file_type'
 *   },
 * });
 */
export function useGenerateUploadUrlMutation(baseOptions?: Apollo.MutationHookOptions<GenerateUploadUrlMutation, GenerateUploadUrlMutationVariables>) {
        return Apollo.useMutation<GenerateUploadUrlMutation, GenerateUploadUrlMutationVariables>(GenerateUploadUrlDocument, baseOptions);
      }
export type GenerateUploadUrlMutationHookResult = ReturnType<typeof useGenerateUploadUrlMutation>;
export type GenerateUploadUrlMutationResult = Apollo.MutationResult<GenerateUploadUrlMutation>;
export type GenerateUploadUrlMutationOptions = Apollo.BaseMutationOptions<GenerateUploadUrlMutation, GenerateUploadUrlMutationVariables>;
export const ForkDashboardDocument = gql`
    mutation ForkDashboard($existing_dashboard_id: Int!, $new_dashboard_name: String!, $new_dashboard_slug: String!, $contextOwner: ContextOwner!) {
  fork_dashboard_v2(
    dashboard_id: $existing_dashboard_id
    dashboard_name: $new_dashboard_name
    dashboard_slug: $new_dashboard_slug
    forkTo: $contextOwner
  ) {
    slug
  }
}
    `;
export type ForkDashboardMutationFn = Apollo.MutationFunction<ForkDashboardMutation, ForkDashboardMutationVariables>;

/**
 * __useForkDashboardMutation__
 *
 * To run a mutation, you first call `useForkDashboardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useForkDashboardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [forkDashboardMutation, { data, loading, error }] = useForkDashboardMutation({
 *   variables: {
 *      existing_dashboard_id: // value for 'existing_dashboard_id'
 *      new_dashboard_name: // value for 'new_dashboard_name'
 *      new_dashboard_slug: // value for 'new_dashboard_slug'
 *      contextOwner: // value for 'contextOwner'
 *   },
 * });
 */
export function useForkDashboardMutation(baseOptions?: Apollo.MutationHookOptions<ForkDashboardMutation, ForkDashboardMutationVariables>) {
        return Apollo.useMutation<ForkDashboardMutation, ForkDashboardMutationVariables>(ForkDashboardDocument, baseOptions);
      }
export type ForkDashboardMutationHookResult = ReturnType<typeof useForkDashboardMutation>;
export type ForkDashboardMutationResult = Apollo.MutationResult<ForkDashboardMutation>;
export type ForkDashboardMutationOptions = Apollo.BaseMutationOptions<ForkDashboardMutation, ForkDashboardMutationVariables>;
export const UpsertDashboardDocument = gql`
    mutation UpsertDashboard($object: dashboards_insert_input!, $on_conflict: dashboards_on_conflict!) {
  insert_dashboards_one(object: $object, on_conflict: $on_conflict) {
    slug
  }
}
    `;
export type UpsertDashboardMutationFn = Apollo.MutationFunction<UpsertDashboardMutation, UpsertDashboardMutationVariables>;

/**
 * __useUpsertDashboardMutation__
 *
 * To run a mutation, you first call `useUpsertDashboardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertDashboardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertDashboardMutation, { data, loading, error }] = useUpsertDashboardMutation({
 *   variables: {
 *      object: // value for 'object'
 *      on_conflict: // value for 'on_conflict'
 *   },
 * });
 */
export function useUpsertDashboardMutation(baseOptions?: Apollo.MutationHookOptions<UpsertDashboardMutation, UpsertDashboardMutationVariables>) {
        return Apollo.useMutation<UpsertDashboardMutation, UpsertDashboardMutationVariables>(UpsertDashboardDocument, baseOptions);
      }
export type UpsertDashboardMutationHookResult = ReturnType<typeof useUpsertDashboardMutation>;
export type UpsertDashboardMutationResult = Apollo.MutationResult<UpsertDashboardMutation>;
export type UpsertDashboardMutationOptions = Apollo.BaseMutationOptions<UpsertDashboardMutation, UpsertDashboardMutationVariables>;
export const PatchDashboardSettingsDocument = gql`
    mutation PatchDashboardSettings($id: Int!, $name: String, $user_id: Int, $team_id: Int, $is_private: Boolean, $slug: String, $tags: jsonb) {
  patch_dashboard_settings(
    dashboard_settings: {name: $name, id: $id, is_private: $is_private, team_id: $team_id, user_id: $user_id, slug: $slug}
  ) {
    dashboard {
      id
      name
      is_private
      user_id
      team_id
      slug
    }
  }
  update_dashboards(where: {id: {_eq: $id}}, _set: {tags: $tags}) {
    returning {
      id
      tags
    }
  }
}
    `;
export type PatchDashboardSettingsMutationFn = Apollo.MutationFunction<PatchDashboardSettingsMutation, PatchDashboardSettingsMutationVariables>;

/**
 * __usePatchDashboardSettingsMutation__
 *
 * To run a mutation, you first call `usePatchDashboardSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchDashboardSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchDashboardSettingsMutation, { data, loading, error }] = usePatchDashboardSettingsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      user_id: // value for 'user_id'
 *      team_id: // value for 'team_id'
 *      is_private: // value for 'is_private'
 *      slug: // value for 'slug'
 *      tags: // value for 'tags'
 *   },
 * });
 */
export function usePatchDashboardSettingsMutation(baseOptions?: Apollo.MutationHookOptions<PatchDashboardSettingsMutation, PatchDashboardSettingsMutationVariables>) {
        return Apollo.useMutation<PatchDashboardSettingsMutation, PatchDashboardSettingsMutationVariables>(PatchDashboardSettingsDocument, baseOptions);
      }
export type PatchDashboardSettingsMutationHookResult = ReturnType<typeof usePatchDashboardSettingsMutation>;
export type PatchDashboardSettingsMutationResult = Apollo.MutationResult<PatchDashboardSettingsMutation>;
export type PatchDashboardSettingsMutationOptions = Apollo.BaseMutationOptions<PatchDashboardSettingsMutation, PatchDashboardSettingsMutationVariables>;
export const GetUserPrivateDashboardsDocument = gql`
    query GetUserPrivateDashboards {
  dashboards_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, team_id: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetUserPrivateDashboardsQuery__
 *
 * To run a query within a React component, call `useGetUserPrivateDashboardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserPrivateDashboardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserPrivateDashboardsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUserPrivateDashboardsQuery(baseOptions?: Apollo.QueryHookOptions<GetUserPrivateDashboardsQuery, GetUserPrivateDashboardsQueryVariables>) {
        return Apollo.useQuery<GetUserPrivateDashboardsQuery, GetUserPrivateDashboardsQueryVariables>(GetUserPrivateDashboardsDocument, baseOptions);
      }
export function useGetUserPrivateDashboardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserPrivateDashboardsQuery, GetUserPrivateDashboardsQueryVariables>) {
          return Apollo.useLazyQuery<GetUserPrivateDashboardsQuery, GetUserPrivateDashboardsQueryVariables>(GetUserPrivateDashboardsDocument, baseOptions);
        }
export type GetUserPrivateDashboardsQueryHookResult = ReturnType<typeof useGetUserPrivateDashboardsQuery>;
export type GetUserPrivateDashboardsLazyQueryHookResult = ReturnType<typeof useGetUserPrivateDashboardsLazyQuery>;
export type GetUserPrivateDashboardsQueryResult = Apollo.QueryResult<GetUserPrivateDashboardsQuery, GetUserPrivateDashboardsQueryVariables>;
export const GetTeamPrivateDashboardsDocument = gql`
    query GetTeamPrivateDashboards($teamId: Int!) {
  dashboards_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, team_id: {_eq: $teamId}}
  ) {
    aggregate {
      count
    }
  }
  team_members_details(where: {id: {_eq: $teamId}}) {
    id
    service_tier {
      id
      max_private_dashboards
    }
  }
}
    `;

/**
 * __useGetTeamPrivateDashboardsQuery__
 *
 * To run a query within a React component, call `useGetTeamPrivateDashboardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamPrivateDashboardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamPrivateDashboardsQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamPrivateDashboardsQuery(baseOptions: Apollo.QueryHookOptions<GetTeamPrivateDashboardsQuery, GetTeamPrivateDashboardsQueryVariables>) {
        return Apollo.useQuery<GetTeamPrivateDashboardsQuery, GetTeamPrivateDashboardsQueryVariables>(GetTeamPrivateDashboardsDocument, baseOptions);
      }
export function useGetTeamPrivateDashboardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamPrivateDashboardsQuery, GetTeamPrivateDashboardsQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamPrivateDashboardsQuery, GetTeamPrivateDashboardsQueryVariables>(GetTeamPrivateDashboardsDocument, baseOptions);
        }
export type GetTeamPrivateDashboardsQueryHookResult = ReturnType<typeof useGetTeamPrivateDashboardsQuery>;
export type GetTeamPrivateDashboardsLazyQueryHookResult = ReturnType<typeof useGetTeamPrivateDashboardsLazyQuery>;
export type GetTeamPrivateDashboardsQueryResult = Apollo.QueryResult<GetTeamPrivateDashboardsQuery, GetTeamPrivateDashboardsQueryVariables>;
export const ListAbisForContractDocument = gql`
    query ListAbisForContract($namespace: String!, $contract_name: String!, $blockchains_filter: jsonb_comparison_exp!, $dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $abi_type_filter: String_comparison_exp!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "decoded_project"}, namespace: {_eq: $namespace}, contract_name: {_eq: $contract_name}, blockchains: $blockchains_filter, dataset_id: {_eq: $dataset_id}, abi_type: $abi_type_filter, _and: $search_terms}
    order_by: [{abi_name: asc}]
    distinct_on: [abi_name]
    limit: 50
    offset: $offset
  ) {
    abi_name
    abi_type
    full_name
  }
}
    `;

/**
 * __useListAbisForContractQuery__
 *
 * To run a query within a React component, call `useListAbisForContractQuery` and pass it any options that fit your needs.
 * When your component renders, `useListAbisForContractQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListAbisForContractQuery({
 *   variables: {
 *      namespace: // value for 'namespace'
 *      contract_name: // value for 'contract_name'
 *      blockchains_filter: // value for 'blockchains_filter'
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      abi_type_filter: // value for 'abi_type_filter'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListAbisForContractQuery(baseOptions: Apollo.QueryHookOptions<ListAbisForContractQuery, ListAbisForContractQueryVariables>) {
        return Apollo.useQuery<ListAbisForContractQuery, ListAbisForContractQueryVariables>(ListAbisForContractDocument, baseOptions);
      }
export function useListAbisForContractLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListAbisForContractQuery, ListAbisForContractQueryVariables>) {
          return Apollo.useLazyQuery<ListAbisForContractQuery, ListAbisForContractQueryVariables>(ListAbisForContractDocument, baseOptions);
        }
export type ListAbisForContractQueryHookResult = ReturnType<typeof useListAbisForContractQuery>;
export type ListAbisForContractLazyQueryHookResult = ReturnType<typeof useListAbisForContractLazyQuery>;
export type ListAbisForContractQueryResult = Apollo.QueryResult<ListAbisForContractQuery, ListAbisForContractQueryVariables>;
export const ListAbstractionTablesDocument = gql`
    query ListAbstractionTables($namespace: String!, $dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $filter_blockchains: jsonb_comparison_exp!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "abstraction"}, namespace: {_eq: $namespace}, dataset_id: {_eq: $dataset_id}, blockchains: $filter_blockchains, _and: $search_terms}
    order_by: [{blockchains: asc}, {table_name: asc}]
    distinct_on: [table_name, blockchains]
    limit: 50
    offset: $offset
  ) {
    table_name
    full_name
    blockchains
  }
  distinct_by_blockchains: arrakis_schemas(
    where: {category: {_eq: "abstraction"}, namespace: {_eq: $namespace}, dataset_id: {_eq: $dataset_id}}
    order_by: [{blockchains: asc}]
    distinct_on: [blockchains]
    limit: 50
  ) {
    blockchains
  }
}
    `;

/**
 * __useListAbstractionTablesQuery__
 *
 * To run a query within a React component, call `useListAbstractionTablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListAbstractionTablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListAbstractionTablesQuery({
 *   variables: {
 *      namespace: // value for 'namespace'
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      filter_blockchains: // value for 'filter_blockchains'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListAbstractionTablesQuery(baseOptions: Apollo.QueryHookOptions<ListAbstractionTablesQuery, ListAbstractionTablesQueryVariables>) {
        return Apollo.useQuery<ListAbstractionTablesQuery, ListAbstractionTablesQueryVariables>(ListAbstractionTablesDocument, baseOptions);
      }
export function useListAbstractionTablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListAbstractionTablesQuery, ListAbstractionTablesQueryVariables>) {
          return Apollo.useLazyQuery<ListAbstractionTablesQuery, ListAbstractionTablesQueryVariables>(ListAbstractionTablesDocument, baseOptions);
        }
export type ListAbstractionTablesQueryHookResult = ReturnType<typeof useListAbstractionTablesQuery>;
export type ListAbstractionTablesLazyQueryHookResult = ReturnType<typeof useListAbstractionTablesLazyQuery>;
export type ListAbstractionTablesQueryResult = Apollo.QueryResult<ListAbstractionTablesQuery, ListAbstractionTablesQueryVariables>;
export const ListAbstractionsDocument = gql`
    query ListAbstractions($dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $filter_blockchains: jsonb_comparison_exp!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "abstraction"}, dataset_id: {_eq: $dataset_id}, blockchains: $filter_blockchains, _and: $search_terms}
    order_by: [{abstraction_type: desc}, {namespace: asc}, {blockchains: asc}]
    distinct_on: [abstraction_type, namespace, blockchains]
    limit: 50
    offset: $offset
  ) {
    id
    namespace
    abstraction_type
    blockchains
  }
}
    `;

/**
 * __useListAbstractionsQuery__
 *
 * To run a query within a React component, call `useListAbstractionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListAbstractionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListAbstractionsQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      filter_blockchains: // value for 'filter_blockchains'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListAbstractionsQuery(baseOptions: Apollo.QueryHookOptions<ListAbstractionsQuery, ListAbstractionsQueryVariables>) {
        return Apollo.useQuery<ListAbstractionsQuery, ListAbstractionsQueryVariables>(ListAbstractionsDocument, baseOptions);
      }
export function useListAbstractionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListAbstractionsQuery, ListAbstractionsQueryVariables>) {
          return Apollo.useLazyQuery<ListAbstractionsQuery, ListAbstractionsQueryVariables>(ListAbstractionsDocument, baseOptions);
        }
export type ListAbstractionsQueryHookResult = ReturnType<typeof useListAbstractionsQuery>;
export type ListAbstractionsLazyQueryHookResult = ReturnType<typeof useListAbstractionsLazyQuery>;
export type ListAbstractionsQueryResult = Apollo.QueryResult<ListAbstractionsQuery, ListAbstractionsQueryVariables>;
export const ListContractsForSchemaDocument = gql`
    query ListContractsForSchema($namespace: String!, $dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $filter_blockchains: jsonb_comparison_exp!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "decoded_project"}, namespace: {_eq: $namespace}, dataset_id: {_eq: $dataset_id}, blockchains: $filter_blockchains, _and: $search_terms}
    order_by: [{blockchains: asc}, {contract_name: asc}]
    distinct_on: [contract_name, blockchains]
    limit: 50
    offset: $offset
  ) {
    contract_name
    blockchains
  }
  distinct_by_blockchains: arrakis_schemas(
    where: {category: {_eq: "decoded_project"}, namespace: {_eq: $namespace}, dataset_id: {_eq: $dataset_id}}
    order_by: [{blockchains: asc}]
    distinct_on: [blockchains]
    limit: 50
  ) {
    blockchains
  }
}
    `;

/**
 * __useListContractsForSchemaQuery__
 *
 * To run a query within a React component, call `useListContractsForSchemaQuery` and pass it any options that fit your needs.
 * When your component renders, `useListContractsForSchemaQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListContractsForSchemaQuery({
 *   variables: {
 *      namespace: // value for 'namespace'
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      filter_blockchains: // value for 'filter_blockchains'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListContractsForSchemaQuery(baseOptions: Apollo.QueryHookOptions<ListContractsForSchemaQuery, ListContractsForSchemaQueryVariables>) {
        return Apollo.useQuery<ListContractsForSchemaQuery, ListContractsForSchemaQueryVariables>(ListContractsForSchemaDocument, baseOptions);
      }
export function useListContractsForSchemaLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListContractsForSchemaQuery, ListContractsForSchemaQueryVariables>) {
          return Apollo.useLazyQuery<ListContractsForSchemaQuery, ListContractsForSchemaQueryVariables>(ListContractsForSchemaDocument, baseOptions);
        }
export type ListContractsForSchemaQueryHookResult = ReturnType<typeof useListContractsForSchemaQuery>;
export type ListContractsForSchemaLazyQueryHookResult = ReturnType<typeof useListContractsForSchemaLazyQuery>;
export type ListContractsForSchemaQueryResult = Apollo.QueryResult<ListContractsForSchemaQuery, ListContractsForSchemaQueryVariables>;
export const ListDecodedProjectsDocument = gql`
    query ListDecodedProjects($dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $filter_blockchains: jsonb_comparison_exp!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "decoded_project"}, dataset_id: {_eq: $dataset_id}, blockchains: $filter_blockchains, _and: $search_terms}
    order_by: [{namespace: asc}, {blockchains: asc}]
    distinct_on: [namespace, blockchains]
    limit: 50
    offset: $offset
  ) {
    namespace
    blockchains
  }
}
    `;

/**
 * __useListDecodedProjectsQuery__
 *
 * To run a query within a React component, call `useListDecodedProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListDecodedProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListDecodedProjectsQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      filter_blockchains: // value for 'filter_blockchains'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListDecodedProjectsQuery(baseOptions: Apollo.QueryHookOptions<ListDecodedProjectsQuery, ListDecodedProjectsQueryVariables>) {
        return Apollo.useQuery<ListDecodedProjectsQuery, ListDecodedProjectsQueryVariables>(ListDecodedProjectsDocument, baseOptions);
      }
export function useListDecodedProjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListDecodedProjectsQuery, ListDecodedProjectsQueryVariables>) {
          return Apollo.useLazyQuery<ListDecodedProjectsQuery, ListDecodedProjectsQueryVariables>(ListDecodedProjectsDocument, baseOptions);
        }
export type ListDecodedProjectsQueryHookResult = ReturnType<typeof useListDecodedProjectsQuery>;
export type ListDecodedProjectsLazyQueryHookResult = ReturnType<typeof useListDecodedProjectsLazyQuery>;
export type ListDecodedProjectsQueryResult = Apollo.QueryResult<ListDecodedProjectsQuery, ListDecodedProjectsQueryVariables>;
export const FindDecodedTableDetailDocument = gql`
    query FindDecodedTableDetail($namespace: String!, $contract_name: String!, $abi: String!, $blockchains_filter: jsonb_comparison_exp!, $dataset_id: Int!) {
  arrakis_schemas(
    where: {category: {_eq: "decoded_project"}, namespace: {_eq: $namespace}, contract_name: {_eq: $contract_name}, abi_name: {_eq: $abi}, blockchains: $blockchains_filter, dataset_id: {_eq: $dataset_id}}
  ) {
    id
    abi_type
    table_name
    column_name
    data_type
    full_name
    blockchains
  }
}
    `;

/**
 * __useFindDecodedTableDetailQuery__
 *
 * To run a query within a React component, call `useFindDecodedTableDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindDecodedTableDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindDecodedTableDetailQuery({
 *   variables: {
 *      namespace: // value for 'namespace'
 *      contract_name: // value for 'contract_name'
 *      abi: // value for 'abi'
 *      blockchains_filter: // value for 'blockchains_filter'
 *      dataset_id: // value for 'dataset_id'
 *   },
 * });
 */
export function useFindDecodedTableDetailQuery(baseOptions: Apollo.QueryHookOptions<FindDecodedTableDetailQuery, FindDecodedTableDetailQueryVariables>) {
        return Apollo.useQuery<FindDecodedTableDetailQuery, FindDecodedTableDetailQueryVariables>(FindDecodedTableDetailDocument, baseOptions);
      }
export function useFindDecodedTableDetailLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindDecodedTableDetailQuery, FindDecodedTableDetailQueryVariables>) {
          return Apollo.useLazyQuery<FindDecodedTableDetailQuery, FindDecodedTableDetailQueryVariables>(FindDecodedTableDetailDocument, baseOptions);
        }
export type FindDecodedTableDetailQueryHookResult = ReturnType<typeof useFindDecodedTableDetailQuery>;
export type FindDecodedTableDetailLazyQueryHookResult = ReturnType<typeof useFindDecodedTableDetailLazyQuery>;
export type FindDecodedTableDetailQueryResult = Apollo.QueryResult<FindDecodedTableDetailQuery, FindDecodedTableDetailQueryVariables>;
export const ListEssentialTablesDocument = gql`
    query ListEssentialTables($dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $full_names: [String!]!, $filter_blockchains: jsonb_comparison_exp!, $offset: Int) {
  arrakis_schemas(
    where: {dataset_id: {_eq: $dataset_id}, blockchains: $filter_blockchains, full_name: {_in: $full_names}, _and: $search_terms}
    order_by: [{namespace: asc}, {table_name: asc}]
    distinct_on: [namespace, table_name]
    limit: 50
    offset: $offset
  ) {
    id
    category
    namespace
    table_name
    full_name
    blockchains
  }
}
    `;

/**
 * __useListEssentialTablesQuery__
 *
 * To run a query within a React component, call `useListEssentialTablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListEssentialTablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListEssentialTablesQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      full_names: // value for 'full_names'
 *      filter_blockchains: // value for 'filter_blockchains'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListEssentialTablesQuery(baseOptions: Apollo.QueryHookOptions<ListEssentialTablesQuery, ListEssentialTablesQueryVariables>) {
        return Apollo.useQuery<ListEssentialTablesQuery, ListEssentialTablesQueryVariables>(ListEssentialTablesDocument, baseOptions);
      }
export function useListEssentialTablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListEssentialTablesQuery, ListEssentialTablesQueryVariables>) {
          return Apollo.useLazyQuery<ListEssentialTablesQuery, ListEssentialTablesQueryVariables>(ListEssentialTablesDocument, baseOptions);
        }
export type ListEssentialTablesQueryHookResult = ReturnType<typeof useListEssentialTablesQuery>;
export type ListEssentialTablesLazyQueryHookResult = ReturnType<typeof useListEssentialTablesLazyQuery>;
export type ListEssentialTablesQueryResult = Apollo.QueryResult<ListEssentialTablesQuery, ListEssentialTablesQueryVariables>;
export const HomeSearchDocument = gql`
    query HomeSearch($dataset_id: Int!, $search_all: [arrakis_schemas_bool_exp!]!, $search_tables: [arrakis_schemas_bool_exp!]!, $search_projects: [arrakis_schemas_bool_exp!]!, $search_contracts: [arrakis_schemas_bool_exp!]!, $search_abis: [arrakis_schemas_bool_exp!]!) {
  tables: arrakis_schemas(
    where: {dataset_id: {_eq: $dataset_id}, _and: [{_and: $search_all}, {_or: $search_tables}, {_or: [{category: {_eq: "canonical"}}, {category: {_eq: "abstraction"}}, {category: {_eq: "third_party_data"}}]}]}
    limit: 50
    distinct_on: [namespace, table_name, blockchains]
  ) {
    namespace
    table_name
    category
    full_name
    blockchains
  }
  projects: arrakis_schemas(
    where: {dataset_id: {_eq: $dataset_id}, category: {_eq: "decoded_project"}, _and: $search_all, _or: $search_projects}
    limit: 50
    distinct_on: [namespace, blockchains]
  ) {
    namespace
    blockchains
  }
  contracts: arrakis_schemas(
    where: {dataset_id: {_eq: $dataset_id}, category: {_eq: "decoded_project"}, _and: $search_all, _or: $search_contracts}
    limit: 50
    distinct_on: [namespace, contract_name, blockchains]
  ) {
    namespace
    contract_name
    blockchains
  }
  abis: arrakis_schemas(
    where: {dataset_id: {_eq: $dataset_id}, category: {_eq: "decoded_project"}, _and: $search_all, _or: $search_abis}
    limit: 50
    distinct_on: [namespace, contract_name, abi_name, blockchains]
  ) {
    namespace
    contract_name
    abi_name
    abi_type
    full_name
    blockchains
  }
}
    `;

/**
 * __useHomeSearchQuery__
 *
 * To run a query within a React component, call `useHomeSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeSearchQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      search_all: // value for 'search_all'
 *      search_tables: // value for 'search_tables'
 *      search_projects: // value for 'search_projects'
 *      search_contracts: // value for 'search_contracts'
 *      search_abis: // value for 'search_abis'
 *   },
 * });
 */
export function useHomeSearchQuery(baseOptions: Apollo.QueryHookOptions<HomeSearchQuery, HomeSearchQueryVariables>) {
        return Apollo.useQuery<HomeSearchQuery, HomeSearchQueryVariables>(HomeSearchDocument, baseOptions);
      }
export function useHomeSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomeSearchQuery, HomeSearchQueryVariables>) {
          return Apollo.useLazyQuery<HomeSearchQuery, HomeSearchQueryVariables>(HomeSearchDocument, baseOptions);
        }
export type HomeSearchQueryHookResult = ReturnType<typeof useHomeSearchQuery>;
export type HomeSearchLazyQueryHookResult = ReturnType<typeof useHomeSearchLazyQuery>;
export type HomeSearchQueryResult = Apollo.QueryResult<HomeSearchQuery, HomeSearchQueryVariables>;
export const SearchContractsDocument = gql`
    query searchContracts($contract_address: String!) {
  search_contracts(contract_address: $contract_address) {
    projects {
      namespace
      blockchains
    }
  }
}
    `;

/**
 * __useSearchContractsQuery__
 *
 * To run a query within a React component, call `useSearchContractsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchContractsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchContractsQuery({
 *   variables: {
 *      contract_address: // value for 'contract_address'
 *   },
 * });
 */
export function useSearchContractsQuery(baseOptions: Apollo.QueryHookOptions<SearchContractsQuery, SearchContractsQueryVariables>) {
        return Apollo.useQuery<SearchContractsQuery, SearchContractsQueryVariables>(SearchContractsDocument, baseOptions);
      }
export function useSearchContractsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchContractsQuery, SearchContractsQueryVariables>) {
          return Apollo.useLazyQuery<SearchContractsQuery, SearchContractsQueryVariables>(SearchContractsDocument, baseOptions);
        }
export type SearchContractsQueryHookResult = ReturnType<typeof useSearchContractsQuery>;
export type SearchContractsLazyQueryHookResult = ReturnType<typeof useSearchContractsLazyQuery>;
export type SearchContractsQueryResult = Apollo.QueryResult<SearchContractsQuery, SearchContractsQueryVariables>;
export const ListMaterializedViewsDocument = gql`
    query ListMaterializedViews($offset: Int) {
  queries(where: {matview_id: {_is_null: false}}, offset: $offset) {
    name
  }
}
    `;

/**
 * __useListMaterializedViewsQuery__
 *
 * To run a query within a React component, call `useListMaterializedViewsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListMaterializedViewsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListMaterializedViewsQuery({
 *   variables: {
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListMaterializedViewsQuery(baseOptions?: Apollo.QueryHookOptions<ListMaterializedViewsQuery, ListMaterializedViewsQueryVariables>) {
        return Apollo.useQuery<ListMaterializedViewsQuery, ListMaterializedViewsQueryVariables>(ListMaterializedViewsDocument, baseOptions);
      }
export function useListMaterializedViewsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListMaterializedViewsQuery, ListMaterializedViewsQueryVariables>) {
          return Apollo.useLazyQuery<ListMaterializedViewsQuery, ListMaterializedViewsQueryVariables>(ListMaterializedViewsDocument, baseOptions);
        }
export type ListMaterializedViewsQueryHookResult = ReturnType<typeof useListMaterializedViewsQuery>;
export type ListMaterializedViewsLazyQueryHookResult = ReturnType<typeof useListMaterializedViewsLazyQuery>;
export type ListMaterializedViewsQueryResult = Apollo.QueryResult<ListMaterializedViewsQuery, ListMaterializedViewsQueryVariables>;
export const ListRawTablesDocument = gql`
    query ListRawTables($dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $filter_blockchains: jsonb_comparison_exp!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "canonical"}, dataset_id: {_eq: $dataset_id}, blockchains: $filter_blockchains, _and: $search_terms}
    order_by: [{namespace: asc}, {table_name: asc}]
    distinct_on: [namespace, table_name]
    limit: 50
    offset: $offset
  ) {
    id
    namespace
    table_name
    full_name
    blockchains
  }
}
    `;

/**
 * __useListRawTablesQuery__
 *
 * To run a query within a React component, call `useListRawTablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListRawTablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListRawTablesQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      filter_blockchains: // value for 'filter_blockchains'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListRawTablesQuery(baseOptions: Apollo.QueryHookOptions<ListRawTablesQuery, ListRawTablesQueryVariables>) {
        return Apollo.useQuery<ListRawTablesQuery, ListRawTablesQueryVariables>(ListRawTablesDocument, baseOptions);
      }
export function useListRawTablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListRawTablesQuery, ListRawTablesQueryVariables>) {
          return Apollo.useLazyQuery<ListRawTablesQuery, ListRawTablesQueryVariables>(ListRawTablesDocument, baseOptions);
        }
export type ListRawTablesQueryHookResult = ReturnType<typeof useListRawTablesQuery>;
export type ListRawTablesLazyQueryHookResult = ReturnType<typeof useListRawTablesLazyQuery>;
export type ListRawTablesQueryResult = Apollo.QueryResult<ListRawTablesQuery, ListRawTablesQueryVariables>;
export const FindTableDetailDocument = gql`
    query FindTableDetail($category: String!, $namespace: String!, $table_name: String!, $blockchains_filter: jsonb_comparison_exp!, $dataset_id: Int!) {
  arrakis_schemas(
    where: {category: {_eq: $category}, table_name: {_eq: $table_name}, namespace: {_eq: $namespace}, blockchains: $blockchains_filter, dataset_id: {_eq: $dataset_id}}
  ) {
    id
    column_name
    data_type
    full_name
    blockchains
  }
}
    `;

/**
 * __useFindTableDetailQuery__
 *
 * To run a query within a React component, call `useFindTableDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindTableDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindTableDetailQuery({
 *   variables: {
 *      category: // value for 'category'
 *      namespace: // value for 'namespace'
 *      table_name: // value for 'table_name'
 *      blockchains_filter: // value for 'blockchains_filter'
 *      dataset_id: // value for 'dataset_id'
 *   },
 * });
 */
export function useFindTableDetailQuery(baseOptions: Apollo.QueryHookOptions<FindTableDetailQuery, FindTableDetailQueryVariables>) {
        return Apollo.useQuery<FindTableDetailQuery, FindTableDetailQueryVariables>(FindTableDetailDocument, baseOptions);
      }
export function useFindTableDetailLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindTableDetailQuery, FindTableDetailQueryVariables>) {
          return Apollo.useLazyQuery<FindTableDetailQuery, FindTableDetailQueryVariables>(FindTableDetailDocument, baseOptions);
        }
export type FindTableDetailQueryHookResult = ReturnType<typeof useFindTableDetailQuery>;
export type FindTableDetailLazyQueryHookResult = ReturnType<typeof useFindTableDetailLazyQuery>;
export type FindTableDetailQueryResult = Apollo.QueryResult<FindTableDetailQuery, FindTableDetailQueryVariables>;
export const GetTablePreviewDocument = gql`
    mutation GetTablePreview($table: String!) {
  get_table_preview(table: $table) {
    job_id
    result_id
    error_id
    query_id
    parameters {
      key
      type
      value
    }
  }
}
    `;
export type GetTablePreviewMutationFn = Apollo.MutationFunction<GetTablePreviewMutation, GetTablePreviewMutationVariables>;

/**
 * __useGetTablePreviewMutation__
 *
 * To run a mutation, you first call `useGetTablePreviewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetTablePreviewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getTablePreviewMutation, { data, loading, error }] = useGetTablePreviewMutation({
 *   variables: {
 *      table: // value for 'table'
 *   },
 * });
 */
export function useGetTablePreviewMutation(baseOptions?: Apollo.MutationHookOptions<GetTablePreviewMutation, GetTablePreviewMutationVariables>) {
        return Apollo.useMutation<GetTablePreviewMutation, GetTablePreviewMutationVariables>(GetTablePreviewDocument, baseOptions);
      }
export type GetTablePreviewMutationHookResult = ReturnType<typeof useGetTablePreviewMutation>;
export type GetTablePreviewMutationResult = Apollo.MutationResult<GetTablePreviewMutation>;
export type GetTablePreviewMutationOptions = Apollo.BaseMutationOptions<GetTablePreviewMutation, GetTablePreviewMutationVariables>;
export const ListThirdPartiesDocument = gql`
    query ListThirdParties($dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "third_party_data"}, dataset_id: {_eq: $dataset_id}, _and: $search_terms}
    order_by: [{namespace: asc}, {blockchains: asc}]
    distinct_on: [namespace, blockchains]
    limit: 50
    offset: $offset
  ) {
    id
    namespace
    blockchains
  }
}
    `;

/**
 * __useListThirdPartiesQuery__
 *
 * To run a query within a React component, call `useListThirdPartiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListThirdPartiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListThirdPartiesQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListThirdPartiesQuery(baseOptions: Apollo.QueryHookOptions<ListThirdPartiesQuery, ListThirdPartiesQueryVariables>) {
        return Apollo.useQuery<ListThirdPartiesQuery, ListThirdPartiesQueryVariables>(ListThirdPartiesDocument, baseOptions);
      }
export function useListThirdPartiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListThirdPartiesQuery, ListThirdPartiesQueryVariables>) {
          return Apollo.useLazyQuery<ListThirdPartiesQuery, ListThirdPartiesQueryVariables>(ListThirdPartiesDocument, baseOptions);
        }
export type ListThirdPartiesQueryHookResult = ReturnType<typeof useListThirdPartiesQuery>;
export type ListThirdPartiesLazyQueryHookResult = ReturnType<typeof useListThirdPartiesLazyQuery>;
export type ListThirdPartiesQueryResult = Apollo.QueryResult<ListThirdPartiesQuery, ListThirdPartiesQueryVariables>;
export const ListThirdPartyTablesDocument = gql`
    query ListThirdPartyTables($namespace: String!, $dataset_id: Int!, $search_terms: [arrakis_schemas_bool_exp!]!, $offset: Int) {
  arrakis_schemas(
    where: {category: {_eq: "third_party_data"}, namespace: {_eq: $namespace}, dataset_id: {_eq: $dataset_id}, _and: $search_terms}
    order_by: [{blockchains: asc}, {table_name: asc}]
    distinct_on: [table_name, blockchains]
    limit: 50
    offset: $offset
  ) {
    table_name
    full_name
    blockchains
  }
  distinct_by_blockchains: arrakis_schemas(
    where: {category: {_eq: "third_party_data"}, namespace: {_eq: $namespace}, dataset_id: {_eq: $dataset_id}}
    order_by: [{blockchains: asc}]
    distinct_on: [blockchains]
    limit: 50
  ) {
    blockchains
  }
}
    `;

/**
 * __useListThirdPartyTablesQuery__
 *
 * To run a query within a React component, call `useListThirdPartyTablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListThirdPartyTablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListThirdPartyTablesQuery({
 *   variables: {
 *      namespace: // value for 'namespace'
 *      dataset_id: // value for 'dataset_id'
 *      search_terms: // value for 'search_terms'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListThirdPartyTablesQuery(baseOptions: Apollo.QueryHookOptions<ListThirdPartyTablesQuery, ListThirdPartyTablesQueryVariables>) {
        return Apollo.useQuery<ListThirdPartyTablesQuery, ListThirdPartyTablesQueryVariables>(ListThirdPartyTablesDocument, baseOptions);
      }
export function useListThirdPartyTablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListThirdPartyTablesQuery, ListThirdPartyTablesQueryVariables>) {
          return Apollo.useLazyQuery<ListThirdPartyTablesQuery, ListThirdPartyTablesQueryVariables>(ListThirdPartyTablesDocument, baseOptions);
        }
export type ListThirdPartyTablesQueryHookResult = ReturnType<typeof useListThirdPartyTablesQuery>;
export type ListThirdPartyTablesLazyQueryHookResult = ReturnType<typeof useListThirdPartyTablesLazyQuery>;
export type ListThirdPartyTablesQueryResult = Apollo.QueryResult<ListThirdPartyTablesQuery, ListThirdPartyTablesQueryVariables>;
export const GetQueriesDocument = gql`
    query GetQueries($filter_name: String_comparison_exp, $filter_is_private: Boolean_comparison_exp, $filter_custom: [queries_bool_exp!], $is_archived: Boolean!, $order: [queries_order_by!], $limit: Int!, $offset: Int!) {
  queries(
    where: {is_temp: {_eq: false}, is_archived: {_eq: $is_archived}, name: $filter_name, is_private: $filter_is_private, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...QueryExplorerQueryItem
  }
}
    ${QueryExplorerQueryItemFragmentDoc}`;

/**
 * __useGetQueriesQuery__
 *
 * To run a query within a React component, call `useGetQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQueriesQuery({
 *   variables: {
 *      filter_name: // value for 'filter_name'
 *      filter_is_private: // value for 'filter_is_private'
 *      filter_custom: // value for 'filter_custom'
 *      is_archived: // value for 'is_archived'
 *      order: // value for 'order'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetQueriesQuery(baseOptions: Apollo.QueryHookOptions<GetQueriesQuery, GetQueriesQueryVariables>) {
        return Apollo.useQuery<GetQueriesQuery, GetQueriesQueryVariables>(GetQueriesDocument, baseOptions);
      }
export function useGetQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQueriesQuery, GetQueriesQueryVariables>) {
          return Apollo.useLazyQuery<GetQueriesQuery, GetQueriesQueryVariables>(GetQueriesDocument, baseOptions);
        }
export type GetQueriesQueryHookResult = ReturnType<typeof useGetQueriesQuery>;
export type GetQueriesLazyQueryHookResult = ReturnType<typeof useGetQueriesLazyQuery>;
export type GetQueriesQueryResult = Apollo.QueryResult<GetQueriesQuery, GetQueriesQueryVariables>;
export const GetOwnerInfoDocument = gql`
    query GetOwnerInfo($userIds: [Int!]!, $teamIds: [Int!]!) {
  users(where: {id: {_in: $userIds}}) {
    id
    handle: name
    profile_image_url
  }
  teams(where: {id: {_in: $teamIds}}) {
    id
    handle
    profile_image_url
  }
}
    `;

/**
 * __useGetOwnerInfoQuery__
 *
 * To run a query within a React component, call `useGetOwnerInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOwnerInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOwnerInfoQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *      teamIds: // value for 'teamIds'
 *   },
 * });
 */
export function useGetOwnerInfoQuery(baseOptions: Apollo.QueryHookOptions<GetOwnerInfoQuery, GetOwnerInfoQueryVariables>) {
        return Apollo.useQuery<GetOwnerInfoQuery, GetOwnerInfoQueryVariables>(GetOwnerInfoDocument, baseOptions);
      }
export function useGetOwnerInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOwnerInfoQuery, GetOwnerInfoQueryVariables>) {
          return Apollo.useLazyQuery<GetOwnerInfoQuery, GetOwnerInfoQueryVariables>(GetOwnerInfoDocument, baseOptions);
        }
export type GetOwnerInfoQueryHookResult = ReturnType<typeof useGetOwnerInfoQuery>;
export type GetOwnerInfoLazyQueryHookResult = ReturnType<typeof useGetOwnerInfoLazyQuery>;
export type GetOwnerInfoQueryResult = Apollo.QueryResult<GetOwnerInfoQuery, GetOwnerInfoQueryVariables>;
export const GetInitialQueryEventDocument = gql`
    query GetInitialQueryEvent($query_id: Int!) {
  get_initial_query_event(query_id: $query_id) {
    id
    user_id
    team_id
    query_version
    from
    to
    type
    created_at
    metadata {
      name
      description
    }
  }
}
    `;

/**
 * __useGetInitialQueryEventQuery__
 *
 * To run a query within a React component, call `useGetInitialQueryEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInitialQueryEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInitialQueryEventQuery({
 *   variables: {
 *      query_id: // value for 'query_id'
 *   },
 * });
 */
export function useGetInitialQueryEventQuery(baseOptions: Apollo.QueryHookOptions<GetInitialQueryEventQuery, GetInitialQueryEventQueryVariables>) {
        return Apollo.useQuery<GetInitialQueryEventQuery, GetInitialQueryEventQueryVariables>(GetInitialQueryEventDocument, baseOptions);
      }
export function useGetInitialQueryEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInitialQueryEventQuery, GetInitialQueryEventQueryVariables>) {
          return Apollo.useLazyQuery<GetInitialQueryEventQuery, GetInitialQueryEventQueryVariables>(GetInitialQueryEventDocument, baseOptions);
        }
export type GetInitialQueryEventQueryHookResult = ReturnType<typeof useGetInitialQueryEventQuery>;
export type GetInitialQueryEventLazyQueryHookResult = ReturnType<typeof useGetInitialQueryEventLazyQuery>;
export type GetInitialQueryEventQueryResult = Apollo.QueryResult<GetInitialQueryEventQuery, GetInitialQueryEventQueryVariables>;
export const GetQueryEventsDocument = gql`
    query GetQueryEvents($query_id: Int!, $limit: Int!, $offset: Int!) {
  get_query_events(query_id: $query_id, limit: $limit, offset: $offset) {
    results {
      id
      user_id
      team_id
      query_version
      from
      to
      type
      created_at
      metadata {
        name
        description
      }
    }
    past_retention_window
    retention_days
  }
}
    `;

/**
 * __useGetQueryEventsQuery__
 *
 * To run a query within a React component, call `useGetQueryEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQueryEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQueryEventsQuery({
 *   variables: {
 *      query_id: // value for 'query_id'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetQueryEventsQuery(baseOptions: Apollo.QueryHookOptions<GetQueryEventsQuery, GetQueryEventsQueryVariables>) {
        return Apollo.useQuery<GetQueryEventsQuery, GetQueryEventsQueryVariables>(GetQueryEventsDocument, baseOptions);
      }
export function useGetQueryEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQueryEventsQuery, GetQueryEventsQueryVariables>) {
          return Apollo.useLazyQuery<GetQueryEventsQuery, GetQueryEventsQueryVariables>(GetQueryEventsDocument, baseOptions);
        }
export type GetQueryEventsQueryHookResult = ReturnType<typeof useGetQueryEventsQuery>;
export type GetQueryEventsLazyQueryHookResult = ReturnType<typeof useGetQueryEventsLazyQuery>;
export type GetQueryEventsQueryResult = Apollo.QueryResult<GetQueryEventsQuery, GetQueryEventsQueryVariables>;
export const ForkQueryV3Document = gql`
    mutation ForkQueryV3($queryId: Int!, $contextOwner: ContextOwner!) {
  fork_query_v3(query_id: $queryId, forkTo: $contextOwner) {
    query_id
  }
}
    `;
export type ForkQueryV3MutationFn = Apollo.MutationFunction<ForkQueryV3Mutation, ForkQueryV3MutationVariables>;

/**
 * __useForkQueryV3Mutation__
 *
 * To run a mutation, you first call `useForkQueryV3Mutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useForkQueryV3Mutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [forkQueryV3Mutation, { data, loading, error }] = useForkQueryV3Mutation({
 *   variables: {
 *      queryId: // value for 'queryId'
 *      contextOwner: // value for 'contextOwner'
 *   },
 * });
 */
export function useForkQueryV3Mutation(baseOptions?: Apollo.MutationHookOptions<ForkQueryV3Mutation, ForkQueryV3MutationVariables>) {
        return Apollo.useMutation<ForkQueryV3Mutation, ForkQueryV3MutationVariables>(ForkQueryV3Document, baseOptions);
      }
export type ForkQueryV3MutationHookResult = ReturnType<typeof useForkQueryV3Mutation>;
export type ForkQueryV3MutationResult = Apollo.MutationResult<ForkQueryV3Mutation>;
export type ForkQueryV3MutationOptions = Apollo.BaseMutationOptions<ForkQueryV3Mutation, ForkQueryV3MutationVariables>;
export const GetQueryContributorsDocument = gql`
    query GetQueryContributors($queryId: Int!) {
  get_query_contributors(query_id: $queryId) {
    contributors {
      handle
      contributions
      profile_image_url
      query_id
      user_id
    }
  }
}
    `;

/**
 * __useGetQueryContributorsQuery__
 *
 * To run a query within a React component, call `useGetQueryContributorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQueryContributorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQueryContributorsQuery({
 *   variables: {
 *      queryId: // value for 'queryId'
 *   },
 * });
 */
export function useGetQueryContributorsQuery(baseOptions: Apollo.QueryHookOptions<GetQueryContributorsQuery, GetQueryContributorsQueryVariables>) {
        return Apollo.useQuery<GetQueryContributorsQuery, GetQueryContributorsQueryVariables>(GetQueryContributorsDocument, baseOptions);
      }
export function useGetQueryContributorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQueryContributorsQuery, GetQueryContributorsQueryVariables>) {
          return Apollo.useLazyQuery<GetQueryContributorsQuery, GetQueryContributorsQueryVariables>(GetQueryContributorsDocument, baseOptions);
        }
export type GetQueryContributorsQueryHookResult = ReturnType<typeof useGetQueryContributorsQuery>;
export type GetQueryContributorsLazyQueryHookResult = ReturnType<typeof useGetQueryContributorsLazyQuery>;
export type GetQueryContributorsQueryResult = Apollo.QueryResult<GetQueryContributorsQuery, GetQueryContributorsQueryVariables>;
export const CreateQueryScheduleDocument = gql`
    mutation CreateQuerySchedule($query_id: Int!, $cron_expression: String!, $performance: String!) {
  create_query_schedule(
    query_id: $query_id
    cron_expression: $cron_expression
    performance: $performance
  ) {
    query_id
  }
}
    `;
export type CreateQueryScheduleMutationFn = Apollo.MutationFunction<CreateQueryScheduleMutation, CreateQueryScheduleMutationVariables>;

/**
 * __useCreateQueryScheduleMutation__
 *
 * To run a mutation, you first call `useCreateQueryScheduleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateQueryScheduleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createQueryScheduleMutation, { data, loading, error }] = useCreateQueryScheduleMutation({
 *   variables: {
 *      query_id: // value for 'query_id'
 *      cron_expression: // value for 'cron_expression'
 *      performance: // value for 'performance'
 *   },
 * });
 */
export function useCreateQueryScheduleMutation(baseOptions?: Apollo.MutationHookOptions<CreateQueryScheduleMutation, CreateQueryScheduleMutationVariables>) {
        return Apollo.useMutation<CreateQueryScheduleMutation, CreateQueryScheduleMutationVariables>(CreateQueryScheduleDocument, baseOptions);
      }
export type CreateQueryScheduleMutationHookResult = ReturnType<typeof useCreateQueryScheduleMutation>;
export type CreateQueryScheduleMutationResult = Apollo.MutationResult<CreateQueryScheduleMutation>;
export type CreateQueryScheduleMutationOptions = Apollo.BaseMutationOptions<CreateQueryScheduleMutation, CreateQueryScheduleMutationVariables>;
export const DeleteQueryScheduleDocument = gql`
    mutation DeleteQuerySchedule($cron_job_id: String!) {
  delete_query_schedule(cron_job_id: $cron_job_id) {
    cron_job_id
  }
}
    `;
export type DeleteQueryScheduleMutationFn = Apollo.MutationFunction<DeleteQueryScheduleMutation, DeleteQueryScheduleMutationVariables>;

/**
 * __useDeleteQueryScheduleMutation__
 *
 * To run a mutation, you first call `useDeleteQueryScheduleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteQueryScheduleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteQueryScheduleMutation, { data, loading, error }] = useDeleteQueryScheduleMutation({
 *   variables: {
 *      cron_job_id: // value for 'cron_job_id'
 *   },
 * });
 */
export function useDeleteQueryScheduleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteQueryScheduleMutation, DeleteQueryScheduleMutationVariables>) {
        return Apollo.useMutation<DeleteQueryScheduleMutation, DeleteQueryScheduleMutationVariables>(DeleteQueryScheduleDocument, baseOptions);
      }
export type DeleteQueryScheduleMutationHookResult = ReturnType<typeof useDeleteQueryScheduleMutation>;
export type DeleteQueryScheduleMutationResult = Apollo.MutationResult<DeleteQueryScheduleMutation>;
export type DeleteQueryScheduleMutationOptions = Apollo.BaseMutationOptions<DeleteQueryScheduleMutation, DeleteQueryScheduleMutationVariables>;
export const QuerySchedulesDocument = gql`
    query QuerySchedules($query_id: Int!) {
  query_schedules(query_id: $query_id) {
    query_id
    cron_jobs {
      id
      cron_expression
      performance
      owned_by_customer_id
      metadata {
        updated_at
      }
    }
  }
}
    `;

/**
 * __useQuerySchedulesQuery__
 *
 * To run a query within a React component, call `useQuerySchedulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuerySchedulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuerySchedulesQuery({
 *   variables: {
 *      query_id: // value for 'query_id'
 *   },
 * });
 */
export function useQuerySchedulesQuery(baseOptions: Apollo.QueryHookOptions<QuerySchedulesQuery, QuerySchedulesQueryVariables>) {
        return Apollo.useQuery<QuerySchedulesQuery, QuerySchedulesQueryVariables>(QuerySchedulesDocument, baseOptions);
      }
export function useQuerySchedulesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuerySchedulesQuery, QuerySchedulesQueryVariables>) {
          return Apollo.useLazyQuery<QuerySchedulesQuery, QuerySchedulesQueryVariables>(QuerySchedulesDocument, baseOptions);
        }
export type QuerySchedulesQueryHookResult = ReturnType<typeof useQuerySchedulesQuery>;
export type QuerySchedulesLazyQueryHookResult = ReturnType<typeof useQuerySchedulesLazyQuery>;
export type QuerySchedulesQueryResult = Apollo.QueryResult<QuerySchedulesQuery, QuerySchedulesQueryVariables>;
export const UpdateQueryScheduleDocument = gql`
    mutation UpdateQuerySchedule($cron_job_id: String!, $cron_expression: String!, $performance: String!) {
  update_query_schedule(
    cron_job_id: $cron_job_id
    cron_expression: $cron_expression
    performance: $performance
  ) {
    query_id
  }
}
    `;
export type UpdateQueryScheduleMutationFn = Apollo.MutationFunction<UpdateQueryScheduleMutation, UpdateQueryScheduleMutationVariables>;

/**
 * __useUpdateQueryScheduleMutation__
 *
 * To run a mutation, you first call `useUpdateQueryScheduleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateQueryScheduleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateQueryScheduleMutation, { data, loading, error }] = useUpdateQueryScheduleMutation({
 *   variables: {
 *      cron_job_id: // value for 'cron_job_id'
 *      cron_expression: // value for 'cron_expression'
 *      performance: // value for 'performance'
 *   },
 * });
 */
export function useUpdateQueryScheduleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQueryScheduleMutation, UpdateQueryScheduleMutationVariables>) {
        return Apollo.useMutation<UpdateQueryScheduleMutation, UpdateQueryScheduleMutationVariables>(UpdateQueryScheduleDocument, baseOptions);
      }
export type UpdateQueryScheduleMutationHookResult = ReturnType<typeof useUpdateQueryScheduleMutation>;
export type UpdateQueryScheduleMutationResult = Apollo.MutationResult<UpdateQueryScheduleMutation>;
export type UpdateQueryScheduleMutationOptions = Apollo.BaseMutationOptions<UpdateQueryScheduleMutation, UpdateQueryScheduleMutationVariables>;
export const InsertVisualDocument = gql`
    mutation InsertVisual($visual: visualizations_insert_input!) {
  insert_visualizations_one(object: $visual) {
    ...Visualization
  }
}
    ${VisualizationFragmentDoc}`;
export type InsertVisualMutationFn = Apollo.MutationFunction<InsertVisualMutation, InsertVisualMutationVariables>;

/**
 * __useInsertVisualMutation__
 *
 * To run a mutation, you first call `useInsertVisualMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertVisualMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertVisualMutation, { data, loading, error }] = useInsertVisualMutation({
 *   variables: {
 *      visual: // value for 'visual'
 *   },
 * });
 */
export function useInsertVisualMutation(baseOptions?: Apollo.MutationHookOptions<InsertVisualMutation, InsertVisualMutationVariables>) {
        return Apollo.useMutation<InsertVisualMutation, InsertVisualMutationVariables>(InsertVisualDocument, baseOptions);
      }
export type InsertVisualMutationHookResult = ReturnType<typeof useInsertVisualMutation>;
export type InsertVisualMutationResult = Apollo.MutationResult<InsertVisualMutation>;
export type InsertVisualMutationOptions = Apollo.BaseMutationOptions<InsertVisualMutation, InsertVisualMutationVariables>;
export const CreateQueryDocument = gql`
    mutation CreateQuery($query: CreateQueryInput!) {
  create_query(query: $query) {
    query_id
  }
}
    `;
export type CreateQueryMutationFn = Apollo.MutationFunction<CreateQueryMutation, CreateQueryMutationVariables>;

/**
 * __useCreateQueryMutation__
 *
 * To run a mutation, you first call `useCreateQueryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateQueryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createQueryMutation, { data, loading, error }] = useCreateQueryMutation({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useCreateQueryMutation(baseOptions?: Apollo.MutationHookOptions<CreateQueryMutation, CreateQueryMutationVariables>) {
        return Apollo.useMutation<CreateQueryMutation, CreateQueryMutationVariables>(CreateQueryDocument, baseOptions);
      }
export type CreateQueryMutationHookResult = ReturnType<typeof useCreateQueryMutation>;
export type CreateQueryMutationResult = Apollo.MutationResult<CreateQueryMutation>;
export type CreateQueryMutationOptions = Apollo.BaseMutationOptions<CreateQueryMutation, CreateQueryMutationVariables>;
export const UpdateQueryDocument = gql`
    mutation UpdateQuery($query: UpdateQueryInput!) {
  update_query(query: $query) {
    query_id
  }
}
    `;
export type UpdateQueryMutationFn = Apollo.MutationFunction<UpdateQueryMutation, UpdateQueryMutationVariables>;

/**
 * __useUpdateQueryMutation__
 *
 * To run a mutation, you first call `useUpdateQueryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateQueryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateQueryMutation, { data, loading, error }] = useUpdateQueryMutation({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useUpdateQueryMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQueryMutation, UpdateQueryMutationVariables>) {
        return Apollo.useMutation<UpdateQueryMutation, UpdateQueryMutationVariables>(UpdateQueryDocument, baseOptions);
      }
export type UpdateQueryMutationHookResult = ReturnType<typeof useUpdateQueryMutation>;
export type UpdateQueryMutationResult = Apollo.MutationResult<UpdateQueryMutation>;
export type UpdateQueryMutationOptions = Apollo.BaseMutationOptions<UpdateQueryMutation, UpdateQueryMutationVariables>;
export const EditVisualDocument = gql`
    mutation EditVisual($id: Int!, $options: jsonb!, $name: String!, $type: visualization_types!) {
  update_visualizations_by_pk(
    pk_columns: {id: $id}
    _set: {options: $options, name: $name, type: $type}
  ) {
    id
    type
    name
    options
    created_at
  }
}
    `;
export type EditVisualMutationFn = Apollo.MutationFunction<EditVisualMutation, EditVisualMutationVariables>;

/**
 * __useEditVisualMutation__
 *
 * To run a mutation, you first call `useEditVisualMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditVisualMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editVisualMutation, { data, loading, error }] = useEditVisualMutation({
 *   variables: {
 *      id: // value for 'id'
 *      options: // value for 'options'
 *      name: // value for 'name'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useEditVisualMutation(baseOptions?: Apollo.MutationHookOptions<EditVisualMutation, EditVisualMutationVariables>) {
        return Apollo.useMutation<EditVisualMutation, EditVisualMutationVariables>(EditVisualDocument, baseOptions);
      }
export type EditVisualMutationHookResult = ReturnType<typeof useEditVisualMutation>;
export type EditVisualMutationResult = Apollo.MutationResult<EditVisualMutation>;
export type EditVisualMutationOptions = Apollo.BaseMutationOptions<EditVisualMutation, EditVisualMutationVariables>;
export const CancelExecutionDocument = gql`
    mutation CancelExecution($execution_id: String!, $query_id: Int!, $parameters: [Parameter!]!) {
  cancel_execution(
    execution_id: $execution_id
    query_id: $query_id
    parameters: $parameters
  ) {
    execution_id
  }
}
    `;
export type CancelExecutionMutationFn = Apollo.MutationFunction<CancelExecutionMutation, CancelExecutionMutationVariables>;

/**
 * __useCancelExecutionMutation__
 *
 * To run a mutation, you first call `useCancelExecutionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelExecutionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelExecutionMutation, { data, loading, error }] = useCancelExecutionMutation({
 *   variables: {
 *      execution_id: // value for 'execution_id'
 *      query_id: // value for 'query_id'
 *      parameters: // value for 'parameters'
 *   },
 * });
 */
export function useCancelExecutionMutation(baseOptions?: Apollo.MutationHookOptions<CancelExecutionMutation, CancelExecutionMutationVariables>) {
        return Apollo.useMutation<CancelExecutionMutation, CancelExecutionMutationVariables>(CancelExecutionDocument, baseOptions);
      }
export type CancelExecutionMutationHookResult = ReturnType<typeof useCancelExecutionMutation>;
export type CancelExecutionMutationResult = Apollo.MutationResult<CancelExecutionMutation>;
export type CancelExecutionMutationOptions = Apollo.BaseMutationOptions<CancelExecutionMutation, CancelExecutionMutationVariables>;
export const ForkQueryV1Document = gql`
    mutation ForkQueryV1($session_id: Int!, $query_id: Int!) {
  fork_query(user_id: $session_id, query_id: $query_id) {
    query_id
  }
}
    `;
export type ForkQueryV1MutationFn = Apollo.MutationFunction<ForkQueryV1Mutation, ForkQueryV1MutationVariables>;

/**
 * __useForkQueryV1Mutation__
 *
 * To run a mutation, you first call `useForkQueryV1Mutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useForkQueryV1Mutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [forkQueryV1Mutation, { data, loading, error }] = useForkQueryV1Mutation({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      query_id: // value for 'query_id'
 *   },
 * });
 */
export function useForkQueryV1Mutation(baseOptions?: Apollo.MutationHookOptions<ForkQueryV1Mutation, ForkQueryV1MutationVariables>) {
        return Apollo.useMutation<ForkQueryV1Mutation, ForkQueryV1MutationVariables>(ForkQueryV1Document, baseOptions);
      }
export type ForkQueryV1MutationHookResult = ReturnType<typeof useForkQueryV1Mutation>;
export type ForkQueryV1MutationResult = Apollo.MutationResult<ForkQueryV1Mutation>;
export type ForkQueryV1MutationOptions = Apollo.BaseMutationOptions<ForkQueryV1Mutation, ForkQueryV1MutationVariables>;
export const UpdateQueryCodeDocument = gql`
    mutation UpdateQueryCode($query_id: Int!, $code: String!) {
  update_queries_by_pk(pk_columns: {id: $query_id}, _set: {query: $code}) {
    id
  }
}
    `;
export type UpdateQueryCodeMutationFn = Apollo.MutationFunction<UpdateQueryCodeMutation, UpdateQueryCodeMutationVariables>;

/**
 * __useUpdateQueryCodeMutation__
 *
 * To run a mutation, you first call `useUpdateQueryCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateQueryCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateQueryCodeMutation, { data, loading, error }] = useUpdateQueryCodeMutation({
 *   variables: {
 *      query_id: // value for 'query_id'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useUpdateQueryCodeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQueryCodeMutation, UpdateQueryCodeMutationVariables>) {
        return Apollo.useMutation<UpdateQueryCodeMutation, UpdateQueryCodeMutationVariables>(UpdateQueryCodeDocument, baseOptions);
      }
export type UpdateQueryCodeMutationHookResult = ReturnType<typeof useUpdateQueryCodeMutation>;
export type UpdateQueryCodeMutationResult = Apollo.MutationResult<UpdateQueryCodeMutation>;
export type UpdateQueryCodeMutationOptions = Apollo.BaseMutationOptions<UpdateQueryCodeMutation, UpdateQueryCodeMutationVariables>;
export const ExportCsvDocument = gql`
    query ExportCSV($execution_id: String!, $query_id: Int!, $parameters: [Parameter!]!, $downloadFor: ContextOwner!) {
  export_csv(
    execution_id: $execution_id
    query_id: $query_id
    parameters: $parameters
    downloadFor: $downloadFor
  ) {
    url
  }
}
    `;

/**
 * __useExportCsvQuery__
 *
 * To run a query within a React component, call `useExportCsvQuery` and pass it any options that fit your needs.
 * When your component renders, `useExportCsvQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useExportCsvQuery({
 *   variables: {
 *      execution_id: // value for 'execution_id'
 *      query_id: // value for 'query_id'
 *      parameters: // value for 'parameters'
 *      downloadFor: // value for 'downloadFor'
 *   },
 * });
 */
export function useExportCsvQuery(baseOptions: Apollo.QueryHookOptions<ExportCsvQuery, ExportCsvQueryVariables>) {
        return Apollo.useQuery<ExportCsvQuery, ExportCsvQueryVariables>(ExportCsvDocument, baseOptions);
      }
export function useExportCsvLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ExportCsvQuery, ExportCsvQueryVariables>) {
          return Apollo.useLazyQuery<ExportCsvQuery, ExportCsvQueryVariables>(ExportCsvDocument, baseOptions);
        }
export type ExportCsvQueryHookResult = ReturnType<typeof useExportCsvQuery>;
export type ExportCsvLazyQueryHookResult = ReturnType<typeof useExportCsvLazyQuery>;
export type ExportCsvQueryResult = Apollo.QueryResult<ExportCsvQuery, ExportCsvQueryVariables>;
export const DeleteVisualizationDocument = gql`
    mutation DeleteVisualization($visual_id: Int!) {
  delete_visualizations_by_pk(id: $visual_id) {
    id
  }
}
    `;
export type DeleteVisualizationMutationFn = Apollo.MutationFunction<DeleteVisualizationMutation, DeleteVisualizationMutationVariables>;

/**
 * __useDeleteVisualizationMutation__
 *
 * To run a mutation, you first call `useDeleteVisualizationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteVisualizationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteVisualizationMutation, { data, loading, error }] = useDeleteVisualizationMutation({
 *   variables: {
 *      visual_id: // value for 'visual_id'
 *   },
 * });
 */
export function useDeleteVisualizationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteVisualizationMutation, DeleteVisualizationMutationVariables>) {
        return Apollo.useMutation<DeleteVisualizationMutation, DeleteVisualizationMutationVariables>(DeleteVisualizationDocument, baseOptions);
      }
export type DeleteVisualizationMutationHookResult = ReturnType<typeof useDeleteVisualizationMutation>;
export type DeleteVisualizationMutationResult = Apollo.MutationResult<DeleteVisualizationMutation>;
export type DeleteVisualizationMutationOptions = Apollo.BaseMutationOptions<DeleteVisualizationMutation, DeleteVisualizationMutationVariables>;
export const ListDatasetsDocument = gql`
    query ListDatasets {
  datasets(order_by: {name: asc}) {
    id
    name
    type
  }
}
    `;

/**
 * __useListDatasetsQuery__
 *
 * To run a query within a React component, call `useListDatasetsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListDatasetsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListDatasetsQuery({
 *   variables: {
 *   },
 * });
 */
export function useListDatasetsQuery(baseOptions?: Apollo.QueryHookOptions<ListDatasetsQuery, ListDatasetsQueryVariables>) {
        return Apollo.useQuery<ListDatasetsQuery, ListDatasetsQueryVariables>(ListDatasetsDocument, baseOptions);
      }
export function useListDatasetsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListDatasetsQuery, ListDatasetsQueryVariables>) {
          return Apollo.useLazyQuery<ListDatasetsQuery, ListDatasetsQueryVariables>(ListDatasetsDocument, baseOptions);
        }
export type ListDatasetsQueryHookResult = ReturnType<typeof useListDatasetsQuery>;
export type ListDatasetsLazyQueryHookResult = ReturnType<typeof useListDatasetsLazyQuery>;
export type ListDatasetsQueryResult = Apollo.QueryResult<ListDatasetsQuery, ListDatasetsQueryVariables>;
export const ListSchemasDocument = gql`
    query ListSchemas($dataset_id: Int!, $query: [blockchain_schemas_bool_exp!]!, $offset: Int!, $limit: Int!) {
  blockchain_schemas(
    where: {dataset_id: {_eq: $dataset_id}, _and: $query}
    order_by: [{schema: asc}, {table: asc}]
    distinct_on: [schema, table]
    offset: $offset
    limit: $limit
  ) {
    schema
    table
  }
}
    `;

/**
 * __useListSchemasQuery__
 *
 * To run a query within a React component, call `useListSchemasQuery` and pass it any options that fit your needs.
 * When your component renders, `useListSchemasQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListSchemasQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      query: // value for 'query'
 *      offset: // value for 'offset'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useListSchemasQuery(baseOptions: Apollo.QueryHookOptions<ListSchemasQuery, ListSchemasQueryVariables>) {
        return Apollo.useQuery<ListSchemasQuery, ListSchemasQueryVariables>(ListSchemasDocument, baseOptions);
      }
export function useListSchemasLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListSchemasQuery, ListSchemasQueryVariables>) {
          return Apollo.useLazyQuery<ListSchemasQuery, ListSchemasQueryVariables>(ListSchemasDocument, baseOptions);
        }
export type ListSchemasQueryHookResult = ReturnType<typeof useListSchemasQuery>;
export type ListSchemasLazyQueryHookResult = ReturnType<typeof useListSchemasLazyQuery>;
export type ListSchemasQueryResult = Apollo.QueryResult<ListSchemasQuery, ListSchemasQueryVariables>;
export const ListColumnsDocument = gql`
    query ListColumns($dataset_id: Int!, $schema: String!, $table: String!, $limit: Int!) {
  blockchain_schemas(
    where: {dataset_id: {_eq: $dataset_id}, schema: {_eq: $schema}, table: {_eq: $table}}
    order_by: {column_name: asc}
    limit: $limit
  ) {
    column_name
    data_type
  }
}
    `;

/**
 * __useListColumnsQuery__
 *
 * To run a query within a React component, call `useListColumnsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListColumnsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListColumnsQuery({
 *   variables: {
 *      dataset_id: // value for 'dataset_id'
 *      schema: // value for 'schema'
 *      table: // value for 'table'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useListColumnsQuery(baseOptions: Apollo.QueryHookOptions<ListColumnsQuery, ListColumnsQueryVariables>) {
        return Apollo.useQuery<ListColumnsQuery, ListColumnsQueryVariables>(ListColumnsDocument, baseOptions);
      }
export function useListColumnsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListColumnsQuery, ListColumnsQueryVariables>) {
          return Apollo.useLazyQuery<ListColumnsQuery, ListColumnsQueryVariables>(ListColumnsDocument, baseOptions);
        }
export type ListColumnsQueryHookResult = ReturnType<typeof useListColumnsQuery>;
export type ListColumnsLazyQueryHookResult = ReturnType<typeof useListColumnsLazyQuery>;
export type ListColumnsQueryResult = Apollo.QueryResult<ListColumnsQuery, ListColumnsQueryVariables>;
export const RestoreQueryDocument = gql`
    mutation RestoreQuery($query_event_id: String!) {
  restore_query(query_event_id: $query_event_id) {
    query_id
  }
}
    `;
export type RestoreQueryMutationFn = Apollo.MutationFunction<RestoreQueryMutation, RestoreQueryMutationVariables>;

/**
 * __useRestoreQueryMutation__
 *
 * To run a mutation, you first call `useRestoreQueryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestoreQueryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restoreQueryMutation, { data, loading, error }] = useRestoreQueryMutation({
 *   variables: {
 *      query_event_id: // value for 'query_event_id'
 *   },
 * });
 */
export function useRestoreQueryMutation(baseOptions?: Apollo.MutationHookOptions<RestoreQueryMutation, RestoreQueryMutationVariables>) {
        return Apollo.useMutation<RestoreQueryMutation, RestoreQueryMutationVariables>(RestoreQueryDocument, baseOptions);
      }
export type RestoreQueryMutationHookResult = ReturnType<typeof useRestoreQueryMutation>;
export type RestoreQueryMutationResult = Apollo.MutationResult<RestoreQueryMutation>;
export type RestoreQueryMutationOptions = Apollo.BaseMutationOptions<RestoreQueryMutation, RestoreQueryMutationVariables>;
export const UpsertQueryEventMetadataDocument = gql`
    mutation UpsertQueryEventMetadata($query_event_id: String!, $metadata: UpsertQueryEventMetadataInput!) {
  upsert_query_event_metadata(
    query_event_id: $query_event_id
    metadata: $metadata
  ) {
    query_event_id
    user_id
    name
    description
    created_at
    updated_at
  }
}
    `;
export type UpsertQueryEventMetadataMutationFn = Apollo.MutationFunction<UpsertQueryEventMetadataMutation, UpsertQueryEventMetadataMutationVariables>;

/**
 * __useUpsertQueryEventMetadataMutation__
 *
 * To run a mutation, you first call `useUpsertQueryEventMetadataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertQueryEventMetadataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertQueryEventMetadataMutation, { data, loading, error }] = useUpsertQueryEventMetadataMutation({
 *   variables: {
 *      query_event_id: // value for 'query_event_id'
 *      metadata: // value for 'metadata'
 *   },
 * });
 */
export function useUpsertQueryEventMetadataMutation(baseOptions?: Apollo.MutationHookOptions<UpsertQueryEventMetadataMutation, UpsertQueryEventMetadataMutationVariables>) {
        return Apollo.useMutation<UpsertQueryEventMetadataMutation, UpsertQueryEventMetadataMutationVariables>(UpsertQueryEventMetadataDocument, baseOptions);
      }
export type UpsertQueryEventMetadataMutationHookResult = ReturnType<typeof useUpsertQueryEventMetadataMutation>;
export type UpsertQueryEventMetadataMutationResult = Apollo.MutationResult<UpsertQueryEventMetadataMutation>;
export type UpsertQueryEventMetadataMutationOptions = Apollo.BaseMutationOptions<UpsertQueryEventMetadataMutation, UpsertQueryEventMetadataMutationVariables>;
export const GetQueryEventDocument = gql`
    query GetQueryEvent($query_event_id: String!) {
  get_query_event(query_event_id: $query_event_id) {
    id
    user_id
    query_version
    from
    to
    type
    created_at
    metadata {
      name
      description
    }
  }
}
    `;

/**
 * __useGetQueryEventQuery__
 *
 * To run a query within a React component, call `useGetQueryEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQueryEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQueryEventQuery({
 *   variables: {
 *      query_event_id: // value for 'query_event_id'
 *   },
 * });
 */
export function useGetQueryEventQuery(baseOptions: Apollo.QueryHookOptions<GetQueryEventQuery, GetQueryEventQueryVariables>) {
        return Apollo.useQuery<GetQueryEventQuery, GetQueryEventQueryVariables>(GetQueryEventDocument, baseOptions);
      }
export function useGetQueryEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQueryEventQuery, GetQueryEventQueryVariables>) {
          return Apollo.useLazyQuery<GetQueryEventQuery, GetQueryEventQueryVariables>(GetQueryEventDocument, baseOptions);
        }
export type GetQueryEventQueryHookResult = ReturnType<typeof useGetQueryEventQuery>;
export type GetQueryEventLazyQueryHookResult = ReturnType<typeof useGetQueryEventLazyQuery>;
export type GetQueryEventQueryResult = Apollo.QueryResult<GetQueryEventQuery, GetQueryEventQueryVariables>;
export const GetUserPrivateQueriesDocument = gql`
    query GetUserPrivateQueries {
  queries_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, is_temp: {_eq: false}, team_id: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetUserPrivateQueriesQuery__
 *
 * To run a query within a React component, call `useGetUserPrivateQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserPrivateQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserPrivateQueriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUserPrivateQueriesQuery(baseOptions?: Apollo.QueryHookOptions<GetUserPrivateQueriesQuery, GetUserPrivateQueriesQueryVariables>) {
        return Apollo.useQuery<GetUserPrivateQueriesQuery, GetUserPrivateQueriesQueryVariables>(GetUserPrivateQueriesDocument, baseOptions);
      }
export function useGetUserPrivateQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserPrivateQueriesQuery, GetUserPrivateQueriesQueryVariables>) {
          return Apollo.useLazyQuery<GetUserPrivateQueriesQuery, GetUserPrivateQueriesQueryVariables>(GetUserPrivateQueriesDocument, baseOptions);
        }
export type GetUserPrivateQueriesQueryHookResult = ReturnType<typeof useGetUserPrivateQueriesQuery>;
export type GetUserPrivateQueriesLazyQueryHookResult = ReturnType<typeof useGetUserPrivateQueriesLazyQuery>;
export type GetUserPrivateQueriesQueryResult = Apollo.QueryResult<GetUserPrivateQueriesQuery, GetUserPrivateQueriesQueryVariables>;
export const GetTeamPrivateQueriesDocument = gql`
    query GetTeamPrivateQueries($teamId: Int!) {
  queries_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, is_temp: {_eq: false}, team_id: {_eq: $teamId}}
  ) {
    aggregate {
      count
    }
  }
  team_members_details(where: {id: {_eq: $teamId}}) {
    id
    service_tier {
      id
      max_private_queries
    }
  }
}
    `;

/**
 * __useGetTeamPrivateQueriesQuery__
 *
 * To run a query within a React component, call `useGetTeamPrivateQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamPrivateQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamPrivateQueriesQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamPrivateQueriesQuery(baseOptions: Apollo.QueryHookOptions<GetTeamPrivateQueriesQuery, GetTeamPrivateQueriesQueryVariables>) {
        return Apollo.useQuery<GetTeamPrivateQueriesQuery, GetTeamPrivateQueriesQueryVariables>(GetTeamPrivateQueriesDocument, baseOptions);
      }
export function useGetTeamPrivateQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamPrivateQueriesQuery, GetTeamPrivateQueriesQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamPrivateQueriesQuery, GetTeamPrivateQueriesQueryVariables>(GetTeamPrivateQueriesDocument, baseOptions);
        }
export type GetTeamPrivateQueriesQueryHookResult = ReturnType<typeof useGetTeamPrivateQueriesQuery>;
export type GetTeamPrivateQueriesLazyQueryHookResult = ReturnType<typeof useGetTeamPrivateQueriesLazyQuery>;
export type GetTeamPrivateQueriesQueryResult = Apollo.QueryResult<GetTeamPrivateQueriesQuery, GetTeamPrivateQueriesQueryVariables>;
export const GetTeamServiceTierDocument = gql`
    query GetTeamServiceTier($teamId: Int!) {
  team_members_details(where: {id: {_eq: $teamId}}) {
    id
    service_tier {
      id
      release_version
    }
  }
}
    `;

/**
 * __useGetTeamServiceTierQuery__
 *
 * To run a query within a React component, call `useGetTeamServiceTierQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamServiceTierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamServiceTierQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamServiceTierQuery(baseOptions: Apollo.QueryHookOptions<GetTeamServiceTierQuery, GetTeamServiceTierQueryVariables>) {
        return Apollo.useQuery<GetTeamServiceTierQuery, GetTeamServiceTierQueryVariables>(GetTeamServiceTierDocument, baseOptions);
      }
export function useGetTeamServiceTierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamServiceTierQuery, GetTeamServiceTierQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamServiceTierQuery, GetTeamServiceTierQueryVariables>(GetTeamServiceTierDocument, baseOptions);
        }
export type GetTeamServiceTierQueryHookResult = ReturnType<typeof useGetTeamServiceTierQuery>;
export type GetTeamServiceTierLazyQueryHookResult = ReturnType<typeof useGetTeamServiceTierLazyQuery>;
export type GetTeamServiceTierQueryResult = Apollo.QueryResult<GetTeamServiceTierQuery, GetTeamServiceTierQueryVariables>;
export const InsertDashboardApiKeyDocument = gql`
    mutation InsertDashboardApiKey($dashboard_id: Int!, $user_id: Int, $team_id: Int) {
  insert_api_keys_one(
    object: {dashboard_id: $dashboard_id, user_id: $user_id, team_id: $team_id}
  ) {
    id
  }
}
    `;
export type InsertDashboardApiKeyMutationFn = Apollo.MutationFunction<InsertDashboardApiKeyMutation, InsertDashboardApiKeyMutationVariables>;

/**
 * __useInsertDashboardApiKeyMutation__
 *
 * To run a mutation, you first call `useInsertDashboardApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertDashboardApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertDashboardApiKeyMutation, { data, loading, error }] = useInsertDashboardApiKeyMutation({
 *   variables: {
 *      dashboard_id: // value for 'dashboard_id'
 *      user_id: // value for 'user_id'
 *      team_id: // value for 'team_id'
 *   },
 * });
 */
export function useInsertDashboardApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<InsertDashboardApiKeyMutation, InsertDashboardApiKeyMutationVariables>) {
        return Apollo.useMutation<InsertDashboardApiKeyMutation, InsertDashboardApiKeyMutationVariables>(InsertDashboardApiKeyDocument, baseOptions);
      }
export type InsertDashboardApiKeyMutationHookResult = ReturnType<typeof useInsertDashboardApiKeyMutation>;
export type InsertDashboardApiKeyMutationResult = Apollo.MutationResult<InsertDashboardApiKeyMutation>;
export type InsertDashboardApiKeyMutationOptions = Apollo.BaseMutationOptions<InsertDashboardApiKeyMutation, InsertDashboardApiKeyMutationVariables>;
export const InsertQueryApiKeyDocument = gql`
    mutation InsertQueryApiKey($query_id: Int!, $user_id: Int, $team_id: Int) {
  insert_api_keys_one(
    object: {query_id: $query_id, user_id: $user_id, team_id: $team_id}
  ) {
    id
  }
}
    `;
export type InsertQueryApiKeyMutationFn = Apollo.MutationFunction<InsertQueryApiKeyMutation, InsertQueryApiKeyMutationVariables>;

/**
 * __useInsertQueryApiKeyMutation__
 *
 * To run a mutation, you first call `useInsertQueryApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertQueryApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertQueryApiKeyMutation, { data, loading, error }] = useInsertQueryApiKeyMutation({
 *   variables: {
 *      query_id: // value for 'query_id'
 *      user_id: // value for 'user_id'
 *      team_id: // value for 'team_id'
 *   },
 * });
 */
export function useInsertQueryApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<InsertQueryApiKeyMutation, InsertQueryApiKeyMutationVariables>) {
        return Apollo.useMutation<InsertQueryApiKeyMutation, InsertQueryApiKeyMutationVariables>(InsertQueryApiKeyDocument, baseOptions);
      }
export type InsertQueryApiKeyMutationHookResult = ReturnType<typeof useInsertQueryApiKeyMutation>;
export type InsertQueryApiKeyMutationResult = Apollo.MutationResult<InsertQueryApiKeyMutation>;
export type InsertQueryApiKeyMutationOptions = Apollo.BaseMutationOptions<InsertQueryApiKeyMutation, InsertQueryApiKeyMutationVariables>;
export const DeleteParamWidgetsDocument = gql`
    mutation DeleteParamWidgets($ids: [param_widgets_bool_exp!]!) {
  delete_param_widgets(where: {_or: $ids}) {
    affected_rows
  }
}
    `;
export type DeleteParamWidgetsMutationFn = Apollo.MutationFunction<DeleteParamWidgetsMutation, DeleteParamWidgetsMutationVariables>;

/**
 * __useDeleteParamWidgetsMutation__
 *
 * To run a mutation, you first call `useDeleteParamWidgetsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteParamWidgetsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteParamWidgetsMutation, { data, loading, error }] = useDeleteParamWidgetsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useDeleteParamWidgetsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteParamWidgetsMutation, DeleteParamWidgetsMutationVariables>) {
        return Apollo.useMutation<DeleteParamWidgetsMutation, DeleteParamWidgetsMutationVariables>(DeleteParamWidgetsDocument, baseOptions);
      }
export type DeleteParamWidgetsMutationHookResult = ReturnType<typeof useDeleteParamWidgetsMutation>;
export type DeleteParamWidgetsMutationResult = Apollo.MutationResult<DeleteParamWidgetsMutation>;
export type DeleteParamWidgetsMutationOptions = Apollo.BaseMutationOptions<DeleteParamWidgetsMutation, DeleteParamWidgetsMutationVariables>;
export const InsertVisualizationWidgetDocument = gql`
    mutation InsertVisualizationWidget($object: visualization_widgets_insert_input!) {
  insert_visualization_widgets_one(object: $object) {
    id
  }
}
    `;
export type InsertVisualizationWidgetMutationFn = Apollo.MutationFunction<InsertVisualizationWidgetMutation, InsertVisualizationWidgetMutationVariables>;

/**
 * __useInsertVisualizationWidgetMutation__
 *
 * To run a mutation, you first call `useInsertVisualizationWidgetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertVisualizationWidgetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertVisualizationWidgetMutation, { data, loading, error }] = useInsertVisualizationWidgetMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertVisualizationWidgetMutation(baseOptions?: Apollo.MutationHookOptions<InsertVisualizationWidgetMutation, InsertVisualizationWidgetMutationVariables>) {
        return Apollo.useMutation<InsertVisualizationWidgetMutation, InsertVisualizationWidgetMutationVariables>(InsertVisualizationWidgetDocument, baseOptions);
      }
export type InsertVisualizationWidgetMutationHookResult = ReturnType<typeof useInsertVisualizationWidgetMutation>;
export type InsertVisualizationWidgetMutationResult = Apollo.MutationResult<InsertVisualizationWidgetMutation>;
export type InsertVisualizationWidgetMutationOptions = Apollo.BaseMutationOptions<InsertVisualizationWidgetMutation, InsertVisualizationWidgetMutationVariables>;
export const RemoveVisualizationWidgetsDocument = gql`
    mutation RemoveVisualizationWidgets($widgets: [Int!]!) {
  delete_visualization_widgets(where: {id: {_in: $widgets}}) {
    returning {
      id
    }
  }
}
    `;
export type RemoveVisualizationWidgetsMutationFn = Apollo.MutationFunction<RemoveVisualizationWidgetsMutation, RemoveVisualizationWidgetsMutationVariables>;

/**
 * __useRemoveVisualizationWidgetsMutation__
 *
 * To run a mutation, you first call `useRemoveVisualizationWidgetsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveVisualizationWidgetsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeVisualizationWidgetsMutation, { data, loading, error }] = useRemoveVisualizationWidgetsMutation({
 *   variables: {
 *      widgets: // value for 'widgets'
 *   },
 * });
 */
export function useRemoveVisualizationWidgetsMutation(baseOptions?: Apollo.MutationHookOptions<RemoveVisualizationWidgetsMutation, RemoveVisualizationWidgetsMutationVariables>) {
        return Apollo.useMutation<RemoveVisualizationWidgetsMutation, RemoveVisualizationWidgetsMutationVariables>(RemoveVisualizationWidgetsDocument, baseOptions);
      }
export type RemoveVisualizationWidgetsMutationHookResult = ReturnType<typeof useRemoveVisualizationWidgetsMutation>;
export type RemoveVisualizationWidgetsMutationResult = Apollo.MutationResult<RemoveVisualizationWidgetsMutation>;
export type RemoveVisualizationWidgetsMutationOptions = Apollo.BaseMutationOptions<RemoveVisualizationWidgetsMutation, RemoveVisualizationWidgetsMutationVariables>;
export const UpsertTextWidgetDocument = gql`
    mutation UpsertTextWidget($object: text_widgets_insert_input!, $on_conflict: text_widgets_on_conflict!) {
  insert_text_widgets_one(object: $object, on_conflict: $on_conflict) {
    id
  }
}
    `;
export type UpsertTextWidgetMutationFn = Apollo.MutationFunction<UpsertTextWidgetMutation, UpsertTextWidgetMutationVariables>;

/**
 * __useUpsertTextWidgetMutation__
 *
 * To run a mutation, you first call `useUpsertTextWidgetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertTextWidgetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertTextWidgetMutation, { data, loading, error }] = useUpsertTextWidgetMutation({
 *   variables: {
 *      object: // value for 'object'
 *      on_conflict: // value for 'on_conflict'
 *   },
 * });
 */
export function useUpsertTextWidgetMutation(baseOptions?: Apollo.MutationHookOptions<UpsertTextWidgetMutation, UpsertTextWidgetMutationVariables>) {
        return Apollo.useMutation<UpsertTextWidgetMutation, UpsertTextWidgetMutationVariables>(UpsertTextWidgetDocument, baseOptions);
      }
export type UpsertTextWidgetMutationHookResult = ReturnType<typeof useUpsertTextWidgetMutation>;
export type UpsertTextWidgetMutationResult = Apollo.MutationResult<UpsertTextWidgetMutation>;
export type UpsertTextWidgetMutationOptions = Apollo.BaseMutationOptions<UpsertTextWidgetMutation, UpsertTextWidgetMutationVariables>;
export const RemoveTextWidgetsDocument = gql`
    mutation RemoveTextWidgets($widgets: [Int!]!) {
  delete_text_widgets(where: {id: {_in: $widgets}}) {
    returning {
      id
    }
  }
}
    `;
export type RemoveTextWidgetsMutationFn = Apollo.MutationFunction<RemoveTextWidgetsMutation, RemoveTextWidgetsMutationVariables>;

/**
 * __useRemoveTextWidgetsMutation__
 *
 * To run a mutation, you first call `useRemoveTextWidgetsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveTextWidgetsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeTextWidgetsMutation, { data, loading, error }] = useRemoveTextWidgetsMutation({
 *   variables: {
 *      widgets: // value for 'widgets'
 *   },
 * });
 */
export function useRemoveTextWidgetsMutation(baseOptions?: Apollo.MutationHookOptions<RemoveTextWidgetsMutation, RemoveTextWidgetsMutationVariables>) {
        return Apollo.useMutation<RemoveTextWidgetsMutation, RemoveTextWidgetsMutationVariables>(RemoveTextWidgetsDocument, baseOptions);
      }
export type RemoveTextWidgetsMutationHookResult = ReturnType<typeof useRemoveTextWidgetsMutation>;
export type RemoveTextWidgetsMutationResult = Apollo.MutationResult<RemoveTextWidgetsMutation>;
export type RemoveTextWidgetsMutationOptions = Apollo.BaseMutationOptions<RemoveTextWidgetsMutation, RemoveTextWidgetsMutationVariables>;
export const FindDashboardDocument = gql`
    query FindDashboard($session_filter: Int_comparison_exp!, $user: String!, $slug: String!) {
  dashboards(
    where: {slug: {_eq: $slug}, _or: [{user: {name: {_eq: $user}}}, {team: {handle: {_eq: $user}}}]}
  ) {
    ...Dashboard
    favorite_dashboards(where: {user_id: $session_filter}, limit: 1) {
      created_at
    }
  }
}
    ${DashboardFragmentDoc}`;

/**
 * __useFindDashboardQuery__
 *
 * To run a query within a React component, call `useFindDashboardQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindDashboardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindDashboardQuery({
 *   variables: {
 *      session_filter: // value for 'session_filter'
 *      user: // value for 'user'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useFindDashboardQuery(baseOptions: Apollo.QueryHookOptions<FindDashboardQuery, FindDashboardQueryVariables>) {
        return Apollo.useQuery<FindDashboardQuery, FindDashboardQueryVariables>(FindDashboardDocument, baseOptions);
      }
export function useFindDashboardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindDashboardQuery, FindDashboardQueryVariables>) {
          return Apollo.useLazyQuery<FindDashboardQuery, FindDashboardQueryVariables>(FindDashboardDocument, baseOptions);
        }
export type FindDashboardQueryHookResult = ReturnType<typeof useFindDashboardQuery>;
export type FindDashboardLazyQueryHookResult = ReturnType<typeof useFindDashboardLazyQuery>;
export type FindDashboardQueryResult = Apollo.QueryResult<FindDashboardQuery, FindDashboardQueryVariables>;
export const FindDashboardMetadataDocument = gql`
    query FindDashboardMetadata($owner_handle: String!, $slug: String!) {
  dashboards(
    where: {slug: {_eq: $slug}, _or: [{user: {name: {_eq: $owner_handle}}}, {team: {handle: {_eq: $owner_handle}}}]}
  ) {
    name
  }
}
    `;

/**
 * __useFindDashboardMetadataQuery__
 *
 * To run a query within a React component, call `useFindDashboardMetadataQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindDashboardMetadataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindDashboardMetadataQuery({
 *   variables: {
 *      owner_handle: // value for 'owner_handle'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useFindDashboardMetadataQuery(baseOptions: Apollo.QueryHookOptions<FindDashboardMetadataQuery, FindDashboardMetadataQueryVariables>) {
        return Apollo.useQuery<FindDashboardMetadataQuery, FindDashboardMetadataQueryVariables>(FindDashboardMetadataDocument, baseOptions);
      }
export function useFindDashboardMetadataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindDashboardMetadataQuery, FindDashboardMetadataQueryVariables>) {
          return Apollo.useLazyQuery<FindDashboardMetadataQuery, FindDashboardMetadataQueryVariables>(FindDashboardMetadataDocument, baseOptions);
        }
export type FindDashboardMetadataQueryHookResult = ReturnType<typeof useFindDashboardMetadataQuery>;
export type FindDashboardMetadataLazyQueryHookResult = ReturnType<typeof useFindDashboardMetadataLazyQuery>;
export type FindDashboardMetadataQueryResult = Apollo.QueryResult<FindDashboardMetadataQuery, FindDashboardMetadataQueryVariables>;
export const FindQueryMetadataDocument = gql`
    query FindQueryMetadata($id: Int!) {
  queries_by_pk(id: $id) {
    name
    description
  }
}
    `;

/**
 * __useFindQueryMetadataQuery__
 *
 * To run a query within a React component, call `useFindQueryMetadataQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindQueryMetadataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindQueryMetadataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFindQueryMetadataQuery(baseOptions: Apollo.QueryHookOptions<FindQueryMetadataQuery, FindQueryMetadataQueryVariables>) {
        return Apollo.useQuery<FindQueryMetadataQuery, FindQueryMetadataQueryVariables>(FindQueryMetadataDocument, baseOptions);
      }
export function useFindQueryMetadataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindQueryMetadataQuery, FindQueryMetadataQueryVariables>) {
          return Apollo.useLazyQuery<FindQueryMetadataQuery, FindQueryMetadataQueryVariables>(FindQueryMetadataDocument, baseOptions);
        }
export type FindQueryMetadataQueryHookResult = ReturnType<typeof useFindQueryMetadataQuery>;
export type FindQueryMetadataLazyQueryHookResult = ReturnType<typeof useFindQueryMetadataLazyQuery>;
export type FindQueryMetadataQueryResult = Apollo.QueryResult<FindQueryMetadataQuery, FindQueryMetadataQueryVariables>;
export const FindQueryDocument = gql`
    query FindQuery($session_filter: Int_comparison_exp!, $id: Int!, $favs_last_24h: Boolean! = false, $favs_last_7d: Boolean! = false, $favs_last_30d: Boolean! = false, $favs_all_time: Boolean! = true) {
  queries(where: {id: {_eq: $id}}) {
    ...Query
    favorite_queries(where: {user_id: $session_filter}, limit: 1) {
      created_at
    }
  }
}
    ${QueryFragmentDoc}`;

/**
 * __useFindQueryQuery__
 *
 * To run a query within a React component, call `useFindQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindQueryQuery({
 *   variables: {
 *      session_filter: // value for 'session_filter'
 *      id: // value for 'id'
 *      favs_last_24h: // value for 'favs_last_24h'
 *      favs_last_7d: // value for 'favs_last_7d'
 *      favs_last_30d: // value for 'favs_last_30d'
 *      favs_all_time: // value for 'favs_all_time'
 *   },
 * });
 */
export function useFindQueryQuery(baseOptions: Apollo.QueryHookOptions<FindQueryQuery, FindQueryQueryVariables>) {
        return Apollo.useQuery<FindQueryQuery, FindQueryQueryVariables>(FindQueryDocument, baseOptions);
      }
export function useFindQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindQueryQuery, FindQueryQueryVariables>) {
          return Apollo.useLazyQuery<FindQueryQuery, FindQueryQueryVariables>(FindQueryDocument, baseOptions);
        }
export type FindQueryQueryHookResult = ReturnType<typeof useFindQueryQuery>;
export type FindQueryLazyQueryHookResult = ReturnType<typeof useFindQueryLazyQuery>;
export type FindQueryQueryResult = Apollo.QueryResult<FindQueryQuery, FindQueryQueryVariables>;
export const ListDashboardsDocument = gql`
    query ListDashboards($session_filter: Int_comparison_exp!, $filter_custom: [dashboards_bool_exp!]!, $tags: jsonb_comparison_exp!, $query: String_comparison_exp!, $limit: Int!, $offset: Int!, $order: [dashboards_order_by!], $favs_last_24h: Boolean! = false, $favs_last_7d: Boolean! = false, $favs_last_30d: Boolean! = false, $favs_all_time: Boolean! = false) {
  dashboards(
    where: {is_archived: {_eq: false}, tags: $tags, name: $query, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...EntryDashboard
    favorite_dashboards(where: {user_id: $session_filter}, limit: 1) {
      created_at
    }
  }
  dashboards_aggregate(
    where: {is_archived: {_eq: false}, tags: $tags, name: $query, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${EntryDashboardFragmentDoc}`;

/**
 * __useListDashboardsQuery__
 *
 * To run a query within a React component, call `useListDashboardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListDashboardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListDashboardsQuery({
 *   variables: {
 *      session_filter: // value for 'session_filter'
 *      filter_custom: // value for 'filter_custom'
 *      tags: // value for 'tags'
 *      query: // value for 'query'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      order: // value for 'order'
 *      favs_last_24h: // value for 'favs_last_24h'
 *      favs_last_7d: // value for 'favs_last_7d'
 *      favs_last_30d: // value for 'favs_last_30d'
 *      favs_all_time: // value for 'favs_all_time'
 *   },
 * });
 */
export function useListDashboardsQuery(baseOptions: Apollo.QueryHookOptions<ListDashboardsQuery, ListDashboardsQueryVariables>) {
        return Apollo.useQuery<ListDashboardsQuery, ListDashboardsQueryVariables>(ListDashboardsDocument, baseOptions);
      }
export function useListDashboardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListDashboardsQuery, ListDashboardsQueryVariables>) {
          return Apollo.useLazyQuery<ListDashboardsQuery, ListDashboardsQueryVariables>(ListDashboardsDocument, baseOptions);
        }
export type ListDashboardsQueryHookResult = ReturnType<typeof useListDashboardsQuery>;
export type ListDashboardsLazyQueryHookResult = ReturnType<typeof useListDashboardsLazyQuery>;
export type ListDashboardsQueryResult = Apollo.QueryResult<ListDashboardsQuery, ListDashboardsQueryVariables>;
export const ListDashboardsWithVisualizationWidgetsDocument = gql`
    query ListDashboardsWithVisualizationWidgets($author_name: String!, $query: String_comparison_exp!) {
  dashboards(
    where: {_or: [{user: {name: {_eq: $author_name}}}, {team: {memberships: {user: {name: {_eq: $author_name}}}}}], is_archived: {_eq: false}, name: $query}
  ) {
    ...EntryDashboardWithVizWidgets
  }
}
    ${EntryDashboardWithVizWidgetsFragmentDoc}`;

/**
 * __useListDashboardsWithVisualizationWidgetsQuery__
 *
 * To run a query within a React component, call `useListDashboardsWithVisualizationWidgetsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListDashboardsWithVisualizationWidgetsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListDashboardsWithVisualizationWidgetsQuery({
 *   variables: {
 *      author_name: // value for 'author_name'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useListDashboardsWithVisualizationWidgetsQuery(baseOptions: Apollo.QueryHookOptions<ListDashboardsWithVisualizationWidgetsQuery, ListDashboardsWithVisualizationWidgetsQueryVariables>) {
        return Apollo.useQuery<ListDashboardsWithVisualizationWidgetsQuery, ListDashboardsWithVisualizationWidgetsQueryVariables>(ListDashboardsWithVisualizationWidgetsDocument, baseOptions);
      }
export function useListDashboardsWithVisualizationWidgetsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListDashboardsWithVisualizationWidgetsQuery, ListDashboardsWithVisualizationWidgetsQueryVariables>) {
          return Apollo.useLazyQuery<ListDashboardsWithVisualizationWidgetsQuery, ListDashboardsWithVisualizationWidgetsQueryVariables>(ListDashboardsWithVisualizationWidgetsDocument, baseOptions);
        }
export type ListDashboardsWithVisualizationWidgetsQueryHookResult = ReturnType<typeof useListDashboardsWithVisualizationWidgetsQuery>;
export type ListDashboardsWithVisualizationWidgetsLazyQueryHookResult = ReturnType<typeof useListDashboardsWithVisualizationWidgetsLazyQuery>;
export type ListDashboardsWithVisualizationWidgetsQueryResult = Apollo.QueryResult<ListDashboardsWithVisualizationWidgetsQuery, ListDashboardsWithVisualizationWidgetsQueryVariables>;
export const ListFavoriteDashboardsDocument = gql`
    query ListFavoriteDashboards($session_id: Int!, $query: String_comparison_exp!, $limit: Int!, $offset: Int!, $order: [dashboards_order_by!], $favs_last_24h: Boolean! = false, $favs_last_7d: Boolean! = false, $favs_last_30d: Boolean! = false, $favs_all_time: Boolean! = false) {
  dashboards(
    where: {favorite_dashboards: {user_id: {_eq: $session_id}}, is_archived: {_eq: false}, name: $query}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...EntryDashboard
    favorite_dashboards(where: {user_id: {_eq: $session_id}}, limit: 1) {
      created_at
    }
  }
  dashboards_aggregate(
    where: {favorite_dashboards: {user_id: {_eq: $session_id}}, is_archived: {_eq: false}, name: $query}
  ) {
    aggregate {
      count
    }
  }
}
    ${EntryDashboardFragmentDoc}`;

/**
 * __useListFavoriteDashboardsQuery__
 *
 * To run a query within a React component, call `useListFavoriteDashboardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListFavoriteDashboardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListFavoriteDashboardsQuery({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      query: // value for 'query'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      order: // value for 'order'
 *      favs_last_24h: // value for 'favs_last_24h'
 *      favs_last_7d: // value for 'favs_last_7d'
 *      favs_last_30d: // value for 'favs_last_30d'
 *      favs_all_time: // value for 'favs_all_time'
 *   },
 * });
 */
export function useListFavoriteDashboardsQuery(baseOptions: Apollo.QueryHookOptions<ListFavoriteDashboardsQuery, ListFavoriteDashboardsQueryVariables>) {
        return Apollo.useQuery<ListFavoriteDashboardsQuery, ListFavoriteDashboardsQueryVariables>(ListFavoriteDashboardsDocument, baseOptions);
      }
export function useListFavoriteDashboardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListFavoriteDashboardsQuery, ListFavoriteDashboardsQueryVariables>) {
          return Apollo.useLazyQuery<ListFavoriteDashboardsQuery, ListFavoriteDashboardsQueryVariables>(ListFavoriteDashboardsDocument, baseOptions);
        }
export type ListFavoriteDashboardsQueryHookResult = ReturnType<typeof useListFavoriteDashboardsQuery>;
export type ListFavoriteDashboardsLazyQueryHookResult = ReturnType<typeof useListFavoriteDashboardsLazyQuery>;
export type ListFavoriteDashboardsQueryResult = Apollo.QueryResult<ListFavoriteDashboardsQuery, ListFavoriteDashboardsQueryVariables>;
export const ListQueriesDocument = gql`
    query ListQueries($session_filter: Int_comparison_exp!, $filter_custom: [queries_bool_exp!]!, $tags: jsonb_comparison_exp!, $query: String_comparison_exp!, $is_archived: Boolean!, $limit: Int!, $offset: Int!, $order: [queries_order_by!], $favs_last_24h: Boolean! = false, $favs_last_7d: Boolean! = false, $favs_last_30d: Boolean! = false, $favs_all_time: Boolean! = false, $exclude_favorites: Boolean! = false, $exclude_forks: Boolean! = false, $exclude_users: Boolean! = false, $exclude_teams: Boolean! = false, $exclude_visualizations: Boolean! = false) {
  queries(
    where: {is_archived: {_eq: $is_archived}, is_temp: {_eq: false}, tags: $tags, name: $query, _and: $filter_custom}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...ParametrizedQuery
    favorite_queries(where: {user_id: $session_filter}, limit: 1) {
      created_at
    }
  }
  queries_aggregate(
    where: {is_archived: {_eq: $is_archived}, is_temp: {_eq: false}, tags: $tags, name: $query, _and: $filter_custom}
  ) {
    aggregate {
      count
    }
  }
}
    ${ParametrizedQueryFragmentDoc}`;

/**
 * __useListQueriesQuery__
 *
 * To run a query within a React component, call `useListQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListQueriesQuery({
 *   variables: {
 *      session_filter: // value for 'session_filter'
 *      filter_custom: // value for 'filter_custom'
 *      tags: // value for 'tags'
 *      query: // value for 'query'
 *      is_archived: // value for 'is_archived'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      order: // value for 'order'
 *      favs_last_24h: // value for 'favs_last_24h'
 *      favs_last_7d: // value for 'favs_last_7d'
 *      favs_last_30d: // value for 'favs_last_30d'
 *      favs_all_time: // value for 'favs_all_time'
 *      exclude_favorites: // value for 'exclude_favorites'
 *      exclude_forks: // value for 'exclude_forks'
 *      exclude_users: // value for 'exclude_users'
 *      exclude_teams: // value for 'exclude_teams'
 *      exclude_visualizations: // value for 'exclude_visualizations'
 *   },
 * });
 */
export function useListQueriesQuery(baseOptions: Apollo.QueryHookOptions<ListQueriesQuery, ListQueriesQueryVariables>) {
        return Apollo.useQuery<ListQueriesQuery, ListQueriesQueryVariables>(ListQueriesDocument, baseOptions);
      }
export function useListQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListQueriesQuery, ListQueriesQueryVariables>) {
          return Apollo.useLazyQuery<ListQueriesQuery, ListQueriesQueryVariables>(ListQueriesDocument, baseOptions);
        }
export type ListQueriesQueryHookResult = ReturnType<typeof useListQueriesQuery>;
export type ListQueriesLazyQueryHookResult = ReturnType<typeof useListQueriesLazyQuery>;
export type ListQueriesQueryResult = Apollo.QueryResult<ListQueriesQuery, ListQueriesQueryVariables>;
export const ListFavoriteQueriesDocument = gql`
    query ListFavoriteQueries($session_id: Int!, $query: String_comparison_exp!, $limit: Int!, $offset: Int!, $order: [queries_order_by!], $favs_last_24h: Boolean! = false, $favs_last_7d: Boolean! = false, $favs_last_30d: Boolean! = false, $favs_all_time: Boolean! = false, $exclude_favorites: Boolean! = false, $exclude_forks: Boolean! = false, $exclude_users: Boolean! = false, $exclude_teams: Boolean! = false, $exclude_visualizations: Boolean! = false) {
  queries(
    where: {favorite_queries: {user_id: {_eq: $session_id}}, is_archived: {_eq: false}, is_temp: {_eq: false}, name: $query}
    limit: $limit
    offset: $offset
    order_by: $order
  ) {
    ...ParametrizedQuery
    favorite_queries(where: {user_id: {_eq: $session_id}}, limit: 1) {
      created_at
    }
  }
  queries_aggregate(
    where: {favorite_queries: {user_id: {_eq: $session_id}}, is_archived: {_eq: false}, is_temp: {_eq: false}, name: $query}
  ) {
    aggregate {
      count
    }
  }
}
    ${ParametrizedQueryFragmentDoc}`;

/**
 * __useListFavoriteQueriesQuery__
 *
 * To run a query within a React component, call `useListFavoriteQueriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListFavoriteQueriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListFavoriteQueriesQuery({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      query: // value for 'query'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      order: // value for 'order'
 *      favs_last_24h: // value for 'favs_last_24h'
 *      favs_last_7d: // value for 'favs_last_7d'
 *      favs_last_30d: // value for 'favs_last_30d'
 *      favs_all_time: // value for 'favs_all_time'
 *      exclude_favorites: // value for 'exclude_favorites'
 *      exclude_forks: // value for 'exclude_forks'
 *      exclude_users: // value for 'exclude_users'
 *      exclude_teams: // value for 'exclude_teams'
 *      exclude_visualizations: // value for 'exclude_visualizations'
 *   },
 * });
 */
export function useListFavoriteQueriesQuery(baseOptions: Apollo.QueryHookOptions<ListFavoriteQueriesQuery, ListFavoriteQueriesQueryVariables>) {
        return Apollo.useQuery<ListFavoriteQueriesQuery, ListFavoriteQueriesQueryVariables>(ListFavoriteQueriesDocument, baseOptions);
      }
export function useListFavoriteQueriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListFavoriteQueriesQuery, ListFavoriteQueriesQueryVariables>) {
          return Apollo.useLazyQuery<ListFavoriteQueriesQuery, ListFavoriteQueriesQueryVariables>(ListFavoriteQueriesDocument, baseOptions);
        }
export type ListFavoriteQueriesQueryHookResult = ReturnType<typeof useListFavoriteQueriesQuery>;
export type ListFavoriteQueriesLazyQueryHookResult = ReturnType<typeof useListFavoriteQueriesLazyQuery>;
export type ListFavoriteQueriesQueryResult = Apollo.QueryResult<ListFavoriteQueriesQuery, ListFavoriteQueriesQueryVariables>;
export const ListUsersDocument = gql`
    query ListUsers($query: String_comparison_exp!, $limit: Int!, $offset: Int!) {
  user_received_stars(
    where: {user: {name: $query}}
    order_by: [{sum: desc_nulls_last}, {user: {id: asc}}]
    limit: $limit
    offset: $offset
  ) {
    sum
    user {
      id
      name
      profile_image_url
      created_at
      queries(order_by: {created_at: asc_nulls_last}, limit: 1) {
        created_at
      }
    }
  }
  user_received_stars_aggregate(where: {user: {name: $query}}) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useListUsersQuery__
 *
 * To run a query within a React component, call `useListUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useListUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListUsersQuery({
 *   variables: {
 *      query: // value for 'query'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListUsersQuery(baseOptions: Apollo.QueryHookOptions<ListUsersQuery, ListUsersQueryVariables>) {
        return Apollo.useQuery<ListUsersQuery, ListUsersQueryVariables>(ListUsersDocument, baseOptions);
      }
export function useListUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListUsersQuery, ListUsersQueryVariables>) {
          return Apollo.useLazyQuery<ListUsersQuery, ListUsersQueryVariables>(ListUsersDocument, baseOptions);
        }
export type ListUsersQueryHookResult = ReturnType<typeof useListUsersQuery>;
export type ListUsersLazyQueryHookResult = ReturnType<typeof useListUsersLazyQuery>;
export type ListUsersQueryResult = Apollo.QueryResult<ListUsersQuery, ListUsersQueryVariables>;
export const InsertFavoriteDashboardDocument = gql`
    mutation InsertFavoriteDashboard($session_id: Int!, $dashboard_id: Int!) {
  insert_favorite_dashboards_one(
    object: {user_id: $session_id, dashboard_id: $dashboard_id}
  ) {
    id
  }
}
    `;
export type InsertFavoriteDashboardMutationFn = Apollo.MutationFunction<InsertFavoriteDashboardMutation, InsertFavoriteDashboardMutationVariables>;

/**
 * __useInsertFavoriteDashboardMutation__
 *
 * To run a mutation, you first call `useInsertFavoriteDashboardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertFavoriteDashboardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertFavoriteDashboardMutation, { data, loading, error }] = useInsertFavoriteDashboardMutation({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      dashboard_id: // value for 'dashboard_id'
 *   },
 * });
 */
export function useInsertFavoriteDashboardMutation(baseOptions?: Apollo.MutationHookOptions<InsertFavoriteDashboardMutation, InsertFavoriteDashboardMutationVariables>) {
        return Apollo.useMutation<InsertFavoriteDashboardMutation, InsertFavoriteDashboardMutationVariables>(InsertFavoriteDashboardDocument, baseOptions);
      }
export type InsertFavoriteDashboardMutationHookResult = ReturnType<typeof useInsertFavoriteDashboardMutation>;
export type InsertFavoriteDashboardMutationResult = Apollo.MutationResult<InsertFavoriteDashboardMutation>;
export type InsertFavoriteDashboardMutationOptions = Apollo.BaseMutationOptions<InsertFavoriteDashboardMutation, InsertFavoriteDashboardMutationVariables>;
export const InsertFavoriteQueryDocument = gql`
    mutation InsertFavoriteQuery($session_id: Int!, $query_id: Int!) {
  insert_favorite_queries_one(object: {user_id: $session_id, query_id: $query_id}) {
    id
  }
}
    `;
export type InsertFavoriteQueryMutationFn = Apollo.MutationFunction<InsertFavoriteQueryMutation, InsertFavoriteQueryMutationVariables>;

/**
 * __useInsertFavoriteQueryMutation__
 *
 * To run a mutation, you first call `useInsertFavoriteQueryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertFavoriteQueryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertFavoriteQueryMutation, { data, loading, error }] = useInsertFavoriteQueryMutation({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      query_id: // value for 'query_id'
 *   },
 * });
 */
export function useInsertFavoriteQueryMutation(baseOptions?: Apollo.MutationHookOptions<InsertFavoriteQueryMutation, InsertFavoriteQueryMutationVariables>) {
        return Apollo.useMutation<InsertFavoriteQueryMutation, InsertFavoriteQueryMutationVariables>(InsertFavoriteQueryDocument, baseOptions);
      }
export type InsertFavoriteQueryMutationHookResult = ReturnType<typeof useInsertFavoriteQueryMutation>;
export type InsertFavoriteQueryMutationResult = Apollo.MutationResult<InsertFavoriteQueryMutation>;
export type InsertFavoriteQueryMutationOptions = Apollo.BaseMutationOptions<InsertFavoriteQueryMutation, InsertFavoriteQueryMutationVariables>;
export const DeleteFavoriteDashboardDocument = gql`
    mutation DeleteFavoriteDashboard($session_id: Int!, $dashboard_id: Int!) {
  delete_favorite_dashboards(
    where: {user_id: {_eq: $session_id}, dashboard_id: {_eq: $dashboard_id}}
  ) {
    affected_rows
  }
}
    `;
export type DeleteFavoriteDashboardMutationFn = Apollo.MutationFunction<DeleteFavoriteDashboardMutation, DeleteFavoriteDashboardMutationVariables>;

/**
 * __useDeleteFavoriteDashboardMutation__
 *
 * To run a mutation, you first call `useDeleteFavoriteDashboardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteFavoriteDashboardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteFavoriteDashboardMutation, { data, loading, error }] = useDeleteFavoriteDashboardMutation({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      dashboard_id: // value for 'dashboard_id'
 *   },
 * });
 */
export function useDeleteFavoriteDashboardMutation(baseOptions?: Apollo.MutationHookOptions<DeleteFavoriteDashboardMutation, DeleteFavoriteDashboardMutationVariables>) {
        return Apollo.useMutation<DeleteFavoriteDashboardMutation, DeleteFavoriteDashboardMutationVariables>(DeleteFavoriteDashboardDocument, baseOptions);
      }
export type DeleteFavoriteDashboardMutationHookResult = ReturnType<typeof useDeleteFavoriteDashboardMutation>;
export type DeleteFavoriteDashboardMutationResult = Apollo.MutationResult<DeleteFavoriteDashboardMutation>;
export type DeleteFavoriteDashboardMutationOptions = Apollo.BaseMutationOptions<DeleteFavoriteDashboardMutation, DeleteFavoriteDashboardMutationVariables>;
export const DeleteFavoriteQueryDocument = gql`
    mutation DeleteFavoriteQuery($session_id: Int!, $query_id: Int!) {
  delete_favorite_queries(
    where: {user_id: {_eq: $session_id}, query_id: {_eq: $query_id}}
  ) {
    affected_rows
  }
}
    `;
export type DeleteFavoriteQueryMutationFn = Apollo.MutationFunction<DeleteFavoriteQueryMutation, DeleteFavoriteQueryMutationVariables>;

/**
 * __useDeleteFavoriteQueryMutation__
 *
 * To run a mutation, you first call `useDeleteFavoriteQueryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteFavoriteQueryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteFavoriteQueryMutation, { data, loading, error }] = useDeleteFavoriteQueryMutation({
 *   variables: {
 *      session_id: // value for 'session_id'
 *      query_id: // value for 'query_id'
 *   },
 * });
 */
export function useDeleteFavoriteQueryMutation(baseOptions?: Apollo.MutationHookOptions<DeleteFavoriteQueryMutation, DeleteFavoriteQueryMutationVariables>) {
        return Apollo.useMutation<DeleteFavoriteQueryMutation, DeleteFavoriteQueryMutationVariables>(DeleteFavoriteQueryDocument, baseOptions);
      }
export type DeleteFavoriteQueryMutationHookResult = ReturnType<typeof useDeleteFavoriteQueryMutation>;
export type DeleteFavoriteQueryMutationResult = Apollo.MutationResult<DeleteFavoriteQueryMutation>;
export type DeleteFavoriteQueryMutationOptions = Apollo.BaseMutationOptions<DeleteFavoriteQueryMutation, DeleteFavoriteQueryMutationVariables>;
export const GetExecutionDocument = gql`
    query GetExecution($execution_id: String!, $query_id: Int!, $parameters: [Parameter!]!) {
  get_execution(
    execution_id: $execution_id
    query_id: $query_id
    parameters: $parameters
  ) {
    execution_queued {
      execution_id
      execution_user_id
      position
      execution_type
      created_at
    }
    execution_running {
      execution_id
      execution_user_id
      execution_type
      started_at
      created_at
    }
    execution_succeeded {
      execution_id
      runtime_seconds
      generated_at
      columns
      data
      max_result_size_reached_bytes
      request_max_result_size_bytes
    }
    execution_failed {
      execution_id
      type
      message
      metadata {
        line
        column
        hint
      }
      runtime_seconds
      generated_at
    }
  }
}
    `;

/**
 * __useGetExecutionQuery__
 *
 * To run a query within a React component, call `useGetExecutionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExecutionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExecutionQuery({
 *   variables: {
 *      execution_id: // value for 'execution_id'
 *      query_id: // value for 'query_id'
 *      parameters: // value for 'parameters'
 *   },
 * });
 */
export function useGetExecutionQuery(baseOptions: Apollo.QueryHookOptions<GetExecutionQuery, GetExecutionQueryVariables>) {
        return Apollo.useQuery<GetExecutionQuery, GetExecutionQueryVariables>(GetExecutionDocument, baseOptions);
      }
export function useGetExecutionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExecutionQuery, GetExecutionQueryVariables>) {
          return Apollo.useLazyQuery<GetExecutionQuery, GetExecutionQueryVariables>(GetExecutionDocument, baseOptions);
        }
export type GetExecutionQueryHookResult = ReturnType<typeof useGetExecutionQuery>;
export type GetExecutionLazyQueryHookResult = ReturnType<typeof useGetExecutionLazyQuery>;
export type GetExecutionQueryResult = Apollo.QueryResult<GetExecutionQuery, GetExecutionQueryVariables>;
export const StarRankingWithDiscordUsernameDocument = gql`
    query StarRankingWithDiscordUsername {
  users(order_by: [{received_stars: {sum: desc_nulls_last}}]) {
    received_stars {
      sum
    }
    id
    name
    discord_username
  }
}
    `;

/**
 * __useStarRankingWithDiscordUsernameQuery__
 *
 * To run a query within a React component, call `useStarRankingWithDiscordUsernameQuery` and pass it any options that fit your needs.
 * When your component renders, `useStarRankingWithDiscordUsernameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStarRankingWithDiscordUsernameQuery({
 *   variables: {
 *   },
 * });
 */
export function useStarRankingWithDiscordUsernameQuery(baseOptions?: Apollo.QueryHookOptions<StarRankingWithDiscordUsernameQuery, StarRankingWithDiscordUsernameQueryVariables>) {
        return Apollo.useQuery<StarRankingWithDiscordUsernameQuery, StarRankingWithDiscordUsernameQueryVariables>(StarRankingWithDiscordUsernameDocument, baseOptions);
      }
export function useStarRankingWithDiscordUsernameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StarRankingWithDiscordUsernameQuery, StarRankingWithDiscordUsernameQueryVariables>) {
          return Apollo.useLazyQuery<StarRankingWithDiscordUsernameQuery, StarRankingWithDiscordUsernameQueryVariables>(StarRankingWithDiscordUsernameDocument, baseOptions);
        }
export type StarRankingWithDiscordUsernameQueryHookResult = ReturnType<typeof useStarRankingWithDiscordUsernameQuery>;
export type StarRankingWithDiscordUsernameLazyQueryHookResult = ReturnType<typeof useStarRankingWithDiscordUsernameLazyQuery>;
export type StarRankingWithDiscordUsernameQueryResult = Apollo.QueryResult<StarRankingWithDiscordUsernameQuery, StarRankingWithDiscordUsernameQueryVariables>;
export const ExampleDocument = gql`
    query Example {
  dashboards {
    id
  }
}
    `;

/**
 * __useExampleQuery__
 *
 * To run a query within a React component, call `useExampleQuery` and pass it any options that fit your needs.
 * When your component renders, `useExampleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useExampleQuery({
 *   variables: {
 *   },
 * });
 */
export function useExampleQuery(baseOptions?: Apollo.QueryHookOptions<ExampleQuery, ExampleQueryVariables>) {
        return Apollo.useQuery<ExampleQuery, ExampleQueryVariables>(ExampleDocument, baseOptions);
      }
export function useExampleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ExampleQuery, ExampleQueryVariables>) {
          return Apollo.useLazyQuery<ExampleQuery, ExampleQueryVariables>(ExampleDocument, baseOptions);
        }
export type ExampleQueryHookResult = ReturnType<typeof useExampleQuery>;
export type ExampleLazyQueryHookResult = ReturnType<typeof useExampleLazyQuery>;
export type ExampleQueryResult = Apollo.QueryResult<ExampleQuery, ExampleQueryVariables>;
export const GetEntityBySubscriptionIdDocument = gql`
    query GetEntityBySubscriptionId($id: String!) {
  users(
    where: {_or: [{orb_subscription_id: {_eq: $id}}, {orb_api_subscription_id: {_eq: $id}}]}
  ) {
    id
    orb_subscription_id
    orb_api_subscription_id
  }
  teams(where: {orb_subscription_id: {_eq: $id}}) {
    id
    orb_subscription_id
  }
}
    `;

/**
 * __useGetEntityBySubscriptionIdQuery__
 *
 * To run a query within a React component, call `useGetEntityBySubscriptionIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEntityBySubscriptionIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEntityBySubscriptionIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetEntityBySubscriptionIdQuery(baseOptions: Apollo.QueryHookOptions<GetEntityBySubscriptionIdQuery, GetEntityBySubscriptionIdQueryVariables>) {
        return Apollo.useQuery<GetEntityBySubscriptionIdQuery, GetEntityBySubscriptionIdQueryVariables>(GetEntityBySubscriptionIdDocument, baseOptions);
      }
export function useGetEntityBySubscriptionIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEntityBySubscriptionIdQuery, GetEntityBySubscriptionIdQueryVariables>) {
          return Apollo.useLazyQuery<GetEntityBySubscriptionIdQuery, GetEntityBySubscriptionIdQueryVariables>(GetEntityBySubscriptionIdDocument, baseOptions);
        }
export type GetEntityBySubscriptionIdQueryHookResult = ReturnType<typeof useGetEntityBySubscriptionIdQuery>;
export type GetEntityBySubscriptionIdLazyQueryHookResult = ReturnType<typeof useGetEntityBySubscriptionIdLazyQuery>;
export type GetEntityBySubscriptionIdQueryResult = Apollo.QueryResult<GetEntityBySubscriptionIdQuery, GetEntityBySubscriptionIdQueryVariables>;
export const GetApiUserOrbSubscriptionDocument = gql`
    query GetApiUserOrbSubscription($userId: Int!) {
  users(where: {id: {_eq: $userId}}) {
    id
    orb_api_subscription_id
    api_user_service_tier {
      id
      name
    }
  }
}
    `;

/**
 * __useGetApiUserOrbSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetApiUserOrbSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiUserOrbSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiUserOrbSubscriptionQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetApiUserOrbSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetApiUserOrbSubscriptionQuery, GetApiUserOrbSubscriptionQueryVariables>) {
        return Apollo.useQuery<GetApiUserOrbSubscriptionQuery, GetApiUserOrbSubscriptionQueryVariables>(GetApiUserOrbSubscriptionDocument, baseOptions);
      }
export function useGetApiUserOrbSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiUserOrbSubscriptionQuery, GetApiUserOrbSubscriptionQueryVariables>) {
          return Apollo.useLazyQuery<GetApiUserOrbSubscriptionQuery, GetApiUserOrbSubscriptionQueryVariables>(GetApiUserOrbSubscriptionDocument, baseOptions);
        }
export type GetApiUserOrbSubscriptionQueryHookResult = ReturnType<typeof useGetApiUserOrbSubscriptionQuery>;
export type GetApiUserOrbSubscriptionLazyQueryHookResult = ReturnType<typeof useGetApiUserOrbSubscriptionLazyQuery>;
export type GetApiUserOrbSubscriptionQueryResult = Apollo.QueryResult<GetApiUserOrbSubscriptionQuery, GetApiUserOrbSubscriptionQueryVariables>;
export const GetTeamCommunityTierDocument = gql`
    query GetTeamCommunityTier {
  team_service_tiers(where: {id: {_eq: 1}}) {
    id
    orb_base_plan_id
  }
}
    `;

/**
 * __useGetTeamCommunityTierQuery__
 *
 * To run a query within a React component, call `useGetTeamCommunityTierQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamCommunityTierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamCommunityTierQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTeamCommunityTierQuery(baseOptions?: Apollo.QueryHookOptions<GetTeamCommunityTierQuery, GetTeamCommunityTierQueryVariables>) {
        return Apollo.useQuery<GetTeamCommunityTierQuery, GetTeamCommunityTierQueryVariables>(GetTeamCommunityTierDocument, baseOptions);
      }
export function useGetTeamCommunityTierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamCommunityTierQuery, GetTeamCommunityTierQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamCommunityTierQuery, GetTeamCommunityTierQueryVariables>(GetTeamCommunityTierDocument, baseOptions);
        }
export type GetTeamCommunityTierQueryHookResult = ReturnType<typeof useGetTeamCommunityTierQuery>;
export type GetTeamCommunityTierLazyQueryHookResult = ReturnType<typeof useGetTeamCommunityTierLazyQuery>;
export type GetTeamCommunityTierQueryResult = Apollo.QueryResult<GetTeamCommunityTierQuery, GetTeamCommunityTierQueryVariables>;
export const GetUserCommunityTierDocument = gql`
    query GetUserCommunityTier {
  user_service_tiers(where: {id: {_eq: 1}}) {
    id
    orb_base_plan_id
  }
}
    `;

/**
 * __useGetUserCommunityTierQuery__
 *
 * To run a query within a React component, call `useGetUserCommunityTierQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserCommunityTierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserCommunityTierQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUserCommunityTierQuery(baseOptions?: Apollo.QueryHookOptions<GetUserCommunityTierQuery, GetUserCommunityTierQueryVariables>) {
        return Apollo.useQuery<GetUserCommunityTierQuery, GetUserCommunityTierQueryVariables>(GetUserCommunityTierDocument, baseOptions);
      }
export function useGetUserCommunityTierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserCommunityTierQuery, GetUserCommunityTierQueryVariables>) {
          return Apollo.useLazyQuery<GetUserCommunityTierQuery, GetUserCommunityTierQueryVariables>(GetUserCommunityTierDocument, baseOptions);
        }
export type GetUserCommunityTierQueryHookResult = ReturnType<typeof useGetUserCommunityTierQuery>;
export type GetUserCommunityTierLazyQueryHookResult = ReturnType<typeof useGetUserCommunityTierLazyQuery>;
export type GetUserCommunityTierQueryResult = Apollo.QueryResult<GetUserCommunityTierQuery, GetUserCommunityTierQueryVariables>;
export const DowngradeUserToCommunityDocument = gql`
    mutation DowngradeUserToCommunity($userId: Int!) {
  update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {service_tier: 1, orb_subscription_id: null, execution_quota_exceeded_until: null, csv_download_quota_exceeded_until: null, max_overage_cents: 0}
  ) {
    id
  }
  delete_pending_user_subscription_updates(where: {user_id: {_eq: $userId}}) {
    affected_rows
  }
  update_dashboards(
    where: {user_id: {_eq: $userId}, is_private: {_eq: true}}
    _set: {is_archived: true}
  ) {
    affected_rows
  }
  update_queries(
    where: {user_id: {_eq: $userId}, is_private: {_eq: true}, is_temp: {_eq: false}}
    _set: {is_archived: true}
  ) {
    affected_rows
  }
}
    `;
export type DowngradeUserToCommunityMutationFn = Apollo.MutationFunction<DowngradeUserToCommunityMutation, DowngradeUserToCommunityMutationVariables>;

/**
 * __useDowngradeUserToCommunityMutation__
 *
 * To run a mutation, you first call `useDowngradeUserToCommunityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDowngradeUserToCommunityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downgradeUserToCommunityMutation, { data, loading, error }] = useDowngradeUserToCommunityMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useDowngradeUserToCommunityMutation(baseOptions?: Apollo.MutationHookOptions<DowngradeUserToCommunityMutation, DowngradeUserToCommunityMutationVariables>) {
        return Apollo.useMutation<DowngradeUserToCommunityMutation, DowngradeUserToCommunityMutationVariables>(DowngradeUserToCommunityDocument, baseOptions);
      }
export type DowngradeUserToCommunityMutationHookResult = ReturnType<typeof useDowngradeUserToCommunityMutation>;
export type DowngradeUserToCommunityMutationResult = Apollo.MutationResult<DowngradeUserToCommunityMutation>;
export type DowngradeUserToCommunityMutationOptions = Apollo.BaseMutationOptions<DowngradeUserToCommunityMutation, DowngradeUserToCommunityMutationVariables>;
export const TerminateApiUserSubscriptionDocument = gql`
    mutation TerminateApiUserSubscription($userId: Int!, $subscriptionId: String!, $isForced: Boolean) {
  terminate_api_user_subscription(
    user_id: $userId
    subscription_id: $subscriptionId
    is_forced: $isForced
  ) {
    ok
  }
}
    `;
export type TerminateApiUserSubscriptionMutationFn = Apollo.MutationFunction<TerminateApiUserSubscriptionMutation, TerminateApiUserSubscriptionMutationVariables>;

/**
 * __useTerminateApiUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useTerminateApiUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateApiUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateApiUserSubscriptionMutation, { data, loading, error }] = useTerminateApiUserSubscriptionMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      subscriptionId: // value for 'subscriptionId'
 *      isForced: // value for 'isForced'
 *   },
 * });
 */
export function useTerminateApiUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<TerminateApiUserSubscriptionMutation, TerminateApiUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<TerminateApiUserSubscriptionMutation, TerminateApiUserSubscriptionMutationVariables>(TerminateApiUserSubscriptionDocument, baseOptions);
      }
export type TerminateApiUserSubscriptionMutationHookResult = ReturnType<typeof useTerminateApiUserSubscriptionMutation>;
export type TerminateApiUserSubscriptionMutationResult = Apollo.MutationResult<TerminateApiUserSubscriptionMutation>;
export type TerminateApiUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<TerminateApiUserSubscriptionMutation, TerminateApiUserSubscriptionMutationVariables>;
export const GetTeamForOverageDocument = gql`
    query GetTeamForOverage($orbCustomerId: String!) {
  teams(where: {orb_customer_id: {_eq: $orbCustomerId}}) {
    id
    name
    handle
    service_tier {
      id
      csv_downloads_per_month
      included_query_executions
      included_datapoints
      included_nanocredits
    }
    max_executions_overage_cost_cents
    admins: memberships(
      where: {role: {_eq: "admin"}, status: {_eq: "invite_accepted"}}
    ) {
      id
      user {
        id
        name
        email
      }
    }
  }
}
    `;

/**
 * __useGetTeamForOverageQuery__
 *
 * To run a query within a React component, call `useGetTeamForOverageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamForOverageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamForOverageQuery({
 *   variables: {
 *      orbCustomerId: // value for 'orbCustomerId'
 *   },
 * });
 */
export function useGetTeamForOverageQuery(baseOptions: Apollo.QueryHookOptions<GetTeamForOverageQuery, GetTeamForOverageQueryVariables>) {
        return Apollo.useQuery<GetTeamForOverageQuery, GetTeamForOverageQueryVariables>(GetTeamForOverageDocument, baseOptions);
      }
export function useGetTeamForOverageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamForOverageQuery, GetTeamForOverageQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamForOverageQuery, GetTeamForOverageQueryVariables>(GetTeamForOverageDocument, baseOptions);
        }
export type GetTeamForOverageQueryHookResult = ReturnType<typeof useGetTeamForOverageQuery>;
export type GetTeamForOverageLazyQueryHookResult = ReturnType<typeof useGetTeamForOverageLazyQuery>;
export type GetTeamForOverageQueryResult = Apollo.QueryResult<GetTeamForOverageQuery, GetTeamForOverageQueryVariables>;
export const UpdateTeamCsvDownloadQuotaDocument = gql`
    mutation updateTeamCSVDownloadQuota($id: Int!, $csv_download_quota_exceeded_until: timestamptz!) {
  update_teams(
    where: {id: {_eq: $id}}
    _set: {csv_download_quota_exceeded_until: $csv_download_quota_exceeded_until}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateTeamCsvDownloadQuotaMutationFn = Apollo.MutationFunction<UpdateTeamCsvDownloadQuotaMutation, UpdateTeamCsvDownloadQuotaMutationVariables>;

/**
 * __useUpdateTeamCsvDownloadQuotaMutation__
 *
 * To run a mutation, you first call `useUpdateTeamCsvDownloadQuotaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamCsvDownloadQuotaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamCsvDownloadQuotaMutation, { data, loading, error }] = useUpdateTeamCsvDownloadQuotaMutation({
 *   variables: {
 *      id: // value for 'id'
 *      csv_download_quota_exceeded_until: // value for 'csv_download_quota_exceeded_until'
 *   },
 * });
 */
export function useUpdateTeamCsvDownloadQuotaMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTeamCsvDownloadQuotaMutation, UpdateTeamCsvDownloadQuotaMutationVariables>) {
        return Apollo.useMutation<UpdateTeamCsvDownloadQuotaMutation, UpdateTeamCsvDownloadQuotaMutationVariables>(UpdateTeamCsvDownloadQuotaDocument, baseOptions);
      }
export type UpdateTeamCsvDownloadQuotaMutationHookResult = ReturnType<typeof useUpdateTeamCsvDownloadQuotaMutation>;
export type UpdateTeamCsvDownloadQuotaMutationResult = Apollo.MutationResult<UpdateTeamCsvDownloadQuotaMutation>;
export type UpdateTeamCsvDownloadQuotaMutationOptions = Apollo.BaseMutationOptions<UpdateTeamCsvDownloadQuotaMutation, UpdateTeamCsvDownloadQuotaMutationVariables>;
export const UpdateTeamQueryExecutionQuotaDocument = gql`
    mutation updateTeamQueryExecutionQuota($id: Int!, $execution_quota_exceeded_until: timestamptz!) {
  update_teams(
    where: {id: {_eq: $id}}
    _set: {execution_quota_exceeded_until: $execution_quota_exceeded_until}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateTeamQueryExecutionQuotaMutationFn = Apollo.MutationFunction<UpdateTeamQueryExecutionQuotaMutation, UpdateTeamQueryExecutionQuotaMutationVariables>;

/**
 * __useUpdateTeamQueryExecutionQuotaMutation__
 *
 * To run a mutation, you first call `useUpdateTeamQueryExecutionQuotaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamQueryExecutionQuotaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamQueryExecutionQuotaMutation, { data, loading, error }] = useUpdateTeamQueryExecutionQuotaMutation({
 *   variables: {
 *      id: // value for 'id'
 *      execution_quota_exceeded_until: // value for 'execution_quota_exceeded_until'
 *   },
 * });
 */
export function useUpdateTeamQueryExecutionQuotaMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTeamQueryExecutionQuotaMutation, UpdateTeamQueryExecutionQuotaMutationVariables>) {
        return Apollo.useMutation<UpdateTeamQueryExecutionQuotaMutation, UpdateTeamQueryExecutionQuotaMutationVariables>(UpdateTeamQueryExecutionQuotaDocument, baseOptions);
      }
export type UpdateTeamQueryExecutionQuotaMutationHookResult = ReturnType<typeof useUpdateTeamQueryExecutionQuotaMutation>;
export type UpdateTeamQueryExecutionQuotaMutationResult = Apollo.MutationResult<UpdateTeamQueryExecutionQuotaMutation>;
export type UpdateTeamQueryExecutionQuotaMutationOptions = Apollo.BaseMutationOptions<UpdateTeamQueryExecutionQuotaMutation, UpdateTeamQueryExecutionQuotaMutationVariables>;
export const GetUserForOverageDocument = gql`
    query GetUserForOverage($orbCustomerId: String!) {
  users(where: {orb_customer_id: {_eq: $orbCustomerId}}) {
    id
    max_executions_overage_cost_cents
    user_service_tier {
      id
      csv_downloads_per_month
      included_query_executions
      included_nanocredits
    }
    api_user_service_tier {
      id
      included_datapoints
    }
  }
}
    `;

/**
 * __useGetUserForOverageQuery__
 *
 * To run a query within a React component, call `useGetUserForOverageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserForOverageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserForOverageQuery({
 *   variables: {
 *      orbCustomerId: // value for 'orbCustomerId'
 *   },
 * });
 */
export function useGetUserForOverageQuery(baseOptions: Apollo.QueryHookOptions<GetUserForOverageQuery, GetUserForOverageQueryVariables>) {
        return Apollo.useQuery<GetUserForOverageQuery, GetUserForOverageQueryVariables>(GetUserForOverageDocument, baseOptions);
      }
export function useGetUserForOverageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserForOverageQuery, GetUserForOverageQueryVariables>) {
          return Apollo.useLazyQuery<GetUserForOverageQuery, GetUserForOverageQueryVariables>(GetUserForOverageDocument, baseOptions);
        }
export type GetUserForOverageQueryHookResult = ReturnType<typeof useGetUserForOverageQuery>;
export type GetUserForOverageLazyQueryHookResult = ReturnType<typeof useGetUserForOverageLazyQuery>;
export type GetUserForOverageQueryResult = Apollo.QueryResult<GetUserForOverageQuery, GetUserForOverageQueryVariables>;
export const UpdateUserCsvDownloadQuotaDocument = gql`
    mutation updateUserCSVDownloadQuota($id: Int!, $csv_download_quota_exceeded_until: timestamptz!) {
  update_users(
    where: {id: {_eq: $id}}
    _set: {csv_download_quota_exceeded_until: $csv_download_quota_exceeded_until}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateUserCsvDownloadQuotaMutationFn = Apollo.MutationFunction<UpdateUserCsvDownloadQuotaMutation, UpdateUserCsvDownloadQuotaMutationVariables>;

/**
 * __useUpdateUserCsvDownloadQuotaMutation__
 *
 * To run a mutation, you first call `useUpdateUserCsvDownloadQuotaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserCsvDownloadQuotaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserCsvDownloadQuotaMutation, { data, loading, error }] = useUpdateUserCsvDownloadQuotaMutation({
 *   variables: {
 *      id: // value for 'id'
 *      csv_download_quota_exceeded_until: // value for 'csv_download_quota_exceeded_until'
 *   },
 * });
 */
export function useUpdateUserCsvDownloadQuotaMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserCsvDownloadQuotaMutation, UpdateUserCsvDownloadQuotaMutationVariables>) {
        return Apollo.useMutation<UpdateUserCsvDownloadQuotaMutation, UpdateUserCsvDownloadQuotaMutationVariables>(UpdateUserCsvDownloadQuotaDocument, baseOptions);
      }
export type UpdateUserCsvDownloadQuotaMutationHookResult = ReturnType<typeof useUpdateUserCsvDownloadQuotaMutation>;
export type UpdateUserCsvDownloadQuotaMutationResult = Apollo.MutationResult<UpdateUserCsvDownloadQuotaMutation>;
export type UpdateUserCsvDownloadQuotaMutationOptions = Apollo.BaseMutationOptions<UpdateUserCsvDownloadQuotaMutation, UpdateUserCsvDownloadQuotaMutationVariables>;
export const UpdateUserQueryExecutionQuotaDocument = gql`
    mutation updateUserQueryExecutionQuota($id: Int!, $execution_quota_exceeded_until: timestamptz!) {
  update_users(
    where: {id: {_eq: $id}}
    _set: {execution_quota_exceeded_until: $execution_quota_exceeded_until}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateUserQueryExecutionQuotaMutationFn = Apollo.MutationFunction<UpdateUserQueryExecutionQuotaMutation, UpdateUserQueryExecutionQuotaMutationVariables>;

/**
 * __useUpdateUserQueryExecutionQuotaMutation__
 *
 * To run a mutation, you first call `useUpdateUserQueryExecutionQuotaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserQueryExecutionQuotaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserQueryExecutionQuotaMutation, { data, loading, error }] = useUpdateUserQueryExecutionQuotaMutation({
 *   variables: {
 *      id: // value for 'id'
 *      execution_quota_exceeded_until: // value for 'execution_quota_exceeded_until'
 *   },
 * });
 */
export function useUpdateUserQueryExecutionQuotaMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserQueryExecutionQuotaMutation, UpdateUserQueryExecutionQuotaMutationVariables>) {
        return Apollo.useMutation<UpdateUserQueryExecutionQuotaMutation, UpdateUserQueryExecutionQuotaMutationVariables>(UpdateUserQueryExecutionQuotaDocument, baseOptions);
      }
export type UpdateUserQueryExecutionQuotaMutationHookResult = ReturnType<typeof useUpdateUserQueryExecutionQuotaMutation>;
export type UpdateUserQueryExecutionQuotaMutationResult = Apollo.MutationResult<UpdateUserQueryExecutionQuotaMutation>;
export type UpdateUserQueryExecutionQuotaMutationOptions = Apollo.BaseMutationOptions<UpdateUserQueryExecutionQuotaMutation, UpdateUserQueryExecutionQuotaMutationVariables>;
export const GetResultDocument = gql`
    query GetResult($query_id: Int!, $parameters: [Parameter!]!, $can_refresh: Boolean!) {
  get_result_v4(
    query_id: $query_id
    parameters: $parameters
    can_refresh: $can_refresh
  ) {
    job_id
    result_id
    error_id
  }
}
    `;

/**
 * __useGetResultQuery__
 *
 * To run a query within a React component, call `useGetResultQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetResultQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetResultQuery({
 *   variables: {
 *      query_id: // value for 'query_id'
 *      parameters: // value for 'parameters'
 *      can_refresh: // value for 'can_refresh'
 *   },
 * });
 */
export function useGetResultQuery(baseOptions: Apollo.QueryHookOptions<GetResultQuery, GetResultQueryVariables>) {
        return Apollo.useQuery<GetResultQuery, GetResultQueryVariables>(GetResultDocument, baseOptions);
      }
export function useGetResultLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetResultQuery, GetResultQueryVariables>) {
          return Apollo.useLazyQuery<GetResultQuery, GetResultQueryVariables>(GetResultDocument, baseOptions);
        }
export type GetResultQueryHookResult = ReturnType<typeof useGetResultQuery>;
export type GetResultLazyQueryHookResult = ReturnType<typeof useGetResultLazyQuery>;
export type GetResultQueryResult = Apollo.QueryResult<GetResultQuery, GetResultQueryVariables>;
export const ListPopularDashboardTagsDocument = gql`
    query ListPopularDashboardTags($limit: Int!, $offset: Int!) {
  popular_dashboard_tags(
    order_by: [{popularity: desc}]
    limit: $limit
    offset: $offset
  ) {
    ...PopularDashboardTag
  }
}
    ${PopularDashboardTagFragmentDoc}`;

/**
 * __useListPopularDashboardTagsQuery__
 *
 * To run a query within a React component, call `useListPopularDashboardTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListPopularDashboardTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListPopularDashboardTagsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListPopularDashboardTagsQuery(baseOptions: Apollo.QueryHookOptions<ListPopularDashboardTagsQuery, ListPopularDashboardTagsQueryVariables>) {
        return Apollo.useQuery<ListPopularDashboardTagsQuery, ListPopularDashboardTagsQueryVariables>(ListPopularDashboardTagsDocument, baseOptions);
      }
export function useListPopularDashboardTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListPopularDashboardTagsQuery, ListPopularDashboardTagsQueryVariables>) {
          return Apollo.useLazyQuery<ListPopularDashboardTagsQuery, ListPopularDashboardTagsQueryVariables>(ListPopularDashboardTagsDocument, baseOptions);
        }
export type ListPopularDashboardTagsQueryHookResult = ReturnType<typeof useListPopularDashboardTagsQuery>;
export type ListPopularDashboardTagsLazyQueryHookResult = ReturnType<typeof useListPopularDashboardTagsLazyQuery>;
export type ListPopularDashboardTagsQueryResult = Apollo.QueryResult<ListPopularDashboardTagsQuery, ListPopularDashboardTagsQueryVariables>;
export const ListPopularQueryTagsDocument = gql`
    query ListPopularQueryTags($limit: Int!, $offset: Int!) {
  popular_query_tags(
    order_by: [{popularity: desc}]
    limit: $limit
    offset: $offset
  ) {
    ...PopularQueryTag
  }
}
    ${PopularQueryTagFragmentDoc}`;

/**
 * __useListPopularQueryTagsQuery__
 *
 * To run a query within a React component, call `useListPopularQueryTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListPopularQueryTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListPopularQueryTagsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useListPopularQueryTagsQuery(baseOptions: Apollo.QueryHookOptions<ListPopularQueryTagsQuery, ListPopularQueryTagsQueryVariables>) {
        return Apollo.useQuery<ListPopularQueryTagsQuery, ListPopularQueryTagsQueryVariables>(ListPopularQueryTagsDocument, baseOptions);
      }
export function useListPopularQueryTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListPopularQueryTagsQuery, ListPopularQueryTagsQueryVariables>) {
          return Apollo.useLazyQuery<ListPopularQueryTagsQuery, ListPopularQueryTagsQueryVariables>(ListPopularQueryTagsDocument, baseOptions);
        }
export type ListPopularQueryTagsQueryHookResult = ReturnType<typeof useListPopularQueryTagsQuery>;
export type ListPopularQueryTagsLazyQueryHookResult = ReturnType<typeof useListPopularQueryTagsLazyQuery>;
export type ListPopularQueryTagsQueryResult = Apollo.QueryResult<ListPopularQueryTagsQuery, ListPopularQueryTagsQueryVariables>;
export const FindTeamByStripeIdDocument = gql`
    query FindTeamByStripeId($stripe_customer_id: String!) {
  teams(where: {stripe_customer_id: {_eq: $stripe_customer_id}}) {
    id
    orb_customer_id
  }
}
    `;

/**
 * __useFindTeamByStripeIdQuery__
 *
 * To run a query within a React component, call `useFindTeamByStripeIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindTeamByStripeIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindTeamByStripeIdQuery({
 *   variables: {
 *      stripe_customer_id: // value for 'stripe_customer_id'
 *   },
 * });
 */
export function useFindTeamByStripeIdQuery(baseOptions: Apollo.QueryHookOptions<FindTeamByStripeIdQuery, FindTeamByStripeIdQueryVariables>) {
        return Apollo.useQuery<FindTeamByStripeIdQuery, FindTeamByStripeIdQueryVariables>(FindTeamByStripeIdDocument, baseOptions);
      }
export function useFindTeamByStripeIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindTeamByStripeIdQuery, FindTeamByStripeIdQueryVariables>) {
          return Apollo.useLazyQuery<FindTeamByStripeIdQuery, FindTeamByStripeIdQueryVariables>(FindTeamByStripeIdDocument, baseOptions);
        }
export type FindTeamByStripeIdQueryHookResult = ReturnType<typeof useFindTeamByStripeIdQuery>;
export type FindTeamByStripeIdLazyQueryHookResult = ReturnType<typeof useFindTeamByStripeIdLazyQuery>;
export type FindTeamByStripeIdQueryResult = Apollo.QueryResult<FindTeamByStripeIdQuery, FindTeamByStripeIdQueryVariables>;
export const FindSessionTeamPrivateInfoByIdDocument = gql`
    query FindSessionTeamPrivateInfoById($teamId: Int!) {
  memberships_private_details(where: {team: {id: {_eq: $teamId}}}) {
    team {
      members_details {
        stripe_customer_id
      }
    }
  }
}
    `;

/**
 * __useFindSessionTeamPrivateInfoByIdQuery__
 *
 * To run a query within a React component, call `useFindSessionTeamPrivateInfoByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindSessionTeamPrivateInfoByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindSessionTeamPrivateInfoByIdQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useFindSessionTeamPrivateInfoByIdQuery(baseOptions: Apollo.QueryHookOptions<FindSessionTeamPrivateInfoByIdQuery, FindSessionTeamPrivateInfoByIdQueryVariables>) {
        return Apollo.useQuery<FindSessionTeamPrivateInfoByIdQuery, FindSessionTeamPrivateInfoByIdQueryVariables>(FindSessionTeamPrivateInfoByIdDocument, baseOptions);
      }
export function useFindSessionTeamPrivateInfoByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindSessionTeamPrivateInfoByIdQuery, FindSessionTeamPrivateInfoByIdQueryVariables>) {
          return Apollo.useLazyQuery<FindSessionTeamPrivateInfoByIdQuery, FindSessionTeamPrivateInfoByIdQueryVariables>(FindSessionTeamPrivateInfoByIdDocument, baseOptions);
        }
export type FindSessionTeamPrivateInfoByIdQueryHookResult = ReturnType<typeof useFindSessionTeamPrivateInfoByIdQuery>;
export type FindSessionTeamPrivateInfoByIdLazyQueryHookResult = ReturnType<typeof useFindSessionTeamPrivateInfoByIdLazyQuery>;
export type FindSessionTeamPrivateInfoByIdQueryResult = Apollo.QueryResult<FindSessionTeamPrivateInfoByIdQuery, FindSessionTeamPrivateInfoByIdQueryVariables>;
export const TeamMembersDetailsDocument = gql`
    query TeamMembersDetails($id: Int!) {
  teams_by_pk(id: $id) {
    id
    members_details {
      id
      service_tier_id
    }
  }
}
    `;

/**
 * __useTeamMembersDetailsQuery__
 *
 * To run a query within a React component, call `useTeamMembersDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTeamMembersDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTeamMembersDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useTeamMembersDetailsQuery(baseOptions: Apollo.QueryHookOptions<TeamMembersDetailsQuery, TeamMembersDetailsQueryVariables>) {
        return Apollo.useQuery<TeamMembersDetailsQuery, TeamMembersDetailsQueryVariables>(TeamMembersDetailsDocument, baseOptions);
      }
export function useTeamMembersDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TeamMembersDetailsQuery, TeamMembersDetailsQueryVariables>) {
          return Apollo.useLazyQuery<TeamMembersDetailsQuery, TeamMembersDetailsQueryVariables>(TeamMembersDetailsDocument, baseOptions);
        }
export type TeamMembersDetailsQueryHookResult = ReturnType<typeof useTeamMembersDetailsQuery>;
export type TeamMembersDetailsLazyQueryHookResult = ReturnType<typeof useTeamMembersDetailsLazyQuery>;
export type TeamMembersDetailsQueryResult = Apollo.QueryResult<TeamMembersDetailsQuery, TeamMembersDetailsQueryVariables>;
export const FindTeamRoleDocument = gql`
    query FindTeamRole($user_id: Int, $team_id: Int) {
  memberships(where: {user_id: {_eq: $user_id}, team_id: {_eq: $team_id}}) {
    id
    team_id
    private_details {
      role
      status
    }
  }
}
    `;

/**
 * __useFindTeamRoleQuery__
 *
 * To run a query within a React component, call `useFindTeamRoleQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindTeamRoleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindTeamRoleQuery({
 *   variables: {
 *      user_id: // value for 'user_id'
 *      team_id: // value for 'team_id'
 *   },
 * });
 */
export function useFindTeamRoleQuery(baseOptions?: Apollo.QueryHookOptions<FindTeamRoleQuery, FindTeamRoleQueryVariables>) {
        return Apollo.useQuery<FindTeamRoleQuery, FindTeamRoleQueryVariables>(FindTeamRoleDocument, baseOptions);
      }
export function useFindTeamRoleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindTeamRoleQuery, FindTeamRoleQueryVariables>) {
          return Apollo.useLazyQuery<FindTeamRoleQuery, FindTeamRoleQueryVariables>(FindTeamRoleDocument, baseOptions);
        }
export type FindTeamRoleQueryHookResult = ReturnType<typeof useFindTeamRoleQuery>;
export type FindTeamRoleLazyQueryHookResult = ReturnType<typeof useFindTeamRoleLazyQuery>;
export type FindTeamRoleQueryResult = Apollo.QueryResult<FindTeamRoleQuery, FindTeamRoleQueryVariables>;
export const GetUserForEthereumAddressDocument = gql`
    query GetUserForEthereumAddress($ethereum_address: String!) {
  users(where: {ethereum_address: {_eq: $ethereum_address}}) {
    cognitoId: cognito_id
    id
    name
    ethereumAddress: ethereum_address
  }
}
    `;

/**
 * __useGetUserForEthereumAddressQuery__
 *
 * To run a query within a React component, call `useGetUserForEthereumAddressQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserForEthereumAddressQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserForEthereumAddressQuery({
 *   variables: {
 *      ethereum_address: // value for 'ethereum_address'
 *   },
 * });
 */
export function useGetUserForEthereumAddressQuery(baseOptions: Apollo.QueryHookOptions<GetUserForEthereumAddressQuery, GetUserForEthereumAddressQueryVariables>) {
        return Apollo.useQuery<GetUserForEthereumAddressQuery, GetUserForEthereumAddressQueryVariables>(GetUserForEthereumAddressDocument, baseOptions);
      }
export function useGetUserForEthereumAddressLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserForEthereumAddressQuery, GetUserForEthereumAddressQueryVariables>) {
          return Apollo.useLazyQuery<GetUserForEthereumAddressQuery, GetUserForEthereumAddressQueryVariables>(GetUserForEthereumAddressDocument, baseOptions);
        }
export type GetUserForEthereumAddressQueryHookResult = ReturnType<typeof useGetUserForEthereumAddressQuery>;
export type GetUserForEthereumAddressLazyQueryHookResult = ReturnType<typeof useGetUserForEthereumAddressLazyQuery>;
export type GetUserForEthereumAddressQueryResult = Apollo.QueryResult<GetUserForEthereumAddressQuery, GetUserForEthereumAddressQueryVariables>;
export const UpdateUsersEthereumAddressDocument = gql`
    mutation UpdateUsersEthereumAddress($cognito_id: uuid!, $ethereum_address: String!) {
  update_users(
    where: {cognito_id: {_eq: $cognito_id}}
    _set: {ethereum_address: $ethereum_address}
  ) {
    returning {
      ethereum_address
    }
  }
}
    `;
export type UpdateUsersEthereumAddressMutationFn = Apollo.MutationFunction<UpdateUsersEthereumAddressMutation, UpdateUsersEthereumAddressMutationVariables>;

/**
 * __useUpdateUsersEthereumAddressMutation__
 *
 * To run a mutation, you first call `useUpdateUsersEthereumAddressMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUsersEthereumAddressMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUsersEthereumAddressMutation, { data, loading, error }] = useUpdateUsersEthereumAddressMutation({
 *   variables: {
 *      cognito_id: // value for 'cognito_id'
 *      ethereum_address: // value for 'ethereum_address'
 *   },
 * });
 */
export function useUpdateUsersEthereumAddressMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUsersEthereumAddressMutation, UpdateUsersEthereumAddressMutationVariables>) {
        return Apollo.useMutation<UpdateUsersEthereumAddressMutation, UpdateUsersEthereumAddressMutationVariables>(UpdateUsersEthereumAddressDocument, baseOptions);
      }
export type UpdateUsersEthereumAddressMutationHookResult = ReturnType<typeof useUpdateUsersEthereumAddressMutation>;
export type UpdateUsersEthereumAddressMutationResult = Apollo.MutationResult<UpdateUsersEthereumAddressMutation>;
export type UpdateUsersEthereumAddressMutationOptions = Apollo.BaseMutationOptions<UpdateUsersEthereumAddressMutation, UpdateUsersEthereumAddressMutationVariables>;
export const GetNonceForEthereumAddrDocument = gql`
    query GetNonceForEthereumAddr($ethereum_address: String!) {
  user_nonce(where: {ethereum_address: {_eq: $ethereum_address}}) {
    ethereum_address
    nonce
  }
}
    `;

/**
 * __useGetNonceForEthereumAddrQuery__
 *
 * To run a query within a React component, call `useGetNonceForEthereumAddrQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNonceForEthereumAddrQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNonceForEthereumAddrQuery({
 *   variables: {
 *      ethereum_address: // value for 'ethereum_address'
 *   },
 * });
 */
export function useGetNonceForEthereumAddrQuery(baseOptions: Apollo.QueryHookOptions<GetNonceForEthereumAddrQuery, GetNonceForEthereumAddrQueryVariables>) {
        return Apollo.useQuery<GetNonceForEthereumAddrQuery, GetNonceForEthereumAddrQueryVariables>(GetNonceForEthereumAddrDocument, baseOptions);
      }
export function useGetNonceForEthereumAddrLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNonceForEthereumAddrQuery, GetNonceForEthereumAddrQueryVariables>) {
          return Apollo.useLazyQuery<GetNonceForEthereumAddrQuery, GetNonceForEthereumAddrQueryVariables>(GetNonceForEthereumAddrDocument, baseOptions);
        }
export type GetNonceForEthereumAddrQueryHookResult = ReturnType<typeof useGetNonceForEthereumAddrQuery>;
export type GetNonceForEthereumAddrLazyQueryHookResult = ReturnType<typeof useGetNonceForEthereumAddrLazyQuery>;
export type GetNonceForEthereumAddrQueryResult = Apollo.QueryResult<GetNonceForEthereumAddrQuery, GetNonceForEthereumAddrQueryVariables>;
export const UpsertNonceForEthereumAddrDocument = gql`
    mutation UpsertNonceForEthereumAddr($ethereum_address: String!, $nonce: String!) {
  insert_user_nonce_one(
    object: {ethereum_address: $ethereum_address, nonce: $nonce}
    on_conflict: {constraint: user_nonce_pkey, update_columns: nonce}
  ) {
    ethereum_address
    nonce
  }
}
    `;
export type UpsertNonceForEthereumAddrMutationFn = Apollo.MutationFunction<UpsertNonceForEthereumAddrMutation, UpsertNonceForEthereumAddrMutationVariables>;

/**
 * __useUpsertNonceForEthereumAddrMutation__
 *
 * To run a mutation, you first call `useUpsertNonceForEthereumAddrMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertNonceForEthereumAddrMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertNonceForEthereumAddrMutation, { data, loading, error }] = useUpsertNonceForEthereumAddrMutation({
 *   variables: {
 *      ethereum_address: // value for 'ethereum_address'
 *      nonce: // value for 'nonce'
 *   },
 * });
 */
export function useUpsertNonceForEthereumAddrMutation(baseOptions?: Apollo.MutationHookOptions<UpsertNonceForEthereumAddrMutation, UpsertNonceForEthereumAddrMutationVariables>) {
        return Apollo.useMutation<UpsertNonceForEthereumAddrMutation, UpsertNonceForEthereumAddrMutationVariables>(UpsertNonceForEthereumAddrDocument, baseOptions);
      }
export type UpsertNonceForEthereumAddrMutationHookResult = ReturnType<typeof useUpsertNonceForEthereumAddrMutation>;
export type UpsertNonceForEthereumAddrMutationResult = Apollo.MutationResult<UpsertNonceForEthereumAddrMutation>;
export type UpsertNonceForEthereumAddrMutationOptions = Apollo.BaseMutationOptions<UpsertNonceForEthereumAddrMutation, UpsertNonceForEthereumAddrMutationVariables>;
export const FindSessionUserDocument = gql`
    query FindSessionUser($sub: uuid!) {
  users(where: {private_info: {cognito_id: {_eq: $sub}}}) {
    ...SessionUser
  }
}
    ${SessionUserFragmentDoc}`;

/**
 * __useFindSessionUserQuery__
 *
 * To run a query within a React component, call `useFindSessionUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindSessionUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindSessionUserQuery({
 *   variables: {
 *      sub: // value for 'sub'
 *   },
 * });
 */
export function useFindSessionUserQuery(baseOptions: Apollo.QueryHookOptions<FindSessionUserQuery, FindSessionUserQueryVariables>) {
        return Apollo.useQuery<FindSessionUserQuery, FindSessionUserQueryVariables>(FindSessionUserDocument, baseOptions);
      }
export function useFindSessionUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindSessionUserQuery, FindSessionUserQueryVariables>) {
          return Apollo.useLazyQuery<FindSessionUserQuery, FindSessionUserQueryVariables>(FindSessionUserDocument, baseOptions);
        }
export type FindSessionUserQueryHookResult = ReturnType<typeof useFindSessionUserQuery>;
export type FindSessionUserLazyQueryHookResult = ReturnType<typeof useFindSessionUserLazyQuery>;
export type FindSessionUserQueryResult = Apollo.QueryResult<FindSessionUserQuery, FindSessionUserQueryVariables>;
export const FindUserByStripeIdDocument = gql`
    query FindUserByStripeId($customerId: String!) {
  users(where: {stripe_customer_id: {_eq: $customerId}}) {
    ...SessionUser
  }
}
    ${SessionUserFragmentDoc}`;

/**
 * __useFindUserByStripeIdQuery__
 *
 * To run a query within a React component, call `useFindUserByStripeIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindUserByStripeIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindUserByStripeIdQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *   },
 * });
 */
export function useFindUserByStripeIdQuery(baseOptions: Apollo.QueryHookOptions<FindUserByStripeIdQuery, FindUserByStripeIdQueryVariables>) {
        return Apollo.useQuery<FindUserByStripeIdQuery, FindUserByStripeIdQueryVariables>(FindUserByStripeIdDocument, baseOptions);
      }
export function useFindUserByStripeIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindUserByStripeIdQuery, FindUserByStripeIdQueryVariables>) {
          return Apollo.useLazyQuery<FindUserByStripeIdQuery, FindUserByStripeIdQueryVariables>(FindUserByStripeIdDocument, baseOptions);
        }
export type FindUserByStripeIdQueryHookResult = ReturnType<typeof useFindUserByStripeIdQuery>;
export type FindUserByStripeIdLazyQueryHookResult = ReturnType<typeof useFindUserByStripeIdLazyQuery>;
export type FindUserByStripeIdQueryResult = Apollo.QueryResult<FindUserByStripeIdQuery, FindUserByStripeIdQueryVariables>;
export const FindUserByOrbCustomerIdDocument = gql`
    query FindUserByOrbCustomerId($customerId: String!) {
  users(where: {orb_customer_id: {_eq: $customerId}}) {
    id
    name
    email
    orb_subscription_id
    orb_api_subscription_id
    api_service_tier_id
    max_executions_overage_cost_cents
    service_tier: user_service_tier {
      id
      name
      release_version
    }
  }
}
    `;

/**
 * __useFindUserByOrbCustomerIdQuery__
 *
 * To run a query within a React component, call `useFindUserByOrbCustomerIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindUserByOrbCustomerIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindUserByOrbCustomerIdQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *   },
 * });
 */
export function useFindUserByOrbCustomerIdQuery(baseOptions: Apollo.QueryHookOptions<FindUserByOrbCustomerIdQuery, FindUserByOrbCustomerIdQueryVariables>) {
        return Apollo.useQuery<FindUserByOrbCustomerIdQuery, FindUserByOrbCustomerIdQueryVariables>(FindUserByOrbCustomerIdDocument, baseOptions);
      }
export function useFindUserByOrbCustomerIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindUserByOrbCustomerIdQuery, FindUserByOrbCustomerIdQueryVariables>) {
          return Apollo.useLazyQuery<FindUserByOrbCustomerIdQuery, FindUserByOrbCustomerIdQueryVariables>(FindUserByOrbCustomerIdDocument, baseOptions);
        }
export type FindUserByOrbCustomerIdQueryHookResult = ReturnType<typeof useFindUserByOrbCustomerIdQuery>;
export type FindUserByOrbCustomerIdLazyQueryHookResult = ReturnType<typeof useFindUserByOrbCustomerIdLazyQuery>;
export type FindUserByOrbCustomerIdQueryResult = Apollo.QueryResult<FindUserByOrbCustomerIdQuery, FindUserByOrbCustomerIdQueryVariables>;
export const FindVisualDocument = gql`
    query FindVisual($id: Int!) {
  visualizations_by_pk(id: $id) {
    ...Visualization
  }
}
    ${VisualizationFragmentDoc}`;

/**
 * __useFindVisualQuery__
 *
 * To run a query within a React component, call `useFindVisualQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindVisualQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindVisualQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFindVisualQuery(baseOptions: Apollo.QueryHookOptions<FindVisualQuery, FindVisualQueryVariables>) {
        return Apollo.useQuery<FindVisualQuery, FindVisualQueryVariables>(FindVisualDocument, baseOptions);
      }
export function useFindVisualLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindVisualQuery, FindVisualQueryVariables>) {
          return Apollo.useLazyQuery<FindVisualQuery, FindVisualQueryVariables>(FindVisualDocument, baseOptions);
        }
export type FindVisualQueryHookResult = ReturnType<typeof useFindVisualQuery>;
export type FindVisualLazyQueryHookResult = ReturnType<typeof useFindVisualLazyQuery>;
export type FindVisualQueryResult = Apollo.QueryResult<FindVisualQuery, FindVisualQueryVariables>;
export const NlqModelsDocument = gql`
    query NlqModels {
  nlq_models
}
    `;

/**
 * __useNlqModelsQuery__
 *
 * To run a query within a React component, call `useNlqModelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNlqModelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNlqModelsQuery({
 *   variables: {
 *   },
 * });
 */
export function useNlqModelsQuery(baseOptions?: Apollo.QueryHookOptions<NlqModelsQuery, NlqModelsQueryVariables>) {
        return Apollo.useQuery<NlqModelsQuery, NlqModelsQueryVariables>(NlqModelsDocument, baseOptions);
      }
export function useNlqModelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NlqModelsQuery, NlqModelsQueryVariables>) {
          return Apollo.useLazyQuery<NlqModelsQuery, NlqModelsQueryVariables>(NlqModelsDocument, baseOptions);
        }
export type NlqModelsQueryHookResult = ReturnType<typeof useNlqModelsQuery>;
export type NlqModelsLazyQueryHookResult = ReturnType<typeof useNlqModelsLazyQuery>;
export type NlqModelsQueryResult = Apollo.QueryResult<NlqModelsQuery, NlqModelsQueryVariables>;
export const CompleteNlqModelDocument = gql`
    mutation CompleteNlqModel($model: String!, $prompt: String!, $table: String!) {
  complete_nlq_model(model: $model, prompt: $prompt, table: $table) {
    id
    response
  }
}
    `;
export type CompleteNlqModelMutationFn = Apollo.MutationFunction<CompleteNlqModelMutation, CompleteNlqModelMutationVariables>;

/**
 * __useCompleteNlqModelMutation__
 *
 * To run a mutation, you first call `useCompleteNlqModelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCompleteNlqModelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [completeNlqModelMutation, { data, loading, error }] = useCompleteNlqModelMutation({
 *   variables: {
 *      model: // value for 'model'
 *      prompt: // value for 'prompt'
 *      table: // value for 'table'
 *   },
 * });
 */
export function useCompleteNlqModelMutation(baseOptions?: Apollo.MutationHookOptions<CompleteNlqModelMutation, CompleteNlqModelMutationVariables>) {
        return Apollo.useMutation<CompleteNlqModelMutation, CompleteNlqModelMutationVariables>(CompleteNlqModelDocument, baseOptions);
      }
export type CompleteNlqModelMutationHookResult = ReturnType<typeof useCompleteNlqModelMutation>;
export type CompleteNlqModelMutationResult = Apollo.MutationResult<CompleteNlqModelMutation>;
export type CompleteNlqModelMutationOptions = Apollo.BaseMutationOptions<CompleteNlqModelMutation, CompleteNlqModelMutationVariables>;
export const InsertWandCompletionDocument = gql`
    mutation InsertWandCompletion($id: uuid!, $question: String!, $answer: String!, $user_id: Int!, $query_id: Int, $query_version: Int) {
  insert_wand_completions_one(
    object: {id: $id, question: $question, answer: $answer, user_id: $user_id, query_id: $query_id, query_version: $query_version}
  ) {
    id
  }
}
    `;
export type InsertWandCompletionMutationFn = Apollo.MutationFunction<InsertWandCompletionMutation, InsertWandCompletionMutationVariables>;

/**
 * __useInsertWandCompletionMutation__
 *
 * To run a mutation, you first call `useInsertWandCompletionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertWandCompletionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertWandCompletionMutation, { data, loading, error }] = useInsertWandCompletionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      question: // value for 'question'
 *      answer: // value for 'answer'
 *      user_id: // value for 'user_id'
 *      query_id: // value for 'query_id'
 *      query_version: // value for 'query_version'
 *   },
 * });
 */
export function useInsertWandCompletionMutation(baseOptions?: Apollo.MutationHookOptions<InsertWandCompletionMutation, InsertWandCompletionMutationVariables>) {
        return Apollo.useMutation<InsertWandCompletionMutation, InsertWandCompletionMutationVariables>(InsertWandCompletionDocument, baseOptions);
      }
export type InsertWandCompletionMutationHookResult = ReturnType<typeof useInsertWandCompletionMutation>;
export type InsertWandCompletionMutationResult = Apollo.MutationResult<InsertWandCompletionMutation>;
export type InsertWandCompletionMutationOptions = Apollo.BaseMutationOptions<InsertWandCompletionMutation, InsertWandCompletionMutationVariables>;
export const UpdateWandCompletionQueryDocument = gql`
    mutation UpdateWandCompletionQuery($id: uuid!, $query_id: Int, $query_version: Int) {
  update_wand_completions(
    where: {id: {_eq: $id}}
    _set: {query_id: $query_id, query_version: $query_version}
  ) {
    affected_rows
  }
}
    `;
export type UpdateWandCompletionQueryMutationFn = Apollo.MutationFunction<UpdateWandCompletionQueryMutation, UpdateWandCompletionQueryMutationVariables>;

/**
 * __useUpdateWandCompletionQueryMutation__
 *
 * To run a mutation, you first call `useUpdateWandCompletionQueryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWandCompletionQueryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWandCompletionQueryMutation, { data, loading, error }] = useUpdateWandCompletionQueryMutation({
 *   variables: {
 *      id: // value for 'id'
 *      query_id: // value for 'query_id'
 *      query_version: // value for 'query_version'
 *   },
 * });
 */
export function useUpdateWandCompletionQueryMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWandCompletionQueryMutation, UpdateWandCompletionQueryMutationVariables>) {
        return Apollo.useMutation<UpdateWandCompletionQueryMutation, UpdateWandCompletionQueryMutationVariables>(UpdateWandCompletionQueryDocument, baseOptions);
      }
export type UpdateWandCompletionQueryMutationHookResult = ReturnType<typeof useUpdateWandCompletionQueryMutation>;
export type UpdateWandCompletionQueryMutationResult = Apollo.MutationResult<UpdateWandCompletionQueryMutation>;
export type UpdateWandCompletionQueryMutationOptions = Apollo.BaseMutationOptions<UpdateWandCompletionQueryMutation, UpdateWandCompletionQueryMutationVariables>;
export const FindWandCompletionByQueryIdDocument = gql`
    query FindWandCompletionByQueryId($query_id: Int!) {
  wand_completions(
    where: {query_id: {_eq: $query_id}}
    order_by: {created_at: desc}
    limit: 1
  ) {
    id
    question
    answer
  }
}
    `;

/**
 * __useFindWandCompletionByQueryIdQuery__
 *
 * To run a query within a React component, call `useFindWandCompletionByQueryIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindWandCompletionByQueryIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindWandCompletionByQueryIdQuery({
 *   variables: {
 *      query_id: // value for 'query_id'
 *   },
 * });
 */
export function useFindWandCompletionByQueryIdQuery(baseOptions: Apollo.QueryHookOptions<FindWandCompletionByQueryIdQuery, FindWandCompletionByQueryIdQueryVariables>) {
        return Apollo.useQuery<FindWandCompletionByQueryIdQuery, FindWandCompletionByQueryIdQueryVariables>(FindWandCompletionByQueryIdDocument, baseOptions);
      }
export function useFindWandCompletionByQueryIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindWandCompletionByQueryIdQuery, FindWandCompletionByQueryIdQueryVariables>) {
          return Apollo.useLazyQuery<FindWandCompletionByQueryIdQuery, FindWandCompletionByQueryIdQueryVariables>(FindWandCompletionByQueryIdDocument, baseOptions);
        }
export type FindWandCompletionByQueryIdQueryHookResult = ReturnType<typeof useFindWandCompletionByQueryIdQuery>;
export type FindWandCompletionByQueryIdLazyQueryHookResult = ReturnType<typeof useFindWandCompletionByQueryIdLazyQuery>;
export type FindWandCompletionByQueryIdQueryResult = Apollo.QueryResult<FindWandCompletionByQueryIdQuery, FindWandCompletionByQueryIdQueryVariables>;
export const GenerateDataUploadUrlDocument = gql`
    mutation GenerateDataUploadUrl($content_length: Int!, $file_name: String!) {
  generate_data_upload_url(content_length: $content_length, file_name: $file_name) {
    url
  }
}
    `;
export type GenerateDataUploadUrlMutationFn = Apollo.MutationFunction<GenerateDataUploadUrlMutation, GenerateDataUploadUrlMutationVariables>;

/**
 * __useGenerateDataUploadUrlMutation__
 *
 * To run a mutation, you first call `useGenerateDataUploadUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateDataUploadUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateDataUploadUrlMutation, { data, loading, error }] = useGenerateDataUploadUrlMutation({
 *   variables: {
 *      content_length: // value for 'content_length'
 *      file_name: // value for 'file_name'
 *   },
 * });
 */
export function useGenerateDataUploadUrlMutation(baseOptions?: Apollo.MutationHookOptions<GenerateDataUploadUrlMutation, GenerateDataUploadUrlMutationVariables>) {
        return Apollo.useMutation<GenerateDataUploadUrlMutation, GenerateDataUploadUrlMutationVariables>(GenerateDataUploadUrlDocument, baseOptions);
      }
export type GenerateDataUploadUrlMutationHookResult = ReturnType<typeof useGenerateDataUploadUrlMutation>;
export type GenerateDataUploadUrlMutationResult = Apollo.MutationResult<GenerateDataUploadUrlMutation>;
export type GenerateDataUploadUrlMutationOptions = Apollo.BaseMutationOptions<GenerateDataUploadUrlMutation, GenerateDataUploadUrlMutationVariables>;
export const CreateFolderDocument = gql`
    mutation CreateFolder($name: String!, $icon: String!, $color: String!, $description: String, $team_id: Int) {
  create_folder(
    folder: {name: $name, icon: $icon, color: $color, description: $description, team_id: $team_id}
  ) {
    id
  }
}
    `;
export type CreateFolderMutationFn = Apollo.MutationFunction<CreateFolderMutation, CreateFolderMutationVariables>;

/**
 * __useCreateFolderMutation__
 *
 * To run a mutation, you first call `useCreateFolderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFolderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFolderMutation, { data, loading, error }] = useCreateFolderMutation({
 *   variables: {
 *      name: // value for 'name'
 *      icon: // value for 'icon'
 *      color: // value for 'color'
 *      description: // value for 'description'
 *      team_id: // value for 'team_id'
 *   },
 * });
 */
export function useCreateFolderMutation(baseOptions?: Apollo.MutationHookOptions<CreateFolderMutation, CreateFolderMutationVariables>) {
        return Apollo.useMutation<CreateFolderMutation, CreateFolderMutationVariables>(CreateFolderDocument, baseOptions);
      }
export type CreateFolderMutationHookResult = ReturnType<typeof useCreateFolderMutation>;
export type CreateFolderMutationResult = Apollo.MutationResult<CreateFolderMutation>;
export type CreateFolderMutationOptions = Apollo.BaseMutationOptions<CreateFolderMutation, CreateFolderMutationVariables>;
export const UploadedTablesDocument = gql`
    query UploadedTables {
  uploaded_tables {
    file_name
    table_name
    status
  }
}
    `;

/**
 * __useUploadedTablesQuery__
 *
 * To run a query within a React component, call `useUploadedTablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadedTablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadedTablesQuery({
 *   variables: {
 *   },
 * });
 */
export function useUploadedTablesQuery(baseOptions?: Apollo.QueryHookOptions<UploadedTablesQuery, UploadedTablesQueryVariables>) {
        return Apollo.useQuery<UploadedTablesQuery, UploadedTablesQueryVariables>(UploadedTablesDocument, baseOptions);
      }
export function useUploadedTablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadedTablesQuery, UploadedTablesQueryVariables>) {
          return Apollo.useLazyQuery<UploadedTablesQuery, UploadedTablesQueryVariables>(UploadedTablesDocument, baseOptions);
        }
export type UploadedTablesQueryHookResult = ReturnType<typeof useUploadedTablesQuery>;
export type UploadedTablesLazyQueryHookResult = ReturnType<typeof useUploadedTablesLazyQuery>;
export type UploadedTablesQueryResult = Apollo.QueryResult<UploadedTablesQuery, UploadedTablesQueryVariables>;
export const DefaultV2UserServiceTierDocument = gql`
    query DefaultV2UserServiceTier {
  user_service_tiers_by_pk(id: 1) {
    id
    name
    base_monthly_price_dollars_cents
    included_nanocredits
    nanocredits_cost_cents
    max_private_dashboards
    max_private_queries
    csv_downloads_per_month
  }
}
    `;

/**
 * __useDefaultV2UserServiceTierQuery__
 *
 * To run a query within a React component, call `useDefaultV2UserServiceTierQuery` and pass it any options that fit your needs.
 * When your component renders, `useDefaultV2UserServiceTierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDefaultV2UserServiceTierQuery({
 *   variables: {
 *   },
 * });
 */
export function useDefaultV2UserServiceTierQuery(baseOptions?: Apollo.QueryHookOptions<DefaultV2UserServiceTierQuery, DefaultV2UserServiceTierQueryVariables>) {
        return Apollo.useQuery<DefaultV2UserServiceTierQuery, DefaultV2UserServiceTierQueryVariables>(DefaultV2UserServiceTierDocument, baseOptions);
      }
export function useDefaultV2UserServiceTierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DefaultV2UserServiceTierQuery, DefaultV2UserServiceTierQueryVariables>) {
          return Apollo.useLazyQuery<DefaultV2UserServiceTierQuery, DefaultV2UserServiceTierQueryVariables>(DefaultV2UserServiceTierDocument, baseOptions);
        }
export type DefaultV2UserServiceTierQueryHookResult = ReturnType<typeof useDefaultV2UserServiceTierQuery>;
export type DefaultV2UserServiceTierLazyQueryHookResult = ReturnType<typeof useDefaultV2UserServiceTierLazyQuery>;
export type DefaultV2UserServiceTierQueryResult = Apollo.QueryResult<DefaultV2UserServiceTierQuery, DefaultV2UserServiceTierQueryVariables>;
export const GetAllV2TeamServiceTiersDocument = gql`
    query GetAllV2TeamServiceTiers {
  team_service_tiers(
    where: {_or: [{release_version: {_eq: "v2"}}, {_and: {id: {_eq: 1}}}], _and: {is_public: {_eq: true}}}
    order_by: [{base_monthly_price_dollars_cents: asc}]
  ) {
    id
    name
    base_monthly_price_dollars_cents
    is_public
    included_nanocredits
    nanocredits_cost_cents
    max_private_dashboards
    max_private_queries
    csv_downloads_per_month
    release_version
  }
}
    `;

/**
 * __useGetAllV2TeamServiceTiersQuery__
 *
 * To run a query within a React component, call `useGetAllV2TeamServiceTiersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllV2TeamServiceTiersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllV2TeamServiceTiersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllV2TeamServiceTiersQuery(baseOptions?: Apollo.QueryHookOptions<GetAllV2TeamServiceTiersQuery, GetAllV2TeamServiceTiersQueryVariables>) {
        return Apollo.useQuery<GetAllV2TeamServiceTiersQuery, GetAllV2TeamServiceTiersQueryVariables>(GetAllV2TeamServiceTiersDocument, baseOptions);
      }
export function useGetAllV2TeamServiceTiersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllV2TeamServiceTiersQuery, GetAllV2TeamServiceTiersQueryVariables>) {
          return Apollo.useLazyQuery<GetAllV2TeamServiceTiersQuery, GetAllV2TeamServiceTiersQueryVariables>(GetAllV2TeamServiceTiersDocument, baseOptions);
        }
export type GetAllV2TeamServiceTiersQueryHookResult = ReturnType<typeof useGetAllV2TeamServiceTiersQuery>;
export type GetAllV2TeamServiceTiersLazyQueryHookResult = ReturnType<typeof useGetAllV2TeamServiceTiersLazyQuery>;
export type GetAllV2TeamServiceTiersQueryResult = Apollo.QueryResult<GetAllV2TeamServiceTiersQuery, GetAllV2TeamServiceTiersQueryVariables>;
export const GetUserFreeTeamsCountDocument = gql`
    query GetUserFreeTeamsCount($user_id: Int!) {
  teams_aggregate(
    where: {memberships: {user_id: {_eq: $user_id}, private_details: {role: {_eq: "admin"}}}, members_details: {service_tier_id: {_eq: 1}}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetUserFreeTeamsCountQuery__
 *
 * To run a query within a React component, call `useGetUserFreeTeamsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserFreeTeamsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserFreeTeamsCountQuery({
 *   variables: {
 *      user_id: // value for 'user_id'
 *   },
 * });
 */
export function useGetUserFreeTeamsCountQuery(baseOptions: Apollo.QueryHookOptions<GetUserFreeTeamsCountQuery, GetUserFreeTeamsCountQueryVariables>) {
        return Apollo.useQuery<GetUserFreeTeamsCountQuery, GetUserFreeTeamsCountQueryVariables>(GetUserFreeTeamsCountDocument, baseOptions);
      }
export function useGetUserFreeTeamsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserFreeTeamsCountQuery, GetUserFreeTeamsCountQueryVariables>) {
          return Apollo.useLazyQuery<GetUserFreeTeamsCountQuery, GetUserFreeTeamsCountQueryVariables>(GetUserFreeTeamsCountDocument, baseOptions);
        }
export type GetUserFreeTeamsCountQueryHookResult = ReturnType<typeof useGetUserFreeTeamsCountQuery>;
export type GetUserFreeTeamsCountLazyQueryHookResult = ReturnType<typeof useGetUserFreeTeamsCountLazyQuery>;
export type GetUserFreeTeamsCountQueryResult = Apollo.QueryResult<GetUserFreeTeamsCountQuery, GetUserFreeTeamsCountQueryVariables>;
export const CreateUserApiKeyDocument = gql`
    mutation CreateUserApiKey($name: String!) {
  create_user_api_key(name: $name) {
    id
    key
    name
  }
}
    `;
export type CreateUserApiKeyMutationFn = Apollo.MutationFunction<CreateUserApiKeyMutation, CreateUserApiKeyMutationVariables>;

/**
 * __useCreateUserApiKeyMutation__
 *
 * To run a mutation, you first call `useCreateUserApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserApiKeyMutation, { data, loading, error }] = useCreateUserApiKeyMutation({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useCreateUserApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserApiKeyMutation, CreateUserApiKeyMutationVariables>) {
        return Apollo.useMutation<CreateUserApiKeyMutation, CreateUserApiKeyMutationVariables>(CreateUserApiKeyDocument, baseOptions);
      }
export type CreateUserApiKeyMutationHookResult = ReturnType<typeof useCreateUserApiKeyMutation>;
export type CreateUserApiKeyMutationResult = Apollo.MutationResult<CreateUserApiKeyMutation>;
export type CreateUserApiKeyMutationOptions = Apollo.BaseMutationOptions<CreateUserApiKeyMutation, CreateUserApiKeyMutationVariables>;
export const DeleteUserApiKeyDocument = gql`
    mutation DeleteUserApiKey($id: String!) {
  delete_user_api_key(id: $id) {
    id
  }
}
    `;
export type DeleteUserApiKeyMutationFn = Apollo.MutationFunction<DeleteUserApiKeyMutation, DeleteUserApiKeyMutationVariables>;

/**
 * __useDeleteUserApiKeyMutation__
 *
 * To run a mutation, you first call `useDeleteUserApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserApiKeyMutation, { data, loading, error }] = useDeleteUserApiKeyMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserApiKeyMutation, DeleteUserApiKeyMutationVariables>) {
        return Apollo.useMutation<DeleteUserApiKeyMutation, DeleteUserApiKeyMutationVariables>(DeleteUserApiKeyDocument, baseOptions);
      }
export type DeleteUserApiKeyMutationHookResult = ReturnType<typeof useDeleteUserApiKeyMutation>;
export type DeleteUserApiKeyMutationResult = Apollo.MutationResult<DeleteUserApiKeyMutation>;
export type DeleteUserApiKeyMutationOptions = Apollo.BaseMutationOptions<DeleteUserApiKeyMutation, DeleteUserApiKeyMutationVariables>;
export const GetUserApiKeysDocument = gql`
    query GetUserApiKeys {
  user_api_keys {
    keys {
      __typename
      id
      name
      suffix
    }
  }
}
    `;

/**
 * __useGetUserApiKeysQuery__
 *
 * To run a query within a React component, call `useGetUserApiKeysQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserApiKeysQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserApiKeysQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUserApiKeysQuery(baseOptions?: Apollo.QueryHookOptions<GetUserApiKeysQuery, GetUserApiKeysQueryVariables>) {
        return Apollo.useQuery<GetUserApiKeysQuery, GetUserApiKeysQueryVariables>(GetUserApiKeysDocument, baseOptions);
      }
export function useGetUserApiKeysLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserApiKeysQuery, GetUserApiKeysQueryVariables>) {
          return Apollo.useLazyQuery<GetUserApiKeysQuery, GetUserApiKeysQueryVariables>(GetUserApiKeysDocument, baseOptions);
        }
export type GetUserApiKeysQueryHookResult = ReturnType<typeof useGetUserApiKeysQuery>;
export type GetUserApiKeysLazyQueryHookResult = ReturnType<typeof useGetUserApiKeysLazyQuery>;
export type GetUserApiKeysQueryResult = Apollo.QueryResult<GetUserApiKeysQuery, GetUserApiKeysQueryVariables>;
export const ListInvoicesDocument = gql`
    query ListInvoices {
  get_invoices {
    invoices {
      plan_display_name
      source
      date
      status
      href
      amount_display
      currency_key
    }
  }
}
    `;

/**
 * __useListInvoicesQuery__
 *
 * To run a query within a React component, call `useListInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListInvoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function useListInvoicesQuery(baseOptions?: Apollo.QueryHookOptions<ListInvoicesQuery, ListInvoicesQueryVariables>) {
        return Apollo.useQuery<ListInvoicesQuery, ListInvoicesQueryVariables>(ListInvoicesDocument, baseOptions);
      }
export function useListInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListInvoicesQuery, ListInvoicesQueryVariables>) {
          return Apollo.useLazyQuery<ListInvoicesQuery, ListInvoicesQueryVariables>(ListInvoicesDocument, baseOptions);
        }
export type ListInvoicesQueryHookResult = ReturnType<typeof useListInvoicesQuery>;
export type ListInvoicesLazyQueryHookResult = ReturnType<typeof useListInvoicesLazyQuery>;
export type ListInvoicesQueryResult = Apollo.QueryResult<ListInvoicesQuery, ListInvoicesQueryVariables>;
export const GetMaxExecutionsOverageCostCentsDocument = gql`
    query GetMaxExecutionsOverageCostCents($id: Int!) {
  users_by_pk(id: $id) {
    id
    max_executions_overage_cost_cents
  }
}
    `;

/**
 * __useGetMaxExecutionsOverageCostCentsQuery__
 *
 * To run a query within a React component, call `useGetMaxExecutionsOverageCostCentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMaxExecutionsOverageCostCentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMaxExecutionsOverageCostCentsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetMaxExecutionsOverageCostCentsQuery(baseOptions: Apollo.QueryHookOptions<GetMaxExecutionsOverageCostCentsQuery, GetMaxExecutionsOverageCostCentsQueryVariables>) {
        return Apollo.useQuery<GetMaxExecutionsOverageCostCentsQuery, GetMaxExecutionsOverageCostCentsQueryVariables>(GetMaxExecutionsOverageCostCentsDocument, baseOptions);
      }
export function useGetMaxExecutionsOverageCostCentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMaxExecutionsOverageCostCentsQuery, GetMaxExecutionsOverageCostCentsQueryVariables>) {
          return Apollo.useLazyQuery<GetMaxExecutionsOverageCostCentsQuery, GetMaxExecutionsOverageCostCentsQueryVariables>(GetMaxExecutionsOverageCostCentsDocument, baseOptions);
        }
export type GetMaxExecutionsOverageCostCentsQueryHookResult = ReturnType<typeof useGetMaxExecutionsOverageCostCentsQuery>;
export type GetMaxExecutionsOverageCostCentsLazyQueryHookResult = ReturnType<typeof useGetMaxExecutionsOverageCostCentsLazyQuery>;
export type GetMaxExecutionsOverageCostCentsQueryResult = Apollo.QueryResult<GetMaxExecutionsOverageCostCentsQuery, GetMaxExecutionsOverageCostCentsQueryVariables>;
export const SetMaxExecutionsOverageCostCentsDocument = gql`
    mutation SetMaxExecutionsOverageCostCents($max_executions_overage_cost_cents: Int) {
  set_max_executions_overage_cost_cents(
    max_executions_overage_cost_cents: $max_executions_overage_cost_cents
  ) {
    user {
      id
      max_executions_overage_cost_cents
      execution_quota_exceeded_until
    }
  }
}
    `;
export type SetMaxExecutionsOverageCostCentsMutationFn = Apollo.MutationFunction<SetMaxExecutionsOverageCostCentsMutation, SetMaxExecutionsOverageCostCentsMutationVariables>;

/**
 * __useSetMaxExecutionsOverageCostCentsMutation__
 *
 * To run a mutation, you first call `useSetMaxExecutionsOverageCostCentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetMaxExecutionsOverageCostCentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setMaxExecutionsOverageCostCentsMutation, { data, loading, error }] = useSetMaxExecutionsOverageCostCentsMutation({
 *   variables: {
 *      max_executions_overage_cost_cents: // value for 'max_executions_overage_cost_cents'
 *   },
 * });
 */
export function useSetMaxExecutionsOverageCostCentsMutation(baseOptions?: Apollo.MutationHookOptions<SetMaxExecutionsOverageCostCentsMutation, SetMaxExecutionsOverageCostCentsMutationVariables>) {
        return Apollo.useMutation<SetMaxExecutionsOverageCostCentsMutation, SetMaxExecutionsOverageCostCentsMutationVariables>(SetMaxExecutionsOverageCostCentsDocument, baseOptions);
      }
export type SetMaxExecutionsOverageCostCentsMutationHookResult = ReturnType<typeof useSetMaxExecutionsOverageCostCentsMutation>;
export type SetMaxExecutionsOverageCostCentsMutationResult = Apollo.MutationResult<SetMaxExecutionsOverageCostCentsMutation>;
export type SetMaxExecutionsOverageCostCentsMutationOptions = Apollo.BaseMutationOptions<SetMaxExecutionsOverageCostCentsMutation, SetMaxExecutionsOverageCostCentsMutationVariables>;
export const GetUpcomingInvoiceDocument = gql`
    query GetUpcomingInvoice {
  upcoming_invoice: get_upcoming_invoice {
    invoice {
      amount_due
      target_date
      currency
      hosted_invoice_url
    }
  }
}
    `;

/**
 * __useGetUpcomingInvoiceQuery__
 *
 * To run a query within a React component, call `useGetUpcomingInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUpcomingInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUpcomingInvoiceQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUpcomingInvoiceQuery(baseOptions?: Apollo.QueryHookOptions<GetUpcomingInvoiceQuery, GetUpcomingInvoiceQueryVariables>) {
        return Apollo.useQuery<GetUpcomingInvoiceQuery, GetUpcomingInvoiceQueryVariables>(GetUpcomingInvoiceDocument, baseOptions);
      }
export function useGetUpcomingInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUpcomingInvoiceQuery, GetUpcomingInvoiceQueryVariables>) {
          return Apollo.useLazyQuery<GetUpcomingInvoiceQuery, GetUpcomingInvoiceQueryVariables>(GetUpcomingInvoiceDocument, baseOptions);
        }
export type GetUpcomingInvoiceQueryHookResult = ReturnType<typeof useGetUpcomingInvoiceQuery>;
export type GetUpcomingInvoiceLazyQueryHookResult = ReturnType<typeof useGetUpcomingInvoiceLazyQuery>;
export type GetUpcomingInvoiceQueryResult = Apollo.QueryResult<GetUpcomingInvoiceQuery, GetUpcomingInvoiceQueryVariables>;
export const GetTeamUpcomingInvoiceDocument = gql`
    query GetTeamUpcomingInvoice($teamId: Int!) {
  upcoming_invoice: get_team_upcoming_invoice(team_id: $teamId) {
    invoice {
      amount_due
      target_date
      currency
      hosted_invoice_url
    }
  }
}
    `;

/**
 * __useGetTeamUpcomingInvoiceQuery__
 *
 * To run a query within a React component, call `useGetTeamUpcomingInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamUpcomingInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamUpcomingInvoiceQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamUpcomingInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetTeamUpcomingInvoiceQuery, GetTeamUpcomingInvoiceQueryVariables>) {
        return Apollo.useQuery<GetTeamUpcomingInvoiceQuery, GetTeamUpcomingInvoiceQueryVariables>(GetTeamUpcomingInvoiceDocument, baseOptions);
      }
export function useGetTeamUpcomingInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamUpcomingInvoiceQuery, GetTeamUpcomingInvoiceQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamUpcomingInvoiceQuery, GetTeamUpcomingInvoiceQueryVariables>(GetTeamUpcomingInvoiceDocument, baseOptions);
        }
export type GetTeamUpcomingInvoiceQueryHookResult = ReturnType<typeof useGetTeamUpcomingInvoiceQuery>;
export type GetTeamUpcomingInvoiceLazyQueryHookResult = ReturnType<typeof useGetTeamUpcomingInvoiceLazyQuery>;
export type GetTeamUpcomingInvoiceQueryResult = Apollo.QueryResult<GetTeamUpcomingInvoiceQuery, GetTeamUpcomingInvoiceQueryVariables>;
export const GetApiUpcomingInvoiceDocument = gql`
    query GetApiUpcomingInvoice {
  upcoming_invoice: get_api_upcoming_invoice {
    invoice {
      amount_due
      target_date
      currency
      hosted_invoice_url
    }
  }
}
    `;

/**
 * __useGetApiUpcomingInvoiceQuery__
 *
 * To run a query within a React component, call `useGetApiUpcomingInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiUpcomingInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiUpcomingInvoiceQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetApiUpcomingInvoiceQuery(baseOptions?: Apollo.QueryHookOptions<GetApiUpcomingInvoiceQuery, GetApiUpcomingInvoiceQueryVariables>) {
        return Apollo.useQuery<GetApiUpcomingInvoiceQuery, GetApiUpcomingInvoiceQueryVariables>(GetApiUpcomingInvoiceDocument, baseOptions);
      }
export function useGetApiUpcomingInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiUpcomingInvoiceQuery, GetApiUpcomingInvoiceQueryVariables>) {
          return Apollo.useLazyQuery<GetApiUpcomingInvoiceQuery, GetApiUpcomingInvoiceQueryVariables>(GetApiUpcomingInvoiceDocument, baseOptions);
        }
export type GetApiUpcomingInvoiceQueryHookResult = ReturnType<typeof useGetApiUpcomingInvoiceQuery>;
export type GetApiUpcomingInvoiceLazyQueryHookResult = ReturnType<typeof useGetApiUpcomingInvoiceLazyQuery>;
export type GetApiUpcomingInvoiceQueryResult = Apollo.QueryResult<GetApiUpcomingInvoiceQuery, GetApiUpcomingInvoiceQueryVariables>;
export const CancelPendingUserSubscriptionUpdateDocument = gql`
    mutation CancelPendingUserSubscriptionUpdate {
  cancel_user_pending_subscription_change {
    ok
  }
}
    `;
export type CancelPendingUserSubscriptionUpdateMutationFn = Apollo.MutationFunction<CancelPendingUserSubscriptionUpdateMutation, CancelPendingUserSubscriptionUpdateMutationVariables>;

/**
 * __useCancelPendingUserSubscriptionUpdateMutation__
 *
 * To run a mutation, you first call `useCancelPendingUserSubscriptionUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelPendingUserSubscriptionUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelPendingUserSubscriptionUpdateMutation, { data, loading, error }] = useCancelPendingUserSubscriptionUpdateMutation({
 *   variables: {
 *   },
 * });
 */
export function useCancelPendingUserSubscriptionUpdateMutation(baseOptions?: Apollo.MutationHookOptions<CancelPendingUserSubscriptionUpdateMutation, CancelPendingUserSubscriptionUpdateMutationVariables>) {
        return Apollo.useMutation<CancelPendingUserSubscriptionUpdateMutation, CancelPendingUserSubscriptionUpdateMutationVariables>(CancelPendingUserSubscriptionUpdateDocument, baseOptions);
      }
export type CancelPendingUserSubscriptionUpdateMutationHookResult = ReturnType<typeof useCancelPendingUserSubscriptionUpdateMutation>;
export type CancelPendingUserSubscriptionUpdateMutationResult = Apollo.MutationResult<CancelPendingUserSubscriptionUpdateMutation>;
export type CancelPendingUserSubscriptionUpdateMutationOptions = Apollo.BaseMutationOptions<CancelPendingUserSubscriptionUpdateMutation, CancelPendingUserSubscriptionUpdateMutationVariables>;
export const GetPendingUpdatesDocument = gql`
    query GetPendingUpdates {
  pending_user_subscription_updates {
    update_date
    user_service_tier {
      name
    }
    update_type
  }
}
    `;

/**
 * __useGetPendingUpdatesQuery__
 *
 * To run a query within a React component, call `useGetPendingUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPendingUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPendingUpdatesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPendingUpdatesQuery(baseOptions?: Apollo.QueryHookOptions<GetPendingUpdatesQuery, GetPendingUpdatesQueryVariables>) {
        return Apollo.useQuery<GetPendingUpdatesQuery, GetPendingUpdatesQueryVariables>(GetPendingUpdatesDocument, baseOptions);
      }
export function useGetPendingUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPendingUpdatesQuery, GetPendingUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<GetPendingUpdatesQuery, GetPendingUpdatesQueryVariables>(GetPendingUpdatesDocument, baseOptions);
        }
export type GetPendingUpdatesQueryHookResult = ReturnType<typeof useGetPendingUpdatesQuery>;
export type GetPendingUpdatesLazyQueryHookResult = ReturnType<typeof useGetPendingUpdatesLazyQuery>;
export type GetPendingUpdatesQueryResult = Apollo.QueryResult<GetPendingUpdatesQuery, GetPendingUpdatesQueryVariables>;
export const UserExtraCreditsCentsDocument = gql`
    query UserExtraCreditsCents {
  billable_usage {
    extra_credits_cents
  }
}
    `;

/**
 * __useUserExtraCreditsCentsQuery__
 *
 * To run a query within a React component, call `useUserExtraCreditsCentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserExtraCreditsCentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserExtraCreditsCentsQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserExtraCreditsCentsQuery(baseOptions?: Apollo.QueryHookOptions<UserExtraCreditsCentsQuery, UserExtraCreditsCentsQueryVariables>) {
        return Apollo.useQuery<UserExtraCreditsCentsQuery, UserExtraCreditsCentsQueryVariables>(UserExtraCreditsCentsDocument, baseOptions);
      }
export function useUserExtraCreditsCentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserExtraCreditsCentsQuery, UserExtraCreditsCentsQueryVariables>) {
          return Apollo.useLazyQuery<UserExtraCreditsCentsQuery, UserExtraCreditsCentsQueryVariables>(UserExtraCreditsCentsDocument, baseOptions);
        }
export type UserExtraCreditsCentsQueryHookResult = ReturnType<typeof useUserExtraCreditsCentsQuery>;
export type UserExtraCreditsCentsLazyQueryHookResult = ReturnType<typeof useUserExtraCreditsCentsLazyQuery>;
export type UserExtraCreditsCentsQueryResult = Apollo.QueryResult<UserExtraCreditsCentsQuery, UserExtraCreditsCentsQueryVariables>;
export const GetUserTeamsCountDocument = gql`
    query GetUserTeamsCount($user_id: Int!) {
  teams_aggregate(
    where: {memberships: {user_id: {_eq: $user_id}, private_details: {role: {_eq: "admin"}}}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetUserTeamsCountQuery__
 *
 * To run a query within a React component, call `useGetUserTeamsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserTeamsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserTeamsCountQuery({
 *   variables: {
 *      user_id: // value for 'user_id'
 *   },
 * });
 */
export function useGetUserTeamsCountQuery(baseOptions: Apollo.QueryHookOptions<GetUserTeamsCountQuery, GetUserTeamsCountQueryVariables>) {
        return Apollo.useQuery<GetUserTeamsCountQuery, GetUserTeamsCountQueryVariables>(GetUserTeamsCountDocument, baseOptions);
      }
export function useGetUserTeamsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserTeamsCountQuery, GetUserTeamsCountQueryVariables>) {
          return Apollo.useLazyQuery<GetUserTeamsCountQuery, GetUserTeamsCountQueryVariables>(GetUserTeamsCountDocument, baseOptions);
        }
export type GetUserTeamsCountQueryHookResult = ReturnType<typeof useGetUserTeamsCountQuery>;
export type GetUserTeamsCountLazyQueryHookResult = ReturnType<typeof useGetUserTeamsCountLazyQuery>;
export type GetUserTeamsCountQueryResult = Apollo.QueryResult<GetUserTeamsCountQuery, GetUserTeamsCountQueryVariables>;
export const GetUserUsageDocument = gql`
    query GetUserUsage($id: Int!) {
  users_by_pk(id: $id) {
    id
    max_executions_overage_cost_cents
    private_info {
      max_overage_cents
    }
    service_tier: user_service_tier {
      id
      max_private_queries
      max_private_dashboards
      csv_downloads_per_month
      included_query_executions
      nanocredits_cost_cents
    }
  }
  dashboards_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, team_id: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
  queries_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, is_temp: {_eq: false}, team_id: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
  billable_usage {
    query_executions
    csv_downloads
    datapoints_read
    credits_used
    credits_included
    extra_credits_cents
    max_extra_credits_cents
  }
}
    `;

/**
 * __useGetUserUsageQuery__
 *
 * To run a query within a React component, call `useGetUserUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserUsageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserUsageQuery(baseOptions: Apollo.QueryHookOptions<GetUserUsageQuery, GetUserUsageQueryVariables>) {
        return Apollo.useQuery<GetUserUsageQuery, GetUserUsageQueryVariables>(GetUserUsageDocument, baseOptions);
      }
export function useGetUserUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserUsageQuery, GetUserUsageQueryVariables>) {
          return Apollo.useLazyQuery<GetUserUsageQuery, GetUserUsageQueryVariables>(GetUserUsageDocument, baseOptions);
        }
export type GetUserUsageQueryHookResult = ReturnType<typeof useGetUserUsageQuery>;
export type GetUserUsageLazyQueryHookResult = ReturnType<typeof useGetUserUsageLazyQuery>;
export type GetUserUsageQueryResult = Apollo.QueryResult<GetUserUsageQuery, GetUserUsageQueryVariables>;
export const MigrateContentDocument = gql`
    mutation MigrateContent($teamId: Int!, $redirect: Boolean) {
  migrate_content(team_id: $teamId, redirect: $redirect) {
    total_dashboards
    migrated_dashboards
    total_queries
    migrated_queries
  }
}
    `;
export type MigrateContentMutationFn = Apollo.MutationFunction<MigrateContentMutation, MigrateContentMutationVariables>;

/**
 * __useMigrateContentMutation__
 *
 * To run a mutation, you first call `useMigrateContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMigrateContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [migrateContentMutation, { data, loading, error }] = useMigrateContentMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      redirect: // value for 'redirect'
 *   },
 * });
 */
export function useMigrateContentMutation(baseOptions?: Apollo.MutationHookOptions<MigrateContentMutation, MigrateContentMutationVariables>) {
        return Apollo.useMutation<MigrateContentMutation, MigrateContentMutationVariables>(MigrateContentDocument, baseOptions);
      }
export type MigrateContentMutationHookResult = ReturnType<typeof useMigrateContentMutation>;
export type MigrateContentMutationResult = Apollo.MutationResult<MigrateContentMutation>;
export type MigrateContentMutationOptions = Apollo.BaseMutationOptions<MigrateContentMutation, MigrateContentMutationVariables>;
export const GetUserMaxOverageCentsDocument = gql`
    query GetUserMaxOverageCents($id: Int!) {
  users_by_pk(id: $id) {
    id
    private_info {
      max_overage_cents
    }
  }
}
    `;

/**
 * __useGetUserMaxOverageCentsQuery__
 *
 * To run a query within a React component, call `useGetUserMaxOverageCentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserMaxOverageCentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserMaxOverageCentsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserMaxOverageCentsQuery(baseOptions: Apollo.QueryHookOptions<GetUserMaxOverageCentsQuery, GetUserMaxOverageCentsQueryVariables>) {
        return Apollo.useQuery<GetUserMaxOverageCentsQuery, GetUserMaxOverageCentsQueryVariables>(GetUserMaxOverageCentsDocument, baseOptions);
      }
export function useGetUserMaxOverageCentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserMaxOverageCentsQuery, GetUserMaxOverageCentsQueryVariables>) {
          return Apollo.useLazyQuery<GetUserMaxOverageCentsQuery, GetUserMaxOverageCentsQueryVariables>(GetUserMaxOverageCentsDocument, baseOptions);
        }
export type GetUserMaxOverageCentsQueryHookResult = ReturnType<typeof useGetUserMaxOverageCentsQuery>;
export type GetUserMaxOverageCentsLazyQueryHookResult = ReturnType<typeof useGetUserMaxOverageCentsLazyQuery>;
export type GetUserMaxOverageCentsQueryResult = Apollo.QueryResult<GetUserMaxOverageCentsQuery, GetUserMaxOverageCentsQueryVariables>;
export const SetUserMaxOverageCentsDocument = gql`
    mutation SetUserMaxOverageCents($max_overage_cents: Int) {
  set_max_overage_cents(max_overage_cents: $max_overage_cents) {
    max_overage_cents
  }
}
    `;
export type SetUserMaxOverageCentsMutationFn = Apollo.MutationFunction<SetUserMaxOverageCentsMutation, SetUserMaxOverageCentsMutationVariables>;

/**
 * __useSetUserMaxOverageCentsMutation__
 *
 * To run a mutation, you first call `useSetUserMaxOverageCentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetUserMaxOverageCentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setUserMaxOverageCentsMutation, { data, loading, error }] = useSetUserMaxOverageCentsMutation({
 *   variables: {
 *      max_overage_cents: // value for 'max_overage_cents'
 *   },
 * });
 */
export function useSetUserMaxOverageCentsMutation(baseOptions?: Apollo.MutationHookOptions<SetUserMaxOverageCentsMutation, SetUserMaxOverageCentsMutationVariables>) {
        return Apollo.useMutation<SetUserMaxOverageCentsMutation, SetUserMaxOverageCentsMutationVariables>(SetUserMaxOverageCentsDocument, baseOptions);
      }
export type SetUserMaxOverageCentsMutationHookResult = ReturnType<typeof useSetUserMaxOverageCentsMutation>;
export type SetUserMaxOverageCentsMutationResult = Apollo.MutationResult<SetUserMaxOverageCentsMutation>;
export type SetUserMaxOverageCentsMutationOptions = Apollo.BaseMutationOptions<SetUserMaxOverageCentsMutation, SetUserMaxOverageCentsMutationVariables>;
export const GetUserMaxDatapointsPerRequestDocument = gql`
    query GetUserMaxDatapointsPerRequest($id: Int!) {
  users_by_pk(id: $id) {
    id
    private_info {
      max_datapoints_per_request
    }
  }
}
    `;

/**
 * __useGetUserMaxDatapointsPerRequestQuery__
 *
 * To run a query within a React component, call `useGetUserMaxDatapointsPerRequestQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserMaxDatapointsPerRequestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserMaxDatapointsPerRequestQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserMaxDatapointsPerRequestQuery(baseOptions: Apollo.QueryHookOptions<GetUserMaxDatapointsPerRequestQuery, GetUserMaxDatapointsPerRequestQueryVariables>) {
        return Apollo.useQuery<GetUserMaxDatapointsPerRequestQuery, GetUserMaxDatapointsPerRequestQueryVariables>(GetUserMaxDatapointsPerRequestDocument, baseOptions);
      }
export function useGetUserMaxDatapointsPerRequestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserMaxDatapointsPerRequestQuery, GetUserMaxDatapointsPerRequestQueryVariables>) {
          return Apollo.useLazyQuery<GetUserMaxDatapointsPerRequestQuery, GetUserMaxDatapointsPerRequestQueryVariables>(GetUserMaxDatapointsPerRequestDocument, baseOptions);
        }
export type GetUserMaxDatapointsPerRequestQueryHookResult = ReturnType<typeof useGetUserMaxDatapointsPerRequestQuery>;
export type GetUserMaxDatapointsPerRequestLazyQueryHookResult = ReturnType<typeof useGetUserMaxDatapointsPerRequestLazyQuery>;
export type GetUserMaxDatapointsPerRequestQueryResult = Apollo.QueryResult<GetUserMaxDatapointsPerRequestQuery, GetUserMaxDatapointsPerRequestQueryVariables>;
export const SetUserMaxDatapointsPerRequestDocument = gql`
    mutation SetUserMaxDatapointsPerRequest($id: Int!, $max_datapoints_per_request: Int) {
  update_users_by_pk(
    pk_columns: {id: $id}
    _set: {max_datapoints_per_request: $max_datapoints_per_request}
  ) {
    id
    private_info {
      max_datapoints_per_request
    }
  }
}
    `;
export type SetUserMaxDatapointsPerRequestMutationFn = Apollo.MutationFunction<SetUserMaxDatapointsPerRequestMutation, SetUserMaxDatapointsPerRequestMutationVariables>;

/**
 * __useSetUserMaxDatapointsPerRequestMutation__
 *
 * To run a mutation, you first call `useSetUserMaxDatapointsPerRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetUserMaxDatapointsPerRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setUserMaxDatapointsPerRequestMutation, { data, loading, error }] = useSetUserMaxDatapointsPerRequestMutation({
 *   variables: {
 *      id: // value for 'id'
 *      max_datapoints_per_request: // value for 'max_datapoints_per_request'
 *   },
 * });
 */
export function useSetUserMaxDatapointsPerRequestMutation(baseOptions?: Apollo.MutationHookOptions<SetUserMaxDatapointsPerRequestMutation, SetUserMaxDatapointsPerRequestMutationVariables>) {
        return Apollo.useMutation<SetUserMaxDatapointsPerRequestMutation, SetUserMaxDatapointsPerRequestMutationVariables>(SetUserMaxDatapointsPerRequestDocument, baseOptions);
      }
export type SetUserMaxDatapointsPerRequestMutationHookResult = ReturnType<typeof useSetUserMaxDatapointsPerRequestMutation>;
export type SetUserMaxDatapointsPerRequestMutationResult = Apollo.MutationResult<SetUserMaxDatapointsPerRequestMutation>;
export type SetUserMaxDatapointsPerRequestMutationOptions = Apollo.BaseMutationOptions<SetUserMaxDatapointsPerRequestMutation, SetUserMaxDatapointsPerRequestMutationVariables>;
export const InviteMemberDocument = gql`
    mutation InviteMember($team_id: Int!, $role: String!, $usernameOrEmail: String!) {
  invite_member_v2(
    team_id: $team_id
    role: $role
    usernameOrEmail: $usernameOrEmail
  ) {
    id
  }
}
    `;
export type InviteMemberMutationFn = Apollo.MutationFunction<InviteMemberMutation, InviteMemberMutationVariables>;

/**
 * __useInviteMemberMutation__
 *
 * To run a mutation, you first call `useInviteMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInviteMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [inviteMemberMutation, { data, loading, error }] = useInviteMemberMutation({
 *   variables: {
 *      team_id: // value for 'team_id'
 *      role: // value for 'role'
 *      usernameOrEmail: // value for 'usernameOrEmail'
 *   },
 * });
 */
export function useInviteMemberMutation(baseOptions?: Apollo.MutationHookOptions<InviteMemberMutation, InviteMemberMutationVariables>) {
        return Apollo.useMutation<InviteMemberMutation, InviteMemberMutationVariables>(InviteMemberDocument, baseOptions);
      }
export type InviteMemberMutationHookResult = ReturnType<typeof useInviteMemberMutation>;
export type InviteMemberMutationResult = Apollo.MutationResult<InviteMemberMutation>;
export type InviteMemberMutationOptions = Apollo.BaseMutationOptions<InviteMemberMutation, InviteMemberMutationVariables>;
export const CreateTeamApiKeyDocument = gql`
    mutation CreateTeamApiKey($name: String!, $teamId: Int!) {
  create_team_api_key(name: $name, team_id: $teamId) {
    id
    key
    name
  }
}
    `;
export type CreateTeamApiKeyMutationFn = Apollo.MutationFunction<CreateTeamApiKeyMutation, CreateTeamApiKeyMutationVariables>;

/**
 * __useCreateTeamApiKeyMutation__
 *
 * To run a mutation, you first call `useCreateTeamApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTeamApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTeamApiKeyMutation, { data, loading, error }] = useCreateTeamApiKeyMutation({
 *   variables: {
 *      name: // value for 'name'
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useCreateTeamApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<CreateTeamApiKeyMutation, CreateTeamApiKeyMutationVariables>) {
        return Apollo.useMutation<CreateTeamApiKeyMutation, CreateTeamApiKeyMutationVariables>(CreateTeamApiKeyDocument, baseOptions);
      }
export type CreateTeamApiKeyMutationHookResult = ReturnType<typeof useCreateTeamApiKeyMutation>;
export type CreateTeamApiKeyMutationResult = Apollo.MutationResult<CreateTeamApiKeyMutation>;
export type CreateTeamApiKeyMutationOptions = Apollo.BaseMutationOptions<CreateTeamApiKeyMutation, CreateTeamApiKeyMutationVariables>;
export const DeleteTeamApiKeyDocument = gql`
    mutation DeleteTeamApiKey($id: String!, $teamId: Int!) {
  delete_team_api_key(id: $id, team_id: $teamId) {
    id
  }
}
    `;
export type DeleteTeamApiKeyMutationFn = Apollo.MutationFunction<DeleteTeamApiKeyMutation, DeleteTeamApiKeyMutationVariables>;

/**
 * __useDeleteTeamApiKeyMutation__
 *
 * To run a mutation, you first call `useDeleteTeamApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTeamApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTeamApiKeyMutation, { data, loading, error }] = useDeleteTeamApiKeyMutation({
 *   variables: {
 *      id: // value for 'id'
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useDeleteTeamApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTeamApiKeyMutation, DeleteTeamApiKeyMutationVariables>) {
        return Apollo.useMutation<DeleteTeamApiKeyMutation, DeleteTeamApiKeyMutationVariables>(DeleteTeamApiKeyDocument, baseOptions);
      }
export type DeleteTeamApiKeyMutationHookResult = ReturnType<typeof useDeleteTeamApiKeyMutation>;
export type DeleteTeamApiKeyMutationResult = Apollo.MutationResult<DeleteTeamApiKeyMutation>;
export type DeleteTeamApiKeyMutationOptions = Apollo.BaseMutationOptions<DeleteTeamApiKeyMutation, DeleteTeamApiKeyMutationVariables>;
export const GetTeamApiKeysDocument = gql`
    query GetTeamApiKeys($teamId: Int!) {
  team_api_keys(team_id: $teamId) {
    keys {
      __typename
      id
      name
      suffix
    }
  }
}
    `;

/**
 * __useGetTeamApiKeysQuery__
 *
 * To run a query within a React component, call `useGetTeamApiKeysQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamApiKeysQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamApiKeysQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamApiKeysQuery(baseOptions: Apollo.QueryHookOptions<GetTeamApiKeysQuery, GetTeamApiKeysQueryVariables>) {
        return Apollo.useQuery<GetTeamApiKeysQuery, GetTeamApiKeysQueryVariables>(GetTeamApiKeysDocument, baseOptions);
      }
export function useGetTeamApiKeysLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamApiKeysQuery, GetTeamApiKeysQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamApiKeysQuery, GetTeamApiKeysQueryVariables>(GetTeamApiKeysDocument, baseOptions);
        }
export type GetTeamApiKeysQueryHookResult = ReturnType<typeof useGetTeamApiKeysQuery>;
export type GetTeamApiKeysLazyQueryHookResult = ReturnType<typeof useGetTeamApiKeysLazyQuery>;
export type GetTeamApiKeysQueryResult = Apollo.QueryResult<GetTeamApiKeysQuery, GetTeamApiKeysQueryVariables>;
export const GetTeamDocument = gql`
    query GetTeam($team_handle: String!, $userId: Int!) {
  teams(
    where: {handle: {_eq: $team_handle}, memberships: {private_details: {user_id: {_eq: $userId}, role: {_eq: "admin"}}}}
  ) {
    id
    name
    handle
    profile_image_url
    twitter_handle
    telegram_handle
    discord_url
    bio
    members_details {
      id
      show_members
      enable_service_tier_badge
      service_tier {
        id
        name
        is_public
        base_monthly_price_dollars_cents
        included_datapoints
        release_version
        remove_watermark
        performance
      }
    }
  }
}
    `;

/**
 * __useGetTeamQuery__
 *
 * To run a query within a React component, call `useGetTeamQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamQuery({
 *   variables: {
 *      team_handle: // value for 'team_handle'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetTeamQuery(baseOptions: Apollo.QueryHookOptions<GetTeamQuery, GetTeamQueryVariables>) {
        return Apollo.useQuery<GetTeamQuery, GetTeamQueryVariables>(GetTeamDocument, baseOptions);
      }
export function useGetTeamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamQuery, GetTeamQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamQuery, GetTeamQueryVariables>(GetTeamDocument, baseOptions);
        }
export type GetTeamQueryHookResult = ReturnType<typeof useGetTeamQuery>;
export type GetTeamLazyQueryHookResult = ReturnType<typeof useGetTeamLazyQuery>;
export type GetTeamQueryResult = Apollo.QueryResult<GetTeamQuery, GetTeamQueryVariables>;
export const ResendInviteDocument = gql`
    mutation ResendInvite($membership_id: uuid!) {
  resend_invite_v2(membership_id: $membership_id) {
    ok
  }
}
    `;
export type ResendInviteMutationFn = Apollo.MutationFunction<ResendInviteMutation, ResendInviteMutationVariables>;

/**
 * __useResendInviteMutation__
 *
 * To run a mutation, you first call `useResendInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResendInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resendInviteMutation, { data, loading, error }] = useResendInviteMutation({
 *   variables: {
 *      membership_id: // value for 'membership_id'
 *   },
 * });
 */
export function useResendInviteMutation(baseOptions?: Apollo.MutationHookOptions<ResendInviteMutation, ResendInviteMutationVariables>) {
        return Apollo.useMutation<ResendInviteMutation, ResendInviteMutationVariables>(ResendInviteDocument, baseOptions);
      }
export type ResendInviteMutationHookResult = ReturnType<typeof useResendInviteMutation>;
export type ResendInviteMutationResult = Apollo.MutationResult<ResendInviteMutation>;
export type ResendInviteMutationOptions = Apollo.BaseMutationOptions<ResendInviteMutation, ResendInviteMutationVariables>;
export const ListTeamInvoicesDocument = gql`
    query ListTeamInvoices($teamId: Int!) {
  get_invoices: get_team_invoices(team_id: $teamId) {
    invoices {
      plan_display_name
      source
      date
      status
      href
      amount_display
      currency_key
    }
  }
}
    `;

/**
 * __useListTeamInvoicesQuery__
 *
 * To run a query within a React component, call `useListTeamInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListTeamInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListTeamInvoicesQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useListTeamInvoicesQuery(baseOptions: Apollo.QueryHookOptions<ListTeamInvoicesQuery, ListTeamInvoicesQueryVariables>) {
        return Apollo.useQuery<ListTeamInvoicesQuery, ListTeamInvoicesQueryVariables>(ListTeamInvoicesDocument, baseOptions);
      }
export function useListTeamInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListTeamInvoicesQuery, ListTeamInvoicesQueryVariables>) {
          return Apollo.useLazyQuery<ListTeamInvoicesQuery, ListTeamInvoicesQueryVariables>(ListTeamInvoicesDocument, baseOptions);
        }
export type ListTeamInvoicesQueryHookResult = ReturnType<typeof useListTeamInvoicesQuery>;
export type ListTeamInvoicesLazyQueryHookResult = ReturnType<typeof useListTeamInvoicesLazyQuery>;
export type ListTeamInvoicesQueryResult = Apollo.QueryResult<ListTeamInvoicesQuery, ListTeamInvoicesQueryVariables>;
export const TeamExtraCreditsCentsDocument = gql`
    query TeamExtraCreditsCents($teamId: Int!) {
  team_billable_usage(team_id: $teamId) {
    extra_credits_cents
  }
}
    `;

/**
 * __useTeamExtraCreditsCentsQuery__
 *
 * To run a query within a React component, call `useTeamExtraCreditsCentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTeamExtraCreditsCentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTeamExtraCreditsCentsQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useTeamExtraCreditsCentsQuery(baseOptions: Apollo.QueryHookOptions<TeamExtraCreditsCentsQuery, TeamExtraCreditsCentsQueryVariables>) {
        return Apollo.useQuery<TeamExtraCreditsCentsQuery, TeamExtraCreditsCentsQueryVariables>(TeamExtraCreditsCentsDocument, baseOptions);
      }
export function useTeamExtraCreditsCentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TeamExtraCreditsCentsQuery, TeamExtraCreditsCentsQueryVariables>) {
          return Apollo.useLazyQuery<TeamExtraCreditsCentsQuery, TeamExtraCreditsCentsQueryVariables>(TeamExtraCreditsCentsDocument, baseOptions);
        }
export type TeamExtraCreditsCentsQueryHookResult = ReturnType<typeof useTeamExtraCreditsCentsQuery>;
export type TeamExtraCreditsCentsLazyQueryHookResult = ReturnType<typeof useTeamExtraCreditsCentsLazyQuery>;
export type TeamExtraCreditsCentsQueryResult = Apollo.QueryResult<TeamExtraCreditsCentsQuery, TeamExtraCreditsCentsQueryVariables>;
export const CancelPendingTeamSubscriptionUpdateDocument = gql`
    mutation CancelPendingTeamSubscriptionUpdate($teamId: Int!) {
  cancel_team_pending_subscription_change(team_id: $teamId) {
    ok
  }
}
    `;
export type CancelPendingTeamSubscriptionUpdateMutationFn = Apollo.MutationFunction<CancelPendingTeamSubscriptionUpdateMutation, CancelPendingTeamSubscriptionUpdateMutationVariables>;

/**
 * __useCancelPendingTeamSubscriptionUpdateMutation__
 *
 * To run a mutation, you first call `useCancelPendingTeamSubscriptionUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelPendingTeamSubscriptionUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelPendingTeamSubscriptionUpdateMutation, { data, loading, error }] = useCancelPendingTeamSubscriptionUpdateMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useCancelPendingTeamSubscriptionUpdateMutation(baseOptions?: Apollo.MutationHookOptions<CancelPendingTeamSubscriptionUpdateMutation, CancelPendingTeamSubscriptionUpdateMutationVariables>) {
        return Apollo.useMutation<CancelPendingTeamSubscriptionUpdateMutation, CancelPendingTeamSubscriptionUpdateMutationVariables>(CancelPendingTeamSubscriptionUpdateDocument, baseOptions);
      }
export type CancelPendingTeamSubscriptionUpdateMutationHookResult = ReturnType<typeof useCancelPendingTeamSubscriptionUpdateMutation>;
export type CancelPendingTeamSubscriptionUpdateMutationResult = Apollo.MutationResult<CancelPendingTeamSubscriptionUpdateMutation>;
export type CancelPendingTeamSubscriptionUpdateMutationOptions = Apollo.BaseMutationOptions<CancelPendingTeamSubscriptionUpdateMutation, CancelPendingTeamSubscriptionUpdateMutationVariables>;
export const GetIsTeamEnterpriseDocument = gql`
    query GetIsTeamEnterprise($teamId: Int!) {
  teams_by_pk(id: $teamId) {
    id
    members_details {
      id
      service_tier {
        id
        is_public
      }
    }
  }
}
    `;

/**
 * __useGetIsTeamEnterpriseQuery__
 *
 * To run a query within a React component, call `useGetIsTeamEnterpriseQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetIsTeamEnterpriseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetIsTeamEnterpriseQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetIsTeamEnterpriseQuery(baseOptions: Apollo.QueryHookOptions<GetIsTeamEnterpriseQuery, GetIsTeamEnterpriseQueryVariables>) {
        return Apollo.useQuery<GetIsTeamEnterpriseQuery, GetIsTeamEnterpriseQueryVariables>(GetIsTeamEnterpriseDocument, baseOptions);
      }
export function useGetIsTeamEnterpriseLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetIsTeamEnterpriseQuery, GetIsTeamEnterpriseQueryVariables>) {
          return Apollo.useLazyQuery<GetIsTeamEnterpriseQuery, GetIsTeamEnterpriseQueryVariables>(GetIsTeamEnterpriseDocument, baseOptions);
        }
export type GetIsTeamEnterpriseQueryHookResult = ReturnType<typeof useGetIsTeamEnterpriseQuery>;
export type GetIsTeamEnterpriseLazyQueryHookResult = ReturnType<typeof useGetIsTeamEnterpriseLazyQuery>;
export type GetIsTeamEnterpriseQueryResult = Apollo.QueryResult<GetIsTeamEnterpriseQuery, GetIsTeamEnterpriseQueryVariables>;
export const GetTeamPendingUpdatesDocument = gql`
    query GetTeamPendingUpdates($teamId: Int!) {
  pending_team_subscription_updates(where: {team_id: {_eq: $teamId}}) {
    update_date
    service_tier {
      id
      name
    }
    update_type
  }
}
    `;

/**
 * __useGetTeamPendingUpdatesQuery__
 *
 * To run a query within a React component, call `useGetTeamPendingUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamPendingUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamPendingUpdatesQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamPendingUpdatesQuery(baseOptions: Apollo.QueryHookOptions<GetTeamPendingUpdatesQuery, GetTeamPendingUpdatesQueryVariables>) {
        return Apollo.useQuery<GetTeamPendingUpdatesQuery, GetTeamPendingUpdatesQueryVariables>(GetTeamPendingUpdatesDocument, baseOptions);
      }
export function useGetTeamPendingUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamPendingUpdatesQuery, GetTeamPendingUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamPendingUpdatesQuery, GetTeamPendingUpdatesQueryVariables>(GetTeamPendingUpdatesDocument, baseOptions);
        }
export type GetTeamPendingUpdatesQueryHookResult = ReturnType<typeof useGetTeamPendingUpdatesQuery>;
export type GetTeamPendingUpdatesLazyQueryHookResult = ReturnType<typeof useGetTeamPendingUpdatesLazyQuery>;
export type GetTeamPendingUpdatesQueryResult = Apollo.QueryResult<GetTeamPendingUpdatesQuery, GetTeamPendingUpdatesQueryVariables>;
export const GetTeamMaxOverageCentsDocument = gql`
    query GetTeamMaxOverageCents($teamId: Int!) {
  teams_by_pk(id: $teamId) {
    id
    members_details {
      id
      max_overage_cents
    }
  }
}
    `;

/**
 * __useGetTeamMaxOverageCentsQuery__
 *
 * To run a query within a React component, call `useGetTeamMaxOverageCentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamMaxOverageCentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamMaxOverageCentsQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamMaxOverageCentsQuery(baseOptions: Apollo.QueryHookOptions<GetTeamMaxOverageCentsQuery, GetTeamMaxOverageCentsQueryVariables>) {
        return Apollo.useQuery<GetTeamMaxOverageCentsQuery, GetTeamMaxOverageCentsQueryVariables>(GetTeamMaxOverageCentsDocument, baseOptions);
      }
export function useGetTeamMaxOverageCentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamMaxOverageCentsQuery, GetTeamMaxOverageCentsQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamMaxOverageCentsQuery, GetTeamMaxOverageCentsQueryVariables>(GetTeamMaxOverageCentsDocument, baseOptions);
        }
export type GetTeamMaxOverageCentsQueryHookResult = ReturnType<typeof useGetTeamMaxOverageCentsQuery>;
export type GetTeamMaxOverageCentsLazyQueryHookResult = ReturnType<typeof useGetTeamMaxOverageCentsLazyQuery>;
export type GetTeamMaxOverageCentsQueryResult = Apollo.QueryResult<GetTeamMaxOverageCentsQuery, GetTeamMaxOverageCentsQueryVariables>;
export const SetTeamMaxOverageCentsDocument = gql`
    mutation SetTeamMaxOverageCents($teamId: Int!, $max_overage_cents: Int) {
  set_team_max_overage_cents(
    team_id: $teamId
    max_overage_cents: $max_overage_cents
  ) {
    team {
      id
      max_overage_cents
    }
  }
}
    `;
export type SetTeamMaxOverageCentsMutationFn = Apollo.MutationFunction<SetTeamMaxOverageCentsMutation, SetTeamMaxOverageCentsMutationVariables>;

/**
 * __useSetTeamMaxOverageCentsMutation__
 *
 * To run a mutation, you first call `useSetTeamMaxOverageCentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetTeamMaxOverageCentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setTeamMaxOverageCentsMutation, { data, loading, error }] = useSetTeamMaxOverageCentsMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      max_overage_cents: // value for 'max_overage_cents'
 *   },
 * });
 */
export function useSetTeamMaxOverageCentsMutation(baseOptions?: Apollo.MutationHookOptions<SetTeamMaxOverageCentsMutation, SetTeamMaxOverageCentsMutationVariables>) {
        return Apollo.useMutation<SetTeamMaxOverageCentsMutation, SetTeamMaxOverageCentsMutationVariables>(SetTeamMaxOverageCentsDocument, baseOptions);
      }
export type SetTeamMaxOverageCentsMutationHookResult = ReturnType<typeof useSetTeamMaxOverageCentsMutation>;
export type SetTeamMaxOverageCentsMutationResult = Apollo.MutationResult<SetTeamMaxOverageCentsMutation>;
export type SetTeamMaxOverageCentsMutationOptions = Apollo.BaseMutationOptions<SetTeamMaxOverageCentsMutation, SetTeamMaxOverageCentsMutationVariables>;
export const GetTeamMaxExecutionsOverageCostCentsDocument = gql`
    query GetTeamMaxExecutionsOverageCostCents($teamId: Int!) {
  teams_by_pk(id: $teamId) {
    id
    members_details {
      id
      max_executions_overage_cost_cents
    }
  }
}
    `;

/**
 * __useGetTeamMaxExecutionsOverageCostCentsQuery__
 *
 * To run a query within a React component, call `useGetTeamMaxExecutionsOverageCostCentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamMaxExecutionsOverageCostCentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamMaxExecutionsOverageCostCentsQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamMaxExecutionsOverageCostCentsQuery(baseOptions: Apollo.QueryHookOptions<GetTeamMaxExecutionsOverageCostCentsQuery, GetTeamMaxExecutionsOverageCostCentsQueryVariables>) {
        return Apollo.useQuery<GetTeamMaxExecutionsOverageCostCentsQuery, GetTeamMaxExecutionsOverageCostCentsQueryVariables>(GetTeamMaxExecutionsOverageCostCentsDocument, baseOptions);
      }
export function useGetTeamMaxExecutionsOverageCostCentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamMaxExecutionsOverageCostCentsQuery, GetTeamMaxExecutionsOverageCostCentsQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamMaxExecutionsOverageCostCentsQuery, GetTeamMaxExecutionsOverageCostCentsQueryVariables>(GetTeamMaxExecutionsOverageCostCentsDocument, baseOptions);
        }
export type GetTeamMaxExecutionsOverageCostCentsQueryHookResult = ReturnType<typeof useGetTeamMaxExecutionsOverageCostCentsQuery>;
export type GetTeamMaxExecutionsOverageCostCentsLazyQueryHookResult = ReturnType<typeof useGetTeamMaxExecutionsOverageCostCentsLazyQuery>;
export type GetTeamMaxExecutionsOverageCostCentsQueryResult = Apollo.QueryResult<GetTeamMaxExecutionsOverageCostCentsQuery, GetTeamMaxExecutionsOverageCostCentsQueryVariables>;
export const SetTeamMaxExecutionsOverageCostCentsDocument = gql`
    mutation SetTeamMaxExecutionsOverageCostCents($teamId: Int!, $max_executions_overage_cost_cents: Int) {
  set_team_max_executions_overage_cost_cents(
    team_id: $teamId
    max_executions_overage_cost_cents: $max_executions_overage_cost_cents
  ) {
    team {
      id
      max_executions_overage_cost_cents
      execution_quota_exceeded_until
    }
  }
}
    `;
export type SetTeamMaxExecutionsOverageCostCentsMutationFn = Apollo.MutationFunction<SetTeamMaxExecutionsOverageCostCentsMutation, SetTeamMaxExecutionsOverageCostCentsMutationVariables>;

/**
 * __useSetTeamMaxExecutionsOverageCostCentsMutation__
 *
 * To run a mutation, you first call `useSetTeamMaxExecutionsOverageCostCentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetTeamMaxExecutionsOverageCostCentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setTeamMaxExecutionsOverageCostCentsMutation, { data, loading, error }] = useSetTeamMaxExecutionsOverageCostCentsMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      max_executions_overage_cost_cents: // value for 'max_executions_overage_cost_cents'
 *   },
 * });
 */
export function useSetTeamMaxExecutionsOverageCostCentsMutation(baseOptions?: Apollo.MutationHookOptions<SetTeamMaxExecutionsOverageCostCentsMutation, SetTeamMaxExecutionsOverageCostCentsMutationVariables>) {
        return Apollo.useMutation<SetTeamMaxExecutionsOverageCostCentsMutation, SetTeamMaxExecutionsOverageCostCentsMutationVariables>(SetTeamMaxExecutionsOverageCostCentsDocument, baseOptions);
      }
export type SetTeamMaxExecutionsOverageCostCentsMutationHookResult = ReturnType<typeof useSetTeamMaxExecutionsOverageCostCentsMutation>;
export type SetTeamMaxExecutionsOverageCostCentsMutationResult = Apollo.MutationResult<SetTeamMaxExecutionsOverageCostCentsMutation>;
export type SetTeamMaxExecutionsOverageCostCentsMutationOptions = Apollo.BaseMutationOptions<SetTeamMaxExecutionsOverageCostCentsMutation, SetTeamMaxExecutionsOverageCostCentsMutationVariables>;
export const GetTeamMaxDatapointsPerRequestDocument = gql`
    query GetTeamMaxDatapointsPerRequest($id: Int!) {
  teams_by_pk(id: $id) {
    id
    members_details {
      id
      max_datapoints_per_request
    }
  }
}
    `;

/**
 * __useGetTeamMaxDatapointsPerRequestQuery__
 *
 * To run a query within a React component, call `useGetTeamMaxDatapointsPerRequestQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamMaxDatapointsPerRequestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamMaxDatapointsPerRequestQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetTeamMaxDatapointsPerRequestQuery(baseOptions: Apollo.QueryHookOptions<GetTeamMaxDatapointsPerRequestQuery, GetTeamMaxDatapointsPerRequestQueryVariables>) {
        return Apollo.useQuery<GetTeamMaxDatapointsPerRequestQuery, GetTeamMaxDatapointsPerRequestQueryVariables>(GetTeamMaxDatapointsPerRequestDocument, baseOptions);
      }
export function useGetTeamMaxDatapointsPerRequestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamMaxDatapointsPerRequestQuery, GetTeamMaxDatapointsPerRequestQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamMaxDatapointsPerRequestQuery, GetTeamMaxDatapointsPerRequestQueryVariables>(GetTeamMaxDatapointsPerRequestDocument, baseOptions);
        }
export type GetTeamMaxDatapointsPerRequestQueryHookResult = ReturnType<typeof useGetTeamMaxDatapointsPerRequestQuery>;
export type GetTeamMaxDatapointsPerRequestLazyQueryHookResult = ReturnType<typeof useGetTeamMaxDatapointsPerRequestLazyQuery>;
export type GetTeamMaxDatapointsPerRequestQueryResult = Apollo.QueryResult<GetTeamMaxDatapointsPerRequestQuery, GetTeamMaxDatapointsPerRequestQueryVariables>;
export const SetTeamMaxDatapointsPerRequestDocument = gql`
    mutation SetTeamMaxDatapointsPerRequest($id: Int!, $max_datapoints_per_request: Int) {
  update_teams_by_pk(
    pk_columns: {id: $id}
    _set: {max_datapoints_per_request: $max_datapoints_per_request}
  ) {
    id
    members_details {
      id
      max_datapoints_per_request
    }
  }
}
    `;
export type SetTeamMaxDatapointsPerRequestMutationFn = Apollo.MutationFunction<SetTeamMaxDatapointsPerRequestMutation, SetTeamMaxDatapointsPerRequestMutationVariables>;

/**
 * __useSetTeamMaxDatapointsPerRequestMutation__
 *
 * To run a mutation, you first call `useSetTeamMaxDatapointsPerRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetTeamMaxDatapointsPerRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setTeamMaxDatapointsPerRequestMutation, { data, loading, error }] = useSetTeamMaxDatapointsPerRequestMutation({
 *   variables: {
 *      id: // value for 'id'
 *      max_datapoints_per_request: // value for 'max_datapoints_per_request'
 *   },
 * });
 */
export function useSetTeamMaxDatapointsPerRequestMutation(baseOptions?: Apollo.MutationHookOptions<SetTeamMaxDatapointsPerRequestMutation, SetTeamMaxDatapointsPerRequestMutationVariables>) {
        return Apollo.useMutation<SetTeamMaxDatapointsPerRequestMutation, SetTeamMaxDatapointsPerRequestMutationVariables>(SetTeamMaxDatapointsPerRequestDocument, baseOptions);
      }
export type SetTeamMaxDatapointsPerRequestMutationHookResult = ReturnType<typeof useSetTeamMaxDatapointsPerRequestMutation>;
export type SetTeamMaxDatapointsPerRequestMutationResult = Apollo.MutationResult<SetTeamMaxDatapointsPerRequestMutation>;
export type SetTeamMaxDatapointsPerRequestMutationOptions = Apollo.BaseMutationOptions<SetTeamMaxDatapointsPerRequestMutation, SetTeamMaxDatapointsPerRequestMutationVariables>;
export const GetTeamUsageDocument = gql`
    query GetTeamUsage($teamId: Int!) {
  dashboards_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, team_id: {_eq: $teamId}}
  ) {
    aggregate {
      count
    }
  }
  queries_aggregate(
    where: {is_private: {_eq: true}, is_archived: {_eq: false}, is_temp: {_eq: false}, team_id: {_eq: $teamId}}
  ) {
    aggregate {
      count
    }
  }
  team_members_details(where: {id: {_eq: $teamId}}) {
    id
    max_overage_cents
    max_executions_overage_cost_cents
    service_tier {
      id
      name
      base_monthly_price_dollars_cents
      max_private_dashboards
      max_private_queries
      release_version
      nanocredits_cost_cents
    }
  }
  team_billable_usage(team_id: $teamId) {
    query_executions
    csv_downloads
    max_csv_downloads
    max_query_executions
    max_datapoints_read
    datapoints_read
    credits_included
    credits_used
    extra_credits_cents
    max_extra_credits_cents
  }
}
    `;

/**
 * __useGetTeamUsageQuery__
 *
 * To run a query within a React component, call `useGetTeamUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamUsageQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamUsageQuery(baseOptions: Apollo.QueryHookOptions<GetTeamUsageQuery, GetTeamUsageQueryVariables>) {
        return Apollo.useQuery<GetTeamUsageQuery, GetTeamUsageQueryVariables>(GetTeamUsageDocument, baseOptions);
      }
export function useGetTeamUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamUsageQuery, GetTeamUsageQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamUsageQuery, GetTeamUsageQueryVariables>(GetTeamUsageDocument, baseOptions);
        }
export type GetTeamUsageQueryHookResult = ReturnType<typeof useGetTeamUsageQuery>;
export type GetTeamUsageLazyQueryHookResult = ReturnType<typeof useGetTeamUsageLazyQuery>;
export type GetTeamUsageQueryResult = Apollo.QueryResult<GetTeamUsageQuery, GetTeamUsageQueryVariables>;
export const UpdateTeamDocument = gql`
    mutation UpdateTeam($team_id: Int!, $name: String, $handle: String, $profile_image_url: String, $twitter_handle: String, $telegram_handle: String, $discord_url: String, $bio: String, $show_members: Boolean, $enable_service_tier_badge: Boolean) {
  update_teams_by_pk(
    pk_columns: {id: $team_id}
    _set: {name: $name, handle: $handle, profile_image_url: $profile_image_url, twitter_handle: $twitter_handle, telegram_handle: $telegram_handle, discord_url: $discord_url, bio: $bio, show_members: $show_members, enable_service_tier_badge: $enable_service_tier_badge}
  ) {
    id
    name
    handle
    profile_image_url
    twitter_handle
    telegram_handle
    discord_url
    bio
    members_details {
      id
      show_members
      enable_service_tier_badge
    }
  }
}
    `;
export type UpdateTeamMutationFn = Apollo.MutationFunction<UpdateTeamMutation, UpdateTeamMutationVariables>;

/**
 * __useUpdateTeamMutation__
 *
 * To run a mutation, you first call `useUpdateTeamMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamMutation, { data, loading, error }] = useUpdateTeamMutation({
 *   variables: {
 *      team_id: // value for 'team_id'
 *      name: // value for 'name'
 *      handle: // value for 'handle'
 *      profile_image_url: // value for 'profile_image_url'
 *      twitter_handle: // value for 'twitter_handle'
 *      telegram_handle: // value for 'telegram_handle'
 *      discord_url: // value for 'discord_url'
 *      bio: // value for 'bio'
 *      show_members: // value for 'show_members'
 *      enable_service_tier_badge: // value for 'enable_service_tier_badge'
 *   },
 * });
 */
export function useUpdateTeamMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTeamMutation, UpdateTeamMutationVariables>) {
        return Apollo.useMutation<UpdateTeamMutation, UpdateTeamMutationVariables>(UpdateTeamDocument, baseOptions);
      }
export type UpdateTeamMutationHookResult = ReturnType<typeof useUpdateTeamMutation>;
export type UpdateTeamMutationResult = Apollo.MutationResult<UpdateTeamMutation>;
export type UpdateTeamMutationOptions = Apollo.BaseMutationOptions<UpdateTeamMutation, UpdateTeamMutationVariables>;
export const CreateUserCheckoutSessionDocument = gql`
    mutation CreateUserCheckoutSession($redirect_path: String!) {
  create_user_checkout_session(redirect_path: $redirect_path) {
    checkout_session_id
  }
}
    `;
export type CreateUserCheckoutSessionMutationFn = Apollo.MutationFunction<CreateUserCheckoutSessionMutation, CreateUserCheckoutSessionMutationVariables>;

/**
 * __useCreateUserCheckoutSessionMutation__
 *
 * To run a mutation, you first call `useCreateUserCheckoutSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserCheckoutSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserCheckoutSessionMutation, { data, loading, error }] = useCreateUserCheckoutSessionMutation({
 *   variables: {
 *      redirect_path: // value for 'redirect_path'
 *   },
 * });
 */
export function useCreateUserCheckoutSessionMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserCheckoutSessionMutation, CreateUserCheckoutSessionMutationVariables>) {
        return Apollo.useMutation<CreateUserCheckoutSessionMutation, CreateUserCheckoutSessionMutationVariables>(CreateUserCheckoutSessionDocument, baseOptions);
      }
export type CreateUserCheckoutSessionMutationHookResult = ReturnType<typeof useCreateUserCheckoutSessionMutation>;
export type CreateUserCheckoutSessionMutationResult = Apollo.MutationResult<CreateUserCheckoutSessionMutation>;
export type CreateUserCheckoutSessionMutationOptions = Apollo.BaseMutationOptions<CreateUserCheckoutSessionMutation, CreateUserCheckoutSessionMutationVariables>;
export const CreateTeamCheckoutSessionDocument = gql`
    mutation CreateTeamCheckoutSession($team_id: Int!, $redirect_path: String!) {
  create_team_checkout_session(team_id: $team_id, redirect_path: $redirect_path) {
    checkout_session_id
  }
}
    `;
export type CreateTeamCheckoutSessionMutationFn = Apollo.MutationFunction<CreateTeamCheckoutSessionMutation, CreateTeamCheckoutSessionMutationVariables>;

/**
 * __useCreateTeamCheckoutSessionMutation__
 *
 * To run a mutation, you first call `useCreateTeamCheckoutSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTeamCheckoutSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTeamCheckoutSessionMutation, { data, loading, error }] = useCreateTeamCheckoutSessionMutation({
 *   variables: {
 *      team_id: // value for 'team_id'
 *      redirect_path: // value for 'redirect_path'
 *   },
 * });
 */
export function useCreateTeamCheckoutSessionMutation(baseOptions?: Apollo.MutationHookOptions<CreateTeamCheckoutSessionMutation, CreateTeamCheckoutSessionMutationVariables>) {
        return Apollo.useMutation<CreateTeamCheckoutSessionMutation, CreateTeamCheckoutSessionMutationVariables>(CreateTeamCheckoutSessionDocument, baseOptions);
      }
export type CreateTeamCheckoutSessionMutationHookResult = ReturnType<typeof useCreateTeamCheckoutSessionMutation>;
export type CreateTeamCheckoutSessionMutationResult = Apollo.MutationResult<CreateTeamCheckoutSessionMutation>;
export type CreateTeamCheckoutSessionMutationOptions = Apollo.BaseMutationOptions<CreateTeamCheckoutSessionMutation, CreateTeamCheckoutSessionMutationVariables>;
export const CompleteStripeCheckoutSessionDocument = gql`
    mutation CompleteStripeCheckoutSession($checkout_session_id: String!) {
  complete_stripe_checkout_session(checkout_session_id: $checkout_session_id) {
    card {
      brand
      last4
      exp_month
      exp_year
    }
  }
}
    `;
export type CompleteStripeCheckoutSessionMutationFn = Apollo.MutationFunction<CompleteStripeCheckoutSessionMutation, CompleteStripeCheckoutSessionMutationVariables>;

/**
 * __useCompleteStripeCheckoutSessionMutation__
 *
 * To run a mutation, you first call `useCompleteStripeCheckoutSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCompleteStripeCheckoutSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [completeStripeCheckoutSessionMutation, { data, loading, error }] = useCompleteStripeCheckoutSessionMutation({
 *   variables: {
 *      checkout_session_id: // value for 'checkout_session_id'
 *   },
 * });
 */
export function useCompleteStripeCheckoutSessionMutation(baseOptions?: Apollo.MutationHookOptions<CompleteStripeCheckoutSessionMutation, CompleteStripeCheckoutSessionMutationVariables>) {
        return Apollo.useMutation<CompleteStripeCheckoutSessionMutation, CompleteStripeCheckoutSessionMutationVariables>(CompleteStripeCheckoutSessionDocument, baseOptions);
      }
export type CompleteStripeCheckoutSessionMutationHookResult = ReturnType<typeof useCompleteStripeCheckoutSessionMutation>;
export type CompleteStripeCheckoutSessionMutationResult = Apollo.MutationResult<CompleteStripeCheckoutSessionMutation>;
export type CompleteStripeCheckoutSessionMutationOptions = Apollo.BaseMutationOptions<CompleteStripeCheckoutSessionMutation, CompleteStripeCheckoutSessionMutationVariables>;
export const GetTeamDefaultCardDocument = gql`
    query GetTeamDefaultCard($teamId: Int!) {
  team_stripe_default_card(team_id: $teamId) {
    card {
      brand
      last4
      exp_month
      exp_year
    }
  }
}
    `;

/**
 * __useGetTeamDefaultCardQuery__
 *
 * To run a query within a React component, call `useGetTeamDefaultCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamDefaultCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamDefaultCardQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamDefaultCardQuery(baseOptions: Apollo.QueryHookOptions<GetTeamDefaultCardQuery, GetTeamDefaultCardQueryVariables>) {
        return Apollo.useQuery<GetTeamDefaultCardQuery, GetTeamDefaultCardQueryVariables>(GetTeamDefaultCardDocument, baseOptions);
      }
export function useGetTeamDefaultCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamDefaultCardQuery, GetTeamDefaultCardQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamDefaultCardQuery, GetTeamDefaultCardQueryVariables>(GetTeamDefaultCardDocument, baseOptions);
        }
export type GetTeamDefaultCardQueryHookResult = ReturnType<typeof useGetTeamDefaultCardQuery>;
export type GetTeamDefaultCardLazyQueryHookResult = ReturnType<typeof useGetTeamDefaultCardLazyQuery>;
export type GetTeamDefaultCardQueryResult = Apollo.QueryResult<GetTeamDefaultCardQuery, GetTeamDefaultCardQueryVariables>;
export const DowngradeTeamSubscriptionDocument = gql`
    mutation DowngradeTeamSubscription($teamId: Int!, $serviceTierName: String!) {
  downgrade_team_subscription(
    team_id: $teamId
    service_tier_name: $serviceTierName
  ) {
    ok
  }
}
    `;
export type DowngradeTeamSubscriptionMutationFn = Apollo.MutationFunction<DowngradeTeamSubscriptionMutation, DowngradeTeamSubscriptionMutationVariables>;

/**
 * __useDowngradeTeamSubscriptionMutation__
 *
 * To run a mutation, you first call `useDowngradeTeamSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDowngradeTeamSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downgradeTeamSubscriptionMutation, { data, loading, error }] = useDowngradeTeamSubscriptionMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      serviceTierName: // value for 'serviceTierName'
 *   },
 * });
 */
export function useDowngradeTeamSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<DowngradeTeamSubscriptionMutation, DowngradeTeamSubscriptionMutationVariables>) {
        return Apollo.useMutation<DowngradeTeamSubscriptionMutation, DowngradeTeamSubscriptionMutationVariables>(DowngradeTeamSubscriptionDocument, baseOptions);
      }
export type DowngradeTeamSubscriptionMutationHookResult = ReturnType<typeof useDowngradeTeamSubscriptionMutation>;
export type DowngradeTeamSubscriptionMutationResult = Apollo.MutationResult<DowngradeTeamSubscriptionMutation>;
export type DowngradeTeamSubscriptionMutationOptions = Apollo.BaseMutationOptions<DowngradeTeamSubscriptionMutation, DowngradeTeamSubscriptionMutationVariables>;
export const PendingTeamSubscriptionUpdatesDocument = gql`
    query PendingTeamSubscriptionUpdates($teamId: Int!) {
  pending_team_subscription_updates(where: {team_id: {_eq: $teamId}}) {
    update_type
  }
}
    `;

/**
 * __usePendingTeamSubscriptionUpdatesQuery__
 *
 * To run a query within a React component, call `usePendingTeamSubscriptionUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingTeamSubscriptionUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingTeamSubscriptionUpdatesQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function usePendingTeamSubscriptionUpdatesQuery(baseOptions: Apollo.QueryHookOptions<PendingTeamSubscriptionUpdatesQuery, PendingTeamSubscriptionUpdatesQueryVariables>) {
        return Apollo.useQuery<PendingTeamSubscriptionUpdatesQuery, PendingTeamSubscriptionUpdatesQueryVariables>(PendingTeamSubscriptionUpdatesDocument, baseOptions);
      }
export function usePendingTeamSubscriptionUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PendingTeamSubscriptionUpdatesQuery, PendingTeamSubscriptionUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<PendingTeamSubscriptionUpdatesQuery, PendingTeamSubscriptionUpdatesQueryVariables>(PendingTeamSubscriptionUpdatesDocument, baseOptions);
        }
export type PendingTeamSubscriptionUpdatesQueryHookResult = ReturnType<typeof usePendingTeamSubscriptionUpdatesQuery>;
export type PendingTeamSubscriptionUpdatesLazyQueryHookResult = ReturnType<typeof usePendingTeamSubscriptionUpdatesLazyQuery>;
export type PendingTeamSubscriptionUpdatesQueryResult = Apollo.QueryResult<PendingTeamSubscriptionUpdatesQuery, PendingTeamSubscriptionUpdatesQueryVariables>;
export const UpgradeTeamSubscriptionDocument = gql`
    mutation UpgradeTeamSubscription($teamId: Int!, $serviceTierName: String!) {
  upgrade_team_subscription(team_id: $teamId, service_tier_name: $serviceTierName) {
    ok
  }
}
    `;
export type UpgradeTeamSubscriptionMutationFn = Apollo.MutationFunction<UpgradeTeamSubscriptionMutation, UpgradeTeamSubscriptionMutationVariables>;

/**
 * __useUpgradeTeamSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpgradeTeamSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpgradeTeamSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upgradeTeamSubscriptionMutation, { data, loading, error }] = useUpgradeTeamSubscriptionMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      serviceTierName: // value for 'serviceTierName'
 *   },
 * });
 */
export function useUpgradeTeamSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpgradeTeamSubscriptionMutation, UpgradeTeamSubscriptionMutationVariables>) {
        return Apollo.useMutation<UpgradeTeamSubscriptionMutation, UpgradeTeamSubscriptionMutationVariables>(UpgradeTeamSubscriptionDocument, baseOptions);
      }
export type UpgradeTeamSubscriptionMutationHookResult = ReturnType<typeof useUpgradeTeamSubscriptionMutation>;
export type UpgradeTeamSubscriptionMutationResult = Apollo.MutationResult<UpgradeTeamSubscriptionMutation>;
export type UpgradeTeamSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpgradeTeamSubscriptionMutation, UpgradeTeamSubscriptionMutationVariables>;
export const MigrateLegacyPlanDocument = gql`
    mutation MigrateLegacyPlan($teamId: Int, $serviceTierId: Int!) {
  migrate_legacy_plan(input: {team_id: $teamId, service_tier_id: $serviceTierId}) {
    ok
  }
}
    `;
export type MigrateLegacyPlanMutationFn = Apollo.MutationFunction<MigrateLegacyPlanMutation, MigrateLegacyPlanMutationVariables>;

/**
 * __useMigrateLegacyPlanMutation__
 *
 * To run a mutation, you first call `useMigrateLegacyPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMigrateLegacyPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [migrateLegacyPlanMutation, { data, loading, error }] = useMigrateLegacyPlanMutation({
 *   variables: {
 *      teamId: // value for 'teamId'
 *      serviceTierId: // value for 'serviceTierId'
 *   },
 * });
 */
export function useMigrateLegacyPlanMutation(baseOptions?: Apollo.MutationHookOptions<MigrateLegacyPlanMutation, MigrateLegacyPlanMutationVariables>) {
        return Apollo.useMutation<MigrateLegacyPlanMutation, MigrateLegacyPlanMutationVariables>(MigrateLegacyPlanDocument, baseOptions);
      }
export type MigrateLegacyPlanMutationHookResult = ReturnType<typeof useMigrateLegacyPlanMutation>;
export type MigrateLegacyPlanMutationResult = Apollo.MutationResult<MigrateLegacyPlanMutation>;
export type MigrateLegacyPlanMutationOptions = Apollo.BaseMutationOptions<MigrateLegacyPlanMutation, MigrateLegacyPlanMutationVariables>;
export const GetTeamInfoDocument = gql`
    query GetTeamInfo($handle: String!) {
  teams(where: {handle: {_eq: $handle}}) {
    id
    name
    handle
    profile_image_url
  }
}
    `;

/**
 * __useGetTeamInfoQuery__
 *
 * To run a query within a React component, call `useGetTeamInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamInfoQuery({
 *   variables: {
 *      handle: // value for 'handle'
 *   },
 * });
 */
export function useGetTeamInfoQuery(baseOptions: Apollo.QueryHookOptions<GetTeamInfoQuery, GetTeamInfoQueryVariables>) {
        return Apollo.useQuery<GetTeamInfoQuery, GetTeamInfoQueryVariables>(GetTeamInfoDocument, baseOptions);
      }
export function useGetTeamInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamInfoQuery, GetTeamInfoQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamInfoQuery, GetTeamInfoQueryVariables>(GetTeamInfoDocument, baseOptions);
        }
export type GetTeamInfoQueryHookResult = ReturnType<typeof useGetTeamInfoQuery>;
export type GetTeamInfoLazyQueryHookResult = ReturnType<typeof useGetTeamInfoLazyQuery>;
export type GetTeamInfoQueryResult = Apollo.QueryResult<GetTeamInfoQuery, GetTeamInfoQueryVariables>;
export const GetTeamPrivateInfoDocument = gql`
    query GetTeamPrivateInfo($teamHandle: String!, $userId: Int!) {
  memberships_private_details(
    where: {team: {handle: {_eq: $teamHandle}}, user_id: {_eq: $userId}}
  ) {
    role
    team_id
    team {
      service_tier {
        id
        base_monthly_price_dollars_cents
      }
    }
  }
}
    `;

/**
 * __useGetTeamPrivateInfoQuery__
 *
 * To run a query within a React component, call `useGetTeamPrivateInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamPrivateInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamPrivateInfoQuery({
 *   variables: {
 *      teamHandle: // value for 'teamHandle'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetTeamPrivateInfoQuery(baseOptions: Apollo.QueryHookOptions<GetTeamPrivateInfoQuery, GetTeamPrivateInfoQueryVariables>) {
        return Apollo.useQuery<GetTeamPrivateInfoQuery, GetTeamPrivateInfoQueryVariables>(GetTeamPrivateInfoDocument, baseOptions);
      }
export function useGetTeamPrivateInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamPrivateInfoQuery, GetTeamPrivateInfoQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamPrivateInfoQuery, GetTeamPrivateInfoQueryVariables>(GetTeamPrivateInfoDocument, baseOptions);
        }
export type GetTeamPrivateInfoQueryHookResult = ReturnType<typeof useGetTeamPrivateInfoQuery>;
export type GetTeamPrivateInfoLazyQueryHookResult = ReturnType<typeof useGetTeamPrivateInfoLazyQuery>;
export type GetTeamPrivateInfoQueryResult = Apollo.QueryResult<GetTeamPrivateInfoQuery, GetTeamPrivateInfoQueryVariables>;
export const DowngradeUserSubscriptionDocument = gql`
    mutation DowngradeUserSubscription($service_tier_name: String!) {
  downgrade_user_subscription(service_tier_name: $service_tier_name) {
    ok
  }
}
    `;
export type DowngradeUserSubscriptionMutationFn = Apollo.MutationFunction<DowngradeUserSubscriptionMutation, DowngradeUserSubscriptionMutationVariables>;

/**
 * __useDowngradeUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useDowngradeUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDowngradeUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downgradeUserSubscriptionMutation, { data, loading, error }] = useDowngradeUserSubscriptionMutation({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useDowngradeUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<DowngradeUserSubscriptionMutation, DowngradeUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<DowngradeUserSubscriptionMutation, DowngradeUserSubscriptionMutationVariables>(DowngradeUserSubscriptionDocument, baseOptions);
      }
export type DowngradeUserSubscriptionMutationHookResult = ReturnType<typeof useDowngradeUserSubscriptionMutation>;
export type DowngradeUserSubscriptionMutationResult = Apollo.MutationResult<DowngradeUserSubscriptionMutation>;
export type DowngradeUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<DowngradeUserSubscriptionMutation, DowngradeUserSubscriptionMutationVariables>;
export const PendingUserSubscriptionUpdatesDocument = gql`
    query PendingUserSubscriptionUpdates {
  pending_user_subscription_updates {
    user_id
    update_type
  }
}
    `;

/**
 * __usePendingUserSubscriptionUpdatesQuery__
 *
 * To run a query within a React component, call `usePendingUserSubscriptionUpdatesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingUserSubscriptionUpdatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingUserSubscriptionUpdatesQuery({
 *   variables: {
 *   },
 * });
 */
export function usePendingUserSubscriptionUpdatesQuery(baseOptions?: Apollo.QueryHookOptions<PendingUserSubscriptionUpdatesQuery, PendingUserSubscriptionUpdatesQueryVariables>) {
        return Apollo.useQuery<PendingUserSubscriptionUpdatesQuery, PendingUserSubscriptionUpdatesQueryVariables>(PendingUserSubscriptionUpdatesDocument, baseOptions);
      }
export function usePendingUserSubscriptionUpdatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PendingUserSubscriptionUpdatesQuery, PendingUserSubscriptionUpdatesQueryVariables>) {
          return Apollo.useLazyQuery<PendingUserSubscriptionUpdatesQuery, PendingUserSubscriptionUpdatesQueryVariables>(PendingUserSubscriptionUpdatesDocument, baseOptions);
        }
export type PendingUserSubscriptionUpdatesQueryHookResult = ReturnType<typeof usePendingUserSubscriptionUpdatesQuery>;
export type PendingUserSubscriptionUpdatesLazyQueryHookResult = ReturnType<typeof usePendingUserSubscriptionUpdatesLazyQuery>;
export type PendingUserSubscriptionUpdatesQueryResult = Apollo.QueryResult<PendingUserSubscriptionUpdatesQuery, PendingUserSubscriptionUpdatesQueryVariables>;
export const UpgradeUserSubscriptionDocument = gql`
    mutation UpgradeUserSubscription($service_tier_name: String!) {
  upgrade_user_subscription(service_tier_name: $service_tier_name) {
    ok
  }
}
    `;
export type UpgradeUserSubscriptionMutationFn = Apollo.MutationFunction<UpgradeUserSubscriptionMutation, UpgradeUserSubscriptionMutationVariables>;

/**
 * __useUpgradeUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpgradeUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpgradeUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upgradeUserSubscriptionMutation, { data, loading, error }] = useUpgradeUserSubscriptionMutation({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useUpgradeUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpgradeUserSubscriptionMutation, UpgradeUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<UpgradeUserSubscriptionMutation, UpgradeUserSubscriptionMutationVariables>(UpgradeUserSubscriptionDocument, baseOptions);
      }
export type UpgradeUserSubscriptionMutationHookResult = ReturnType<typeof useUpgradeUserSubscriptionMutation>;
export type UpgradeUserSubscriptionMutationResult = Apollo.MutationResult<UpgradeUserSubscriptionMutation>;
export type UpgradeUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpgradeUserSubscriptionMutation, UpgradeUserSubscriptionMutationVariables>;
export const DowngradeApiUserSubscriptionDocument = gql`
    mutation DowngradeApiUserSubscription($service_tier_name: String!) {
  downgrade_api_user_subscription(service_tier_name: $service_tier_name) {
    ok
  }
}
    `;
export type DowngradeApiUserSubscriptionMutationFn = Apollo.MutationFunction<DowngradeApiUserSubscriptionMutation, DowngradeApiUserSubscriptionMutationVariables>;

/**
 * __useDowngradeApiUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useDowngradeApiUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDowngradeApiUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downgradeApiUserSubscriptionMutation, { data, loading, error }] = useDowngradeApiUserSubscriptionMutation({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useDowngradeApiUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<DowngradeApiUserSubscriptionMutation, DowngradeApiUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<DowngradeApiUserSubscriptionMutation, DowngradeApiUserSubscriptionMutationVariables>(DowngradeApiUserSubscriptionDocument, baseOptions);
      }
export type DowngradeApiUserSubscriptionMutationHookResult = ReturnType<typeof useDowngradeApiUserSubscriptionMutation>;
export type DowngradeApiUserSubscriptionMutationResult = Apollo.MutationResult<DowngradeApiUserSubscriptionMutation>;
export type DowngradeApiUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<DowngradeApiUserSubscriptionMutation, DowngradeApiUserSubscriptionMutationVariables>;
export const UpgradeApiUserSubscriptionDocument = gql`
    mutation UpgradeApiUserSubscription($service_tier_name: String!) {
  upgrade_api_user_subscription(service_tier_name: $service_tier_name) {
    ok
  }
}
    `;
export type UpgradeApiUserSubscriptionMutationFn = Apollo.MutationFunction<UpgradeApiUserSubscriptionMutation, UpgradeApiUserSubscriptionMutationVariables>;

/**
 * __useUpgradeApiUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpgradeApiUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpgradeApiUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upgradeApiUserSubscriptionMutation, { data, loading, error }] = useUpgradeApiUserSubscriptionMutation({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useUpgradeApiUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpgradeApiUserSubscriptionMutation, UpgradeApiUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<UpgradeApiUserSubscriptionMutation, UpgradeApiUserSubscriptionMutationVariables>(UpgradeApiUserSubscriptionDocument, baseOptions);
      }
export type UpgradeApiUserSubscriptionMutationHookResult = ReturnType<typeof useUpgradeApiUserSubscriptionMutation>;
export type UpgradeApiUserSubscriptionMutationResult = Apollo.MutationResult<UpgradeApiUserSubscriptionMutation>;
export type UpgradeApiUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpgradeApiUserSubscriptionMutation, UpgradeApiUserSubscriptionMutationVariables>;
export const GetDefaultCardDocument = gql`
    query GetDefaultCard {
  stripe_default_card {
    card {
      brand
      last4
      exp_month
      exp_year
    }
  }
}
    `;

/**
 * __useGetDefaultCardQuery__
 *
 * To run a query within a React component, call `useGetDefaultCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDefaultCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDefaultCardQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetDefaultCardQuery(baseOptions?: Apollo.QueryHookOptions<GetDefaultCardQuery, GetDefaultCardQueryVariables>) {
        return Apollo.useQuery<GetDefaultCardQuery, GetDefaultCardQueryVariables>(GetDefaultCardDocument, baseOptions);
      }
export function useGetDefaultCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDefaultCardQuery, GetDefaultCardQueryVariables>) {
          return Apollo.useLazyQuery<GetDefaultCardQuery, GetDefaultCardQueryVariables>(GetDefaultCardDocument, baseOptions);
        }
export type GetDefaultCardQueryHookResult = ReturnType<typeof useGetDefaultCardQuery>;
export type GetDefaultCardLazyQueryHookResult = ReturnType<typeof useGetDefaultCardLazyQuery>;
export type GetDefaultCardQueryResult = Apollo.QueryResult<GetDefaultCardQuery, GetDefaultCardQueryVariables>;
export const FindDashboardNameWithRedirectDocument = gql`
    query FindDashboardNameWithRedirect($redirect_from: String) {
  dashboards(where: {redirect_from: {_eq: $redirect_from}}) {
    id
    slug
    user {
      id
      name
    }
    team {
      id
      handle
    }
  }
}
    `;

/**
 * __useFindDashboardNameWithRedirectQuery__
 *
 * To run a query within a React component, call `useFindDashboardNameWithRedirectQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindDashboardNameWithRedirectQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindDashboardNameWithRedirectQuery({
 *   variables: {
 *      redirect_from: // value for 'redirect_from'
 *   },
 * });
 */
export function useFindDashboardNameWithRedirectQuery(baseOptions?: Apollo.QueryHookOptions<FindDashboardNameWithRedirectQuery, FindDashboardNameWithRedirectQueryVariables>) {
        return Apollo.useQuery<FindDashboardNameWithRedirectQuery, FindDashboardNameWithRedirectQueryVariables>(FindDashboardNameWithRedirectDocument, baseOptions);
      }
export function useFindDashboardNameWithRedirectLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindDashboardNameWithRedirectQuery, FindDashboardNameWithRedirectQueryVariables>) {
          return Apollo.useLazyQuery<FindDashboardNameWithRedirectQuery, FindDashboardNameWithRedirectQueryVariables>(FindDashboardNameWithRedirectDocument, baseOptions);
        }
export type FindDashboardNameWithRedirectQueryHookResult = ReturnType<typeof useFindDashboardNameWithRedirectQuery>;
export type FindDashboardNameWithRedirectLazyQueryHookResult = ReturnType<typeof useFindDashboardNameWithRedirectLazyQuery>;
export type FindDashboardNameWithRedirectQueryResult = Apollo.QueryResult<FindDashboardNameWithRedirectQuery, FindDashboardNameWithRedirectQueryVariables>;
export const IsHandleAvailableDocument = gql`
    query IsHandleAvailable($username: String!) {
  handles_aggregate(where: {handle: {_ilike: $username}}) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useIsHandleAvailableQuery__
 *
 * To run a query within a React component, call `useIsHandleAvailableQuery` and pass it any options that fit your needs.
 * When your component renders, `useIsHandleAvailableQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIsHandleAvailableQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useIsHandleAvailableQuery(baseOptions: Apollo.QueryHookOptions<IsHandleAvailableQuery, IsHandleAvailableQueryVariables>) {
        return Apollo.useQuery<IsHandleAvailableQuery, IsHandleAvailableQueryVariables>(IsHandleAvailableDocument, baseOptions);
      }
export function useIsHandleAvailableLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IsHandleAvailableQuery, IsHandleAvailableQueryVariables>) {
          return Apollo.useLazyQuery<IsHandleAvailableQuery, IsHandleAvailableQueryVariables>(IsHandleAvailableDocument, baseOptions);
        }
export type IsHandleAvailableQueryHookResult = ReturnType<typeof useIsHandleAvailableQuery>;
export type IsHandleAvailableLazyQueryHookResult = ReturnType<typeof useIsHandleAvailableLazyQuery>;
export type IsHandleAvailableQueryResult = Apollo.QueryResult<IsHandleAvailableQuery, IsHandleAvailableQueryVariables>;
export const FindUserForDashboardDocument = gql`
    query FindUserForDashboard($slug: String!, $before: timestamptz!) {
  dashboards(where: {slug: {_eq: $slug}, created_at: {_lt: $before}}) {
    user {
      name
    }
  }
}
    `;

/**
 * __useFindUserForDashboardQuery__
 *
 * To run a query within a React component, call `useFindUserForDashboardQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindUserForDashboardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindUserForDashboardQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      before: // value for 'before'
 *   },
 * });
 */
export function useFindUserForDashboardQuery(baseOptions: Apollo.QueryHookOptions<FindUserForDashboardQuery, FindUserForDashboardQueryVariables>) {
        return Apollo.useQuery<FindUserForDashboardQuery, FindUserForDashboardQueryVariables>(FindUserForDashboardDocument, baseOptions);
      }
export function useFindUserForDashboardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindUserForDashboardQuery, FindUserForDashboardQueryVariables>) {
          return Apollo.useLazyQuery<FindUserForDashboardQuery, FindUserForDashboardQueryVariables>(FindUserForDashboardDocument, baseOptions);
        }
export type FindUserForDashboardQueryHookResult = ReturnType<typeof useFindUserForDashboardQuery>;
export type FindUserForDashboardLazyQueryHookResult = ReturnType<typeof useFindUserForDashboardLazyQuery>;
export type FindUserForDashboardQueryResult = Apollo.QueryResult<FindUserForDashboardQuery, FindUserForDashboardQueryVariables>;
export const FindDashboardForKeyDocument = gql`
    query FindDashboardForKey($api_key: String!) {
  api_keys(where: {id: {_eq: $api_key}}) {
    dashboard {
      slug
      is_private
      user {
        name
      }
    }
  }
}
    `;

/**
 * __useFindDashboardForKeyQuery__
 *
 * To run a query within a React component, call `useFindDashboardForKeyQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindDashboardForKeyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindDashboardForKeyQuery({
 *   variables: {
 *      api_key: // value for 'api_key'
 *   },
 * });
 */
export function useFindDashboardForKeyQuery(baseOptions: Apollo.QueryHookOptions<FindDashboardForKeyQuery, FindDashboardForKeyQueryVariables>) {
        return Apollo.useQuery<FindDashboardForKeyQuery, FindDashboardForKeyQueryVariables>(FindDashboardForKeyDocument, baseOptions);
      }
export function useFindDashboardForKeyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindDashboardForKeyQuery, FindDashboardForKeyQueryVariables>) {
          return Apollo.useLazyQuery<FindDashboardForKeyQuery, FindDashboardForKeyQueryVariables>(FindDashboardForKeyDocument, baseOptions);
        }
export type FindDashboardForKeyQueryHookResult = ReturnType<typeof useFindDashboardForKeyQuery>;
export type FindDashboardForKeyLazyQueryHookResult = ReturnType<typeof useFindDashboardForKeyLazyQuery>;
export type FindDashboardForKeyQueryResult = Apollo.QueryResult<FindDashboardForKeyQuery, FindDashboardForKeyQueryVariables>;
export const GetServiceTierInfoByNameDocument = gql`
    query GetServiceTierInfoByName($service_tier_name: String!) {
  user_service_tiers(
    where: {name: {_eq: $service_tier_name}, is_public: {_eq: true}}
  ) {
    id
    name
    base_monthly_price_dollars_cents
    max_private_queries
    max_private_dashboards
    remove_watermark
    csv_downloads_per_month
    performance
    included_query_executions
    included_nanocredits
    nanocredits_cost_cents
    query_exec_overage_dollars_cents
    is_public
    release_version
  }
}
    `;

/**
 * __useGetServiceTierInfoByNameQuery__
 *
 * To run a query within a React component, call `useGetServiceTierInfoByNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetServiceTierInfoByNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetServiceTierInfoByNameQuery({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useGetServiceTierInfoByNameQuery(baseOptions: Apollo.QueryHookOptions<GetServiceTierInfoByNameQuery, GetServiceTierInfoByNameQueryVariables>) {
        return Apollo.useQuery<GetServiceTierInfoByNameQuery, GetServiceTierInfoByNameQueryVariables>(GetServiceTierInfoByNameDocument, baseOptions);
      }
export function useGetServiceTierInfoByNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetServiceTierInfoByNameQuery, GetServiceTierInfoByNameQueryVariables>) {
          return Apollo.useLazyQuery<GetServiceTierInfoByNameQuery, GetServiceTierInfoByNameQueryVariables>(GetServiceTierInfoByNameDocument, baseOptions);
        }
export type GetServiceTierInfoByNameQueryHookResult = ReturnType<typeof useGetServiceTierInfoByNameQuery>;
export type GetServiceTierInfoByNameLazyQueryHookResult = ReturnType<typeof useGetServiceTierInfoByNameLazyQuery>;
export type GetServiceTierInfoByNameQueryResult = Apollo.QueryResult<GetServiceTierInfoByNameQuery, GetServiceTierInfoByNameQueryVariables>;
export const GetApiUserServiceTierInfoByNameDocument = gql`
    query GetApiUserServiceTierInfoByName($service_tier_name: String!) {
  api_user_service_tiers(
    where: {name: {_eq: $service_tier_name}, is_public: {_eq: true}}
  ) {
    id
    name
    base_monthly_price_dollars_cents
    datapoint_overage_10k_cost_dollars_cents
    included_datapoints
    included_executions
    read_results_api_calls_per_minute
    dune_attribution_required
  }
}
    `;

/**
 * __useGetApiUserServiceTierInfoByNameQuery__
 *
 * To run a query within a React component, call `useGetApiUserServiceTierInfoByNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiUserServiceTierInfoByNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiUserServiceTierInfoByNameQuery({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useGetApiUserServiceTierInfoByNameQuery(baseOptions: Apollo.QueryHookOptions<GetApiUserServiceTierInfoByNameQuery, GetApiUserServiceTierInfoByNameQueryVariables>) {
        return Apollo.useQuery<GetApiUserServiceTierInfoByNameQuery, GetApiUserServiceTierInfoByNameQueryVariables>(GetApiUserServiceTierInfoByNameDocument, baseOptions);
      }
export function useGetApiUserServiceTierInfoByNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiUserServiceTierInfoByNameQuery, GetApiUserServiceTierInfoByNameQueryVariables>) {
          return Apollo.useLazyQuery<GetApiUserServiceTierInfoByNameQuery, GetApiUserServiceTierInfoByNameQueryVariables>(GetApiUserServiceTierInfoByNameDocument, baseOptions);
        }
export type GetApiUserServiceTierInfoByNameQueryHookResult = ReturnType<typeof useGetApiUserServiceTierInfoByNameQuery>;
export type GetApiUserServiceTierInfoByNameLazyQueryHookResult = ReturnType<typeof useGetApiUserServiceTierInfoByNameLazyQuery>;
export type GetApiUserServiceTierInfoByNameQueryResult = Apollo.QueryResult<GetApiUserServiceTierInfoByNameQuery, GetApiUserServiceTierInfoByNameQueryVariables>;
export const GetTeamServiceTierInfoByNameDocument = gql`
    query GetTeamServiceTierInfoByName($service_tier_name: String!) {
  team_service_tiers(
    where: {name: {_eq: $service_tier_name}, is_public: {_eq: true}}
  ) {
    id
    name
    base_monthly_price_dollars_cents
    max_private_queries
    max_private_dashboards
    remove_watermark
    csv_downloads_per_month
    performance
    included_query_executions
    query_exec_overage_dollars_cents
    max_query_event_retention_days
    included_nanocredits
    nanocredits_cost_cents
    release_version
  }
}
    `;

/**
 * __useGetTeamServiceTierInfoByNameQuery__
 *
 * To run a query within a React component, call `useGetTeamServiceTierInfoByNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamServiceTierInfoByNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamServiceTierInfoByNameQuery({
 *   variables: {
 *      service_tier_name: // value for 'service_tier_name'
 *   },
 * });
 */
export function useGetTeamServiceTierInfoByNameQuery(baseOptions: Apollo.QueryHookOptions<GetTeamServiceTierInfoByNameQuery, GetTeamServiceTierInfoByNameQueryVariables>) {
        return Apollo.useQuery<GetTeamServiceTierInfoByNameQuery, GetTeamServiceTierInfoByNameQueryVariables>(GetTeamServiceTierInfoByNameDocument, baseOptions);
      }
export function useGetTeamServiceTierInfoByNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamServiceTierInfoByNameQuery, GetTeamServiceTierInfoByNameQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamServiceTierInfoByNameQuery, GetTeamServiceTierInfoByNameQueryVariables>(GetTeamServiceTierInfoByNameDocument, baseOptions);
        }
export type GetTeamServiceTierInfoByNameQueryHookResult = ReturnType<typeof useGetTeamServiceTierInfoByNameQuery>;
export type GetTeamServiceTierInfoByNameLazyQueryHookResult = ReturnType<typeof useGetTeamServiceTierInfoByNameLazyQuery>;
export type GetTeamServiceTierInfoByNameQueryResult = Apollo.QueryResult<GetTeamServiceTierInfoByNameQuery, GetTeamServiceTierInfoByNameQueryVariables>;
export const SubmitOnboardingQsDocument = gql`
    mutation SubmitOnboardingQs($user_id: Int!, $brings_to_dune: String!, $achieve_with_dune: String!, $sql_experience: String, $blockchain_experience: String!, $organization_size: String, $version: String!, $until: timestamptz!) {
  insert_onboarding_questions(
    objects: {user_id: $user_id, brings_to_dune: $brings_to_dune, achieve_with_dune: $achieve_with_dune, sql_experience: $sql_experience, blockchain_experience: $blockchain_experience, organization_size: $organization_size, version: $version}
  ) {
    affected_rows
  }
  update_users(
    where: {id: {_eq: $user_id}}
    _set: {onboarding_qs_skipped_until: $until}
  ) {
    returning {
      id
      private_info {
        onboarding_qs_skipped_until
      }
    }
  }
}
    `;
export type SubmitOnboardingQsMutationFn = Apollo.MutationFunction<SubmitOnboardingQsMutation, SubmitOnboardingQsMutationVariables>;

/**
 * __useSubmitOnboardingQsMutation__
 *
 * To run a mutation, you first call `useSubmitOnboardingQsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitOnboardingQsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitOnboardingQsMutation, { data, loading, error }] = useSubmitOnboardingQsMutation({
 *   variables: {
 *      user_id: // value for 'user_id'
 *      brings_to_dune: // value for 'brings_to_dune'
 *      achieve_with_dune: // value for 'achieve_with_dune'
 *      sql_experience: // value for 'sql_experience'
 *      blockchain_experience: // value for 'blockchain_experience'
 *      organization_size: // value for 'organization_size'
 *      version: // value for 'version'
 *      until: // value for 'until'
 *   },
 * });
 */
export function useSubmitOnboardingQsMutation(baseOptions?: Apollo.MutationHookOptions<SubmitOnboardingQsMutation, SubmitOnboardingQsMutationVariables>) {
        return Apollo.useMutation<SubmitOnboardingQsMutation, SubmitOnboardingQsMutationVariables>(SubmitOnboardingQsDocument, baseOptions);
      }
export type SubmitOnboardingQsMutationHookResult = ReturnType<typeof useSubmitOnboardingQsMutation>;
export type SubmitOnboardingQsMutationResult = Apollo.MutationResult<SubmitOnboardingQsMutation>;
export type SubmitOnboardingQsMutationOptions = Apollo.BaseMutationOptions<SubmitOnboardingQsMutation, SubmitOnboardingQsMutationVariables>;
export const SkipOnboardingQsDocument = gql`
    mutation SkipOnboardingQs($user_id: Int!, $until: timestamptz!) {
  update_users(
    where: {id: {_eq: $user_id}}
    _set: {onboarding_qs_skipped_until: $until}
  ) {
    returning {
      id
      private_info {
        onboarding_qs_skipped_until
      }
    }
  }
}
    `;
export type SkipOnboardingQsMutationFn = Apollo.MutationFunction<SkipOnboardingQsMutation, SkipOnboardingQsMutationVariables>;

/**
 * __useSkipOnboardingQsMutation__
 *
 * To run a mutation, you first call `useSkipOnboardingQsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSkipOnboardingQsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [skipOnboardingQsMutation, { data, loading, error }] = useSkipOnboardingQsMutation({
 *   variables: {
 *      user_id: // value for 'user_id'
 *      until: // value for 'until'
 *   },
 * });
 */
export function useSkipOnboardingQsMutation(baseOptions?: Apollo.MutationHookOptions<SkipOnboardingQsMutation, SkipOnboardingQsMutationVariables>) {
        return Apollo.useMutation<SkipOnboardingQsMutation, SkipOnboardingQsMutationVariables>(SkipOnboardingQsDocument, baseOptions);
      }
export type SkipOnboardingQsMutationHookResult = ReturnType<typeof useSkipOnboardingQsMutation>;
export type SkipOnboardingQsMutationResult = Apollo.MutationResult<SkipOnboardingQsMutation>;
export type SkipOnboardingQsMutationOptions = Apollo.BaseMutationOptions<SkipOnboardingQsMutation, SkipOnboardingQsMutationVariables>;
export const GetTeamOperationCostsDocument = gql`
    query GetTeamOperationCosts($teamId: Int!) {
  team_operation_costs(team_id: $teamId) {
    key
    interactive_executions {
      dataset_id
      public_performance_tier_key
      credits
    }
  }
}
    `;

/**
 * __useGetTeamOperationCostsQuery__
 *
 * To run a query within a React component, call `useGetTeamOperationCostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamOperationCostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamOperationCostsQuery({
 *   variables: {
 *      teamId: // value for 'teamId'
 *   },
 * });
 */
export function useGetTeamOperationCostsQuery(baseOptions: Apollo.QueryHookOptions<GetTeamOperationCostsQuery, GetTeamOperationCostsQueryVariables>) {
        return Apollo.useQuery<GetTeamOperationCostsQuery, GetTeamOperationCostsQueryVariables>(GetTeamOperationCostsDocument, baseOptions);
      }
export function useGetTeamOperationCostsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTeamOperationCostsQuery, GetTeamOperationCostsQueryVariables>) {
          return Apollo.useLazyQuery<GetTeamOperationCostsQuery, GetTeamOperationCostsQueryVariables>(GetTeamOperationCostsDocument, baseOptions);
        }
export type GetTeamOperationCostsQueryHookResult = ReturnType<typeof useGetTeamOperationCostsQuery>;
export type GetTeamOperationCostsLazyQueryHookResult = ReturnType<typeof useGetTeamOperationCostsLazyQuery>;
export type GetTeamOperationCostsQueryResult = Apollo.QueryResult<GetTeamOperationCostsQuery, GetTeamOperationCostsQueryVariables>;
export const GetUserOperationCostsDocument = gql`
    query GetUserOperationCosts {
  user_operation_costs {
    key
    interactive_executions {
      dataset_id
      public_performance_tier_key
      credits
    }
  }
}
    `;

/**
 * __useGetUserOperationCostsQuery__
 *
 * To run a query within a React component, call `useGetUserOperationCostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserOperationCostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserOperationCostsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUserOperationCostsQuery(baseOptions?: Apollo.QueryHookOptions<GetUserOperationCostsQuery, GetUserOperationCostsQueryVariables>) {
        return Apollo.useQuery<GetUserOperationCostsQuery, GetUserOperationCostsQueryVariables>(GetUserOperationCostsDocument, baseOptions);
      }
export function useGetUserOperationCostsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserOperationCostsQuery, GetUserOperationCostsQueryVariables>) {
          return Apollo.useLazyQuery<GetUserOperationCostsQuery, GetUserOperationCostsQueryVariables>(GetUserOperationCostsDocument, baseOptions);
        }
export type GetUserOperationCostsQueryHookResult = ReturnType<typeof useGetUserOperationCostsQuery>;
export type GetUserOperationCostsLazyQueryHookResult = ReturnType<typeof useGetUserOperationCostsLazyQuery>;
export type GetUserOperationCostsQueryResult = Apollo.QueryResult<GetUserOperationCostsQuery, GetUserOperationCostsQueryVariables>;
export const ExecuteQueryV3Document = gql`
    mutation ExecuteQueryV3($query_id: Int!, $executor: ContextOwner!, $performance: String, $parameters: [Parameter!]!) {
  execute_query_v3(
    query_id: $query_id
    executor: $executor
    performance: $performance
    parameters: $parameters
  ) {
    job_id
  }
}
    `;
export type ExecuteQueryV3MutationFn = Apollo.MutationFunction<ExecuteQueryV3Mutation, ExecuteQueryV3MutationVariables>;

/**
 * __useExecuteQueryV3Mutation__
 *
 * To run a mutation, you first call `useExecuteQueryV3Mutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExecuteQueryV3Mutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [executeQueryV3Mutation, { data, loading, error }] = useExecuteQueryV3Mutation({
 *   variables: {
 *      query_id: // value for 'query_id'
 *      executor: // value for 'executor'
 *      performance: // value for 'performance'
 *      parameters: // value for 'parameters'
 *   },
 * });
 */
export function useExecuteQueryV3Mutation(baseOptions?: Apollo.MutationHookOptions<ExecuteQueryV3Mutation, ExecuteQueryV3MutationVariables>) {
        return Apollo.useMutation<ExecuteQueryV3Mutation, ExecuteQueryV3MutationVariables>(ExecuteQueryV3Document, baseOptions);
      }
export type ExecuteQueryV3MutationHookResult = ReturnType<typeof useExecuteQueryV3Mutation>;
export type ExecuteQueryV3MutationResult = Apollo.MutationResult<ExecuteQueryV3Mutation>;
export type ExecuteQueryV3MutationOptions = Apollo.BaseMutationOptions<ExecuteQueryV3Mutation, ExecuteQueryV3MutationVariables>;
export const AcceptInviteDocument = gql`
    mutation AcceptInvite($id: uuid!) {
  accept_invite_v2(membership_id: $id) {
    ok
  }
}
    `;
export type AcceptInviteMutationFn = Apollo.MutationFunction<AcceptInviteMutation, AcceptInviteMutationVariables>;

/**
 * __useAcceptInviteMutation__
 *
 * To run a mutation, you first call `useAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [acceptInviteMutation, { data, loading, error }] = useAcceptInviteMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<AcceptInviteMutation, AcceptInviteMutationVariables>) {
        return Apollo.useMutation<AcceptInviteMutation, AcceptInviteMutationVariables>(AcceptInviteDocument, baseOptions);
      }
export type AcceptInviteMutationHookResult = ReturnType<typeof useAcceptInviteMutation>;
export type AcceptInviteMutationResult = Apollo.MutationResult<AcceptInviteMutation>;
export type AcceptInviteMutationOptions = Apollo.BaseMutationOptions<AcceptInviteMutation, AcceptInviteMutationVariables>;
export const UpdateTeamMemberRoleDocument = gql`
    mutation UpdateTeamMemberRole($id: uuid!, $role: membership_roles!) {
  update_memberships_by_pk(pk_columns: {id: $id}, _set: {role: $role}) {
    id
    private_details {
      id
      role
      status
    }
    user {
      id
      name
      profile_image_url
    }
    team {
      id
      name
    }
  }
}
    `;
export type UpdateTeamMemberRoleMutationFn = Apollo.MutationFunction<UpdateTeamMemberRoleMutation, UpdateTeamMemberRoleMutationVariables>;

/**
 * __useUpdateTeamMemberRoleMutation__
 *
 * To run a mutation, you first call `useUpdateTeamMemberRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamMemberRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamMemberRoleMutation, { data, loading, error }] = useUpdateTeamMemberRoleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      role: // value for 'role'
 *   },
 * });
 */
export function useUpdateTeamMemberRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTeamMemberRoleMutation, UpdateTeamMemberRoleMutationVariables>) {
        return Apollo.useMutation<UpdateTeamMemberRoleMutation, UpdateTeamMemberRoleMutationVariables>(UpdateTeamMemberRoleDocument, baseOptions);
      }
export type UpdateTeamMemberRoleMutationHookResult = ReturnType<typeof useUpdateTeamMemberRoleMutation>;
export type UpdateTeamMemberRoleMutationResult = Apollo.MutationResult<UpdateTeamMemberRoleMutation>;
export type UpdateTeamMemberRoleMutationOptions = Apollo.BaseMutationOptions<UpdateTeamMemberRoleMutation, UpdateTeamMemberRoleMutationVariables>;
export const CreateTeamDocument = gql`
    mutation CreateTeam($name: String!, $handle: String!, $profile_image_url: String) {
  create_team(name: $name, handle: $handle, profile_image_url: $profile_image_url) {
    team_id
  }
}
    `;
export type CreateTeamMutationFn = Apollo.MutationFunction<CreateTeamMutation, CreateTeamMutationVariables>;

/**
 * __useCreateTeamMutation__
 *
 * To run a mutation, you first call `useCreateTeamMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTeamMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTeamMutation, { data, loading, error }] = useCreateTeamMutation({
 *   variables: {
 *      name: // value for 'name'
 *      handle: // value for 'handle'
 *      profile_image_url: // value for 'profile_image_url'
 *   },
 * });
 */
export function useCreateTeamMutation(baseOptions?: Apollo.MutationHookOptions<CreateTeamMutation, CreateTeamMutationVariables>) {
        return Apollo.useMutation<CreateTeamMutation, CreateTeamMutationVariables>(CreateTeamDocument, baseOptions);
      }
export type CreateTeamMutationHookResult = ReturnType<typeof useCreateTeamMutation>;
export type CreateTeamMutationResult = Apollo.MutationResult<CreateTeamMutation>;
export type CreateTeamMutationOptions = Apollo.BaseMutationOptions<CreateTeamMutation, CreateTeamMutationVariables>;
export const DeleteTeamDocument = gql`
    mutation DeleteTeam($id: Int!) {
  delete_team(team_id: $id) {
    ok
  }
}
    `;
export type DeleteTeamMutationFn = Apollo.MutationFunction<DeleteTeamMutation, DeleteTeamMutationVariables>;

/**
 * __useDeleteTeamMutation__
 *
 * To run a mutation, you first call `useDeleteTeamMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTeamMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTeamMutation, { data, loading, error }] = useDeleteTeamMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteTeamMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTeamMutation, DeleteTeamMutationVariables>) {
        return Apollo.useMutation<DeleteTeamMutation, DeleteTeamMutationVariables>(DeleteTeamDocument, baseOptions);
      }
export type DeleteTeamMutationHookResult = ReturnType<typeof useDeleteTeamMutation>;
export type DeleteTeamMutationResult = Apollo.MutationResult<DeleteTeamMutation>;
export type DeleteTeamMutationOptions = Apollo.BaseMutationOptions<DeleteTeamMutation, DeleteTeamMutationVariables>;
export const DeleteMembershipDocument = gql`
    mutation DeleteMembership($id: uuid!) {
  delete_memberships_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteMembershipMutationFn = Apollo.MutationFunction<DeleteMembershipMutation, DeleteMembershipMutationVariables>;

/**
 * __useDeleteMembershipMutation__
 *
 * To run a mutation, you first call `useDeleteMembershipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteMembershipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteMembershipMutation, { data, loading, error }] = useDeleteMembershipMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteMembershipMutation(baseOptions?: Apollo.MutationHookOptions<DeleteMembershipMutation, DeleteMembershipMutationVariables>) {
        return Apollo.useMutation<DeleteMembershipMutation, DeleteMembershipMutationVariables>(DeleteMembershipDocument, baseOptions);
      }
export type DeleteMembershipMutationHookResult = ReturnType<typeof useDeleteMembershipMutation>;
export type DeleteMembershipMutationResult = Apollo.MutationResult<DeleteMembershipMutation>;
export type DeleteMembershipMutationOptions = Apollo.BaseMutationOptions<DeleteMembershipMutation, DeleteMembershipMutationVariables>;
export const ListUserMembershipsDocument = gql`
    query ListUserMemberships($user_id: Int, $user_email: String) {
  memberships_private_details(
    where: {_or: [{user_id: {_eq: $user_id}}, {email: {_eq: $user_email}}]}
    order_by: [{status: desc}, {role: desc}]
  ) {
    id
    role
    status
    team {
      id
      name
      handle
      profile_image_url
      service_tier {
        id
        name
        release_version
        is_public
        csv_downloads_per_month
        included_datapoints
        included_nanocredits
      }
    }
  }
}
    `;

/**
 * __useListUserMembershipsQuery__
 *
 * To run a query within a React component, call `useListUserMembershipsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListUserMembershipsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListUserMembershipsQuery({
 *   variables: {
 *      user_id: // value for 'user_id'
 *      user_email: // value for 'user_email'
 *   },
 * });
 */
export function useListUserMembershipsQuery(baseOptions?: Apollo.QueryHookOptions<ListUserMembershipsQuery, ListUserMembershipsQueryVariables>) {
        return Apollo.useQuery<ListUserMembershipsQuery, ListUserMembershipsQueryVariables>(ListUserMembershipsDocument, baseOptions);
      }
export function useListUserMembershipsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListUserMembershipsQuery, ListUserMembershipsQueryVariables>) {
          return Apollo.useLazyQuery<ListUserMembershipsQuery, ListUserMembershipsQueryVariables>(ListUserMembershipsDocument, baseOptions);
        }
export type ListUserMembershipsQueryHookResult = ReturnType<typeof useListUserMembershipsQuery>;
export type ListUserMembershipsLazyQueryHookResult = ReturnType<typeof useListUserMembershipsLazyQuery>;
export type ListUserMembershipsQueryResult = Apollo.QueryResult<ListUserMembershipsQuery, ListUserMembershipsQueryVariables>;
export const ListTeamMembersDocument = gql`
    query ListTeamMembers($team_id: Int!) {
  memberships_private_details(
    where: {team_id: {_eq: $team_id}}
    order_by: [{status: desc}, {role: desc}]
  ) {
    id
    role
    status
    email
    team {
      id
      name
    }
    user {
      id
      name
      profile_image_url
    }
  }
}
    `;

/**
 * __useListTeamMembersQuery__
 *
 * To run a query within a React component, call `useListTeamMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useListTeamMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListTeamMembersQuery({
 *   variables: {
 *      team_id: // value for 'team_id'
 *   },
 * });
 */
export function useListTeamMembersQuery(baseOptions: Apollo.QueryHookOptions<ListTeamMembersQuery, ListTeamMembersQueryVariables>) {
        return Apollo.useQuery<ListTeamMembersQuery, ListTeamMembersQueryVariables>(ListTeamMembersDocument, baseOptions);
      }
export function useListTeamMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListTeamMembersQuery, ListTeamMembersQueryVariables>) {
          return Apollo.useLazyQuery<ListTeamMembersQuery, ListTeamMembersQueryVariables>(ListTeamMembersDocument, baseOptions);
        }
export type ListTeamMembersQueryHookResult = ReturnType<typeof useListTeamMembersQuery>;
export type ListTeamMembersLazyQueryHookResult = ReturnType<typeof useListTeamMembersLazyQuery>;
export type ListTeamMembersQueryResult = Apollo.QueryResult<ListTeamMembersQuery, ListTeamMembersQueryVariables>;